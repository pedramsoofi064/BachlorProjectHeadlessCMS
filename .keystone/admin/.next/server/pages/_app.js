(() => {
var exports = {};
exports.id = "pages/_app";
exports.ids = ["pages/_app"];
exports.modules = {

/***/ "../../node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*******************************************************************/
/***/ ((module) => {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/extends.js":
/*!************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/extends.js ***!
  \************************************************************/
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports.default = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/objectSpread2.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/objectSpread2.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

module.exports = _objectSpread2;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js").default;

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

module.exports = _toPrimitive;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../node_modules/@babel/runtime/helpers/typeof.js").default;

var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "../../node_modules/@babel/runtime/helpers/toPrimitive.js");

function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

module.exports = _toPropertyKey;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/typeof.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@babel/runtime/helpers/typeof.js ***!
  \***********************************************************/
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports.default = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports.default = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports.default = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "../../node_modules/@keystone-next/fields-document/dist/api-93436025.cjs.dev.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/fields-document/dist/api-93436025.cjs.dev.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields$1 = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var React = __webpack_require__(/*! react */ "react");
var sanitizeUrl = __webpack_require__(/*! @braintree/sanitize-url */ "@braintree/sanitize-url");

function isValidURL(url) {
  return url === sanitizeUrl.sanitizeUrl(url);
}

const _excluded = ["children"];
const fields = {
  text({
    label,
    defaultValue = ''
  }) {
    return {
      kind: 'form',

      Input({
        value,
        onChange,
        autoFocus
      }) {
        return core.jsx(fields$1.FieldContainer, null, core.jsx(fields$1.FieldLabel, null, label), core.jsx(fields$1.TextInput, {
          autoFocus: autoFocus,
          value: value,
          onChange: event => {
            onChange(event.target.value);
          }
        }));
      },

      options: undefined,
      defaultValue,

      validate(value) {
        return typeof value === 'string';
      }

    };
  },

  url({
    label,
    defaultValue = ''
  }) {
    const validate = value => {
      return typeof value === 'string' && (value === '' || isValidURL(value));
    };

    return {
      kind: 'form',

      Input({
        value,
        onChange,
        autoFocus,
        forceValidation
      }) {
        const [blurred, setBlurred] = React.useState(false);
        const showValidation = forceValidation || blurred && !validate(value);
        return core.jsx(fields$1.FieldContainer, null, core.jsx(fields$1.FieldLabel, null, label), core.jsx(fields$1.TextInput, {
          onBlur: () => {
            setBlurred(true);
          },
          autoFocus: autoFocus,
          value: value,
          onChange: event => {
            onChange(event.target.value);
          }
        }), showValidation && core.jsx("span", {
          css: {
            color: 'red'
          }
        }, "Please provide a valid URL"));
      },

      options: undefined,
      defaultValue,
      validate
    };
  },

  select({
    label,
    options,
    defaultValue
  }) {
    const optionValuesSet = new Set(options.map(x => x.value));
    return {
      kind: 'form',

      Input({
        value,
        onChange,
        autoFocus
      }) {
        return core.jsx(fields$1.FieldContainer, null, core.jsx(fields$1.FieldLabel, null, label), core.jsx(fields$1.Select, {
          autoFocus: autoFocus,
          value: options.find(option => option.value === value) || null,
          onChange: option => {
            if (option) {
              onChange(option.value);
            }
          },
          options: options
        }));
      },

      options,
      defaultValue,

      validate(value) {
        return typeof value === 'string' && optionValuesSet.has(value);
      }

    };
  },

  multiselect({
    label,
    options,
    defaultValue
  }) {
    const valuesToOption = new Map(options.map(x => [x.value, x]));
    return {
      kind: 'form',

      Input({
        value,
        onChange,
        autoFocus
      }) {
        return core.jsx(fields$1.FieldContainer, null, core.jsx(fields$1.FieldLabel, null, label), core.jsx(fields$1.MultiSelect, {
          autoFocus: autoFocus,
          value: value.map(x => valuesToOption.get(x)),
          options: options,
          onChange: options => {
            onChange(options.map(x => x.value));
          }
        }));
      },

      options,
      defaultValue,

      validate(value) {
        return Array.isArray(value) && value.every(value => typeof value === 'string' && valuesToOption.has(value));
      }

    };
  },

  checkbox({
    label,
    defaultValue = false
  }) {
    return {
      kind: 'form',

      Input({
        value,
        onChange,
        autoFocus
      }) {
        return core.jsx(fields$1.FieldContainer, null, core.jsx(fields$1.Checkbox, {
          checked: value,
          autoFocus: autoFocus,
          onChange: event => {
            onChange(event.target.checked);
          }
        }, label));
      },

      options: undefined,
      defaultValue,

      validate(value) {
        return typeof value === 'boolean';
      }

    };
  },

  empty() {
    return {
      kind: 'form',

      Input() {
        return null;
      },

      options: undefined,
      defaultValue: undefined,

      validate(value) {
        return value === undefined;
      }

    };
  },

  child(options) {
    return {
      kind: 'child',
      options: options.kind === 'block' ? {
        kind: 'block',
        placeholder: options.placeholder,
        dividers: options.dividers,
        formatting: options.formatting === 'inherit' ? {
          blockTypes: 'inherit',
          headingLevels: 'inherit',
          inlineMarks: 'inherit',
          listTypes: 'inherit',
          alignment: 'inherit',
          softBreaks: 'inherit'
        } : options.formatting,
        links: options.links,
        relationships: options.relationships
      } : {
        kind: 'inline',
        placeholder: options.placeholder,
        formatting: options.formatting === 'inherit' ? {
          inlineMarks: 'inherit',
          softBreaks: 'inherit'
        } : options.formatting,
        links: options.links,
        relationships: options.relationships
      }
    };
  },

  object(value) {
    return {
      kind: 'object',
      value
    };
  },

  conditional(discriminant, values) {
    return {
      kind: 'conditional',
      discriminant,
      values: values
    };
  },

  relationship({
    relationship,
    label
  }) {
    return {
      kind: 'relationship',
      relationship,
      label
    };
  }

};
function component(options) {
  return options;
}
const NotEditable = _ref => {
  let {
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  return core.jsx("span", _extends({
    css: {
      userSelect: 'none'
    },
    contentEditable: false
  }, props), children);
};

exports.NotEditable = NotEditable;
exports.component = component;
exports.fields = fields;
exports.isValidURL = isValidURL;


/***/ }),

/***/ "../../node_modules/@keystone-next/fields-document/dist/index-9ba2e5f2.cjs.dev.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/fields-document/dist/index-9ba2e5f2.cjs.dev.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var React = __webpack_require__(/*! react */ "react");
var isHotkey = __webpack_require__(/*! is-hotkey */ "is-hotkey");
var slate = __webpack_require__(/*! slate */ "slate");
var slateReact = __webpack_require__(/*! slate-react */ "slate-react");
var slateHistory = __webpack_require__(/*! slate-history */ "slate-history");
var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var popover = __webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
var tooltip = __webpack_require__(/*! @keystone-ui/tooltip */ "@keystone-ui/tooltip");
var LinkIcon = __webpack_require__(/*! @keystone-ui/icons/icons/LinkIcon */ "@keystone-ui/icons/icons/LinkIcon");
var Trash2Icon = __webpack_require__(/*! @keystone-ui/icons/icons/Trash2Icon */ "@keystone-ui/icons/icons/Trash2Icon");
var ExternalLinkIcon = __webpack_require__(/*! @keystone-ui/icons/icons/ExternalLinkIcon */ "@keystone-ui/icons/icons/ExternalLinkIcon");
var toolbar = __webpack_require__(/*! ./toolbar-2700d97c.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/dist/toolbar-2700d97c.cjs.dev.js");
var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var api = __webpack_require__(/*! ./api-93436025.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/dist/api-93436025.cjs.dev.js");
var context = __webpack_require__(/*! @keystone-next/keystone/admin-ui/context */ "@keystone-next/keystone/admin-ui/context");
var RelationshipSelect = __webpack_require__(/*! @keystone-next/keystone/fields/types/relationship/views/RelationshipSelect */ "@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var weakMemoize = __webpack_require__(/*! @emotion/weak-memoize */ "@emotion/weak-memoize");
var ColumnsIcon = __webpack_require__(/*! @keystone-ui/icons/icons/ColumnsIcon */ "@keystone-ui/icons/icons/ColumnsIcon");
var applyRef = __webpack_require__(/*! apply-ref */ "apply-ref");
var BoldIcon = __webpack_require__(/*! @keystone-ui/icons/icons/BoldIcon */ "@keystone-ui/icons/icons/BoldIcon");
var ItalicIcon = __webpack_require__(/*! @keystone-ui/icons/icons/ItalicIcon */ "@keystone-ui/icons/icons/ItalicIcon");
var PlusIcon = __webpack_require__(/*! @keystone-ui/icons/icons/PlusIcon */ "@keystone-ui/icons/icons/PlusIcon");
var ChevronDownIcon = __webpack_require__(/*! @keystone-ui/icons/icons/ChevronDownIcon */ "@keystone-ui/icons/icons/ChevronDownIcon");
var Maximize2Icon = __webpack_require__(/*! @keystone-ui/icons/icons/Maximize2Icon */ "@keystone-ui/icons/icons/Maximize2Icon");
var Minimize2Icon = __webpack_require__(/*! @keystone-ui/icons/icons/Minimize2Icon */ "@keystone-ui/icons/icons/Minimize2Icon");
var MoreHorizontalIcon = __webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
var CodeIcon = __webpack_require__(/*! @keystone-ui/icons/icons/CodeIcon */ "@keystone-ui/icons/icons/CodeIcon");
var AlignLeftIcon = __webpack_require__(/*! @keystone-ui/icons/icons/AlignLeftIcon */ "@keystone-ui/icons/icons/AlignLeftIcon");
var AlignRightIcon = __webpack_require__(/*! @keystone-ui/icons/icons/AlignRightIcon */ "@keystone-ui/icons/icons/AlignRightIcon");
var AlignCenterIcon = __webpack_require__(/*! @keystone-ui/icons/icons/AlignCenterIcon */ "@keystone-ui/icons/icons/AlignCenterIcon");
var MinusIcon = __webpack_require__(/*! @keystone-ui/icons/icons/MinusIcon */ "@keystone-ui/icons/icons/MinusIcon");
var matchSorter = __webpack_require__(/*! match-sorter */ "match-sorter");
var scrollIntoView = __webpack_require__(/*! scroll-into-view-if-needed */ "scroll-into-view-if-needed");
var mdASTUtilFromMarkdown = __webpack_require__(/*! mdast-util-from-markdown */ "mdast-util-from-markdown");
var autoLinkLiteralFromMarkdownExtension = __webpack_require__(/*! mdast-util-gfm-autolink-literal/from-markdown */ "mdast-util-gfm-autolink-literal/from-markdown");
var autoLinkLiteralMarkdownSyntax = __webpack_require__(/*! micromark-extension-gfm-autolink-literal */ "micromark-extension-gfm-autolink-literal");
var gfmStrikethroughFromMarkdownExtension = __webpack_require__(/*! mdast-util-gfm-strikethrough/from-markdown */ "mdast-util-gfm-strikethrough/from-markdown");
var gfmStrikethroughMarkdownSyntax = __webpack_require__(/*! micromark-extension-gfm-strikethrough */ "micromark-extension-gfm-strikethrough");
var definitions = __webpack_require__(/*! mdast-util-definitions */ "mdast-util-definitions");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var isHotkey__default = /*#__PURE__*/_interopDefault(isHotkey);
var weakMemoize__default = /*#__PURE__*/_interopDefault(weakMemoize);
var scrollIntoView__default = /*#__PURE__*/_interopDefault(scrollIntoView);
var mdASTUtilFromMarkdown__default = /*#__PURE__*/_interopDefault(mdASTUtilFromMarkdown);
var autoLinkLiteralFromMarkdownExtension__default = /*#__PURE__*/_interopDefault(autoLinkLiteralFromMarkdownExtension);
var autoLinkLiteralMarkdownSyntax__default = /*#__PURE__*/_interopDefault(autoLinkLiteralMarkdownSyntax);
var gfmStrikethroughFromMarkdownExtension__default = /*#__PURE__*/_interopDefault(gfmStrikethroughFromMarkdownExtension);
var gfmStrikethroughMarkdownSyntax__default = /*#__PURE__*/_interopDefault(gfmStrikethroughMarkdownSyntax);
var definitions__default = /*#__PURE__*/_interopDefault(definitions);

const paragraphElement = () => ({
  type: 'paragraph',
  children: [{
    text: ''
  }]
});
function withParagraphs(editor) {
  const {
    normalizeNode
  } = editor;

  editor.normalizeNode = entry => {
    const [node, path] = entry;

    if (slate.Editor.isEditor(node)) {
      let lastNode = node.children[node.children.length - 1];

      if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== 'paragraph') {
        slate.Transforms.insertNodes(editor, paragraphElement(), {
          at: [...path, node.children.length]
        });
        return;
      }
    }

    normalizeNode(entry);
  };

  return editor;
}

const allMarks = ['bold', 'italic', 'underline', 'strikethrough', 'code', 'superscript', 'subscript', 'keyboard'];
const isElementActive = (editor, format) => {
  const [match] = slate.Editor.nodes(editor, {
    match: n => n.type === format
  });
  return !!match;
};
function clearFormatting(editor) {
  slate.Transforms.unwrapNodes(editor, {
    match: node => node.type === 'heading' || node.type === 'blockquote' || node.type === 'code'
  });
  slate.Transforms.unsetNodes(editor, allMarks, {
    match: slate.Text.isText
  });
}
function moveChildren(editor, parent, to, shouldMoveNode = () => true) {
  const parentPath = slate.Path.isPath(parent) ? parent : parent[1];
  const parentNode = slate.Path.isPath(parent) ? slate.Node.get(editor, parentPath) : parent[0];
  if (!slate.Editor.isBlock(editor, parentNode)) return;

  for (let i = parentNode.children.length - 1; i >= 0; i--) {
    if (shouldMoveNode(parentNode.children[i])) {
      const childPath = [...parentPath, i];
      slate.Transforms.moveNodes(editor, {
        at: childPath,
        to
      });
    }
  }
} // this ensures that when changes happen, they are immediately shown
// this stops the problem of a cursor resetting to the end when a change is made
// because the changes are applied asynchronously

function useElementWithSetNodes(editor, element) {
  const [state, setState] = React.useState({
    element,
    elementWithChanges: element
  });

  if (state.element !== element) {
    setState({
      element,
      elementWithChanges: element
    });
  }

  const setNodes = changes => {
    slate.Transforms.setNodes(editor, changes, {
      at: slateReact.ReactEditor.findPath(editor, element)
    });
    setState({
      element,
      elementWithChanges: _objectSpread(_objectSpread({}, element), changes)
    });
  };

  return [state.elementWithChanges, setNodes];
}
function useEventCallback(callback) {
  const callbackRef = React.useRef(callback);
  const cb = React.useCallback((...args) => {
    return callbackRef.current(...args);
  }, []);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return cb;
}
const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
const modifierKeyText = IS_MAC ? 'âŒ˜' : 'Ctrl';
const ForceValidationContext = /*#__PURE__*/React__default["default"].createContext(false);
const ForceValidationProvider = ForceValidationContext.Provider;
function useForceValidation() {
  return React.useContext(ForceValidationContext);
}
function insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes) {
  var _pathRefForEmptyNodeA;

  let pathRefForEmptyNodeAtCursor;
  const entry = slate.Editor.above(editor, {
    match: node => node.type === 'heading' || node.type === 'paragraph'
  });

  if (entry && slate.Node.string(entry[0]) === '') {
    pathRefForEmptyNodeAtCursor = slate.Editor.pathRef(editor, entry[1]);
  }

  slate.Transforms.insertNodes(editor, nodes);
  let path = (_pathRefForEmptyNodeA = pathRefForEmptyNodeAtCursor) === null || _pathRefForEmptyNodeA === void 0 ? void 0 : _pathRefForEmptyNodeA.unref();

  if (path) {
    slate.Transforms.removeNodes(editor, {
      at: path
    }); // even though the selection is in the right place after the removeNodes
    // for some reason the editor blurs so we need to focus it again

    slateReact.ReactEditor.focus(editor);
  }
}
/**
 * This is equivalent to Editor.after except that it ignores points that have no content
 * like the point in a void text node, an empty text node and the last point in a text node
 */
// TODO: this would probably break if you were trying to get the last point in the editor?

function EditorAfterButIgnoringingPointsWithNoContent(editor, at, {
  distance = 1
} = {}) {
  const anchor = slate.Editor.point(editor, at, {
    edge: 'end'
  });
  const focus = slate.Editor.end(editor, []);
  const range = {
    anchor,
    focus
  };
  let d = 0;
  let target;

  for (const p of slate.Editor.positions(editor, {
    at: range
  })) {
    if (d > distance) {
      break;
    } // this is the important change


    const node = slate.Node.get(editor, p.path);

    if (node.text.length === p.offset) {
      continue;
    }

    if (d !== 0) {
      target = p;
    }

    d++;
  }

  return target;
}
function nodeTypeMatcher(...args) {
  if (args.length === 1) {
    const type = args[0];
    return node => node.type === type;
  }

  const set = new Set(args);
  return node => typeof node.type === 'string' && set.has(node.type);
}
function assert(condition) {
  if (!condition) {
    throw new Error('failed assert');
  }
}

const DocumentFieldRelationshipsContext = /*#__PURE__*/React.createContext({});
function useDocumentFieldRelationships() {
  return React.useContext(DocumentFieldRelationshipsContext);
}
const DocumentFieldRelationshipsProvider = DocumentFieldRelationshipsContext.Provider;
function withRelationship(editor) {
  const {
    isVoid,
    isInline
  } = editor;

  editor.isVoid = element => {
    return element.type === 'relationship' || isVoid(element);
  };

  editor.isInline = element => {
    return element.type === 'relationship' || isInline(element);
  };

  return editor;
}
function RelationshipButton({
  onClose
}) {
  const {
    editor,
    relationships: {
      isDisabled
    }
  } = useToolbarState();
  const relationships = React.useContext(DocumentFieldRelationshipsContext);
  return core.jsx(React.Fragment, null, Object.entries(relationships).map(([key, relationship]) => {
    if (relationship.kind === 'prop') return null;
    return core.jsx(toolbar.ToolbarButton, {
      key: key,
      isDisabled: isDisabled,
      onMouseDown: event => {
        event.preventDefault();
        slate.Transforms.insertNodes(editor, {
          type: 'relationship',
          relationship: key,
          data: null,
          children: [{
            text: ''
          }]
        });
        onClose();
      }
    }, relationship.label);
  }));
}
function RelationshipElement({
  attributes,
  children,
  element
}) {
  const keystone = context.useKeystone();
  const editor = slateReact.useSlateStatic();
  const relationships = React.useContext(DocumentFieldRelationshipsContext);
  const relationship = relationships[element.relationship];
  return core.jsx("span", _extends({}, attributes, {
    css: {
      display: 'inline-flex',
      alignItems: 'center'
    }
  }), core.jsx("span", {
    contentEditable: false,
    css: {
      userSelect: 'none',
      width: 200,
      display: 'inline-block',
      paddingLeft: 4,
      paddingRight: 4,
      flex: 1
    }
  }, relationship ? core.jsx(RelationshipSelect.RelationshipSelect, {
    controlShouldRenderValue: true,
    isDisabled: false,
    list: keystone.adminMeta.lists[relationship.listKey],
    portalMenu: true,
    state: {
      kind: 'one',
      value: element.data === null ? null : {
        id: element.data.id,
        label: element.data.label || element.data.id
      },

      onChange(value) {
        slate.Transforms.setNodes(editor, {
          data: value
        }, {
          at: slateReact.ReactEditor.findPath(editor, element)
        });
      }

    }
  }) : 'Invalid relationship'), core.jsx("span", {
    css: {
      flex: 0
    }
  }, children));
}

function getInitialValue(type, componentBlock, relationships) {
  const props = getInitialPropsValue({
    kind: 'object',
    value: componentBlock.props
  }, relationships);
  return {
    type: 'component-block',
    component: type,
    props,
    children: findChildPropPaths(props, componentBlock.props).map(x => ({
      type: `component-${x.options.kind}-prop`,
      propPath: x.path,
      children: [x.options.kind === 'block' ? {
        type: 'paragraph',
        children: [{
          text: ''
        }]
      } : {
        text: ''
      }]
    }))
  };
}
function getInitialPropsValue(prop, relationships) {
  switch (prop.kind) {
    case 'form':
      return prop.defaultValue;

    case 'child':
      return undefined;

    case 'relationship':
      return relationships[prop.relationship].many ? [] : null;

    case 'conditional':
      {
        const defaultValue = prop.discriminant.defaultValue;
        return {
          discriminant: defaultValue,
          value: getInitialPropsValue(prop.values[defaultValue], relationships)
        };
      }

    case 'object':
      {
        let obj = {};
        Object.keys(prop.value).forEach(key => {
          obj[key] = getInitialPropsValue(prop.value[key], relationships);
        });
        return obj;
      }
  }

  assertNever(prop);
}

function _findChildPropPaths(value, prop, path) {
  switch (prop.kind) {
    case 'form':
    case 'relationship':
      return [];

    case 'child':
      return [{
        path: path,
        options: prop.options
      }];

    case 'conditional':
      return _findChildPropPaths(value.value, prop.values[value.discriminant], path.concat('value'));

    case 'object':
      {
        let paths = [];
        Object.keys(prop.value).forEach(key => {
          paths.push(..._findChildPropPaths(value[key], prop.value[key], path.concat(key)));
        });
        return paths;
      }
  }
}

function findChildPropPaths(value, props) {
  let propPaths = _findChildPropPaths(value, {
    kind: 'object',
    value: props
  }, []);

  if (!propPaths.length) {
    return [{
      path: undefined,
      options: {
        kind: 'inline',
        placeholder: ''
      }
    }];
  }

  return propPaths;
}
function assertNever(arg) {
  throw new Error('expected to never be called but received: ' + JSON.stringify(arg));
}
function getPropsForConditionalChange(newValue, oldValue, prop, relationships) {
  if (newValue.discriminant !== oldValue.discriminant) {
    return {
      discriminant: newValue.discriminant,
      value: getInitialPropsValue(prop.values[newValue.discriminant], relationships)
    };
  } else {
    return newValue;
  }
}
function getDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7, _options$formatting8;

  // an important note for this: normalization based on document features
  // is done based on the document features returned here
  // and the editor document features
  // so the result for any given child prop will be the things that are
  // allowed by both these document features
  // AND the editor document features
  const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;
  const inlineMarks = inlineMarksFromOptions === 'inherit' ? 'inherit' : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map(mark => {
    return [mark, !!(inlineMarksFromOptions || {})[mark]];
  }));

  if (options.kind === 'inline') {
    var _options$formatting2;

    return {
      kind: 'inline',
      inlineMarks,
      documentFeatures: {
        links: options.links === 'inherit',
        relationships: options.relationships === 'inherit'
      },
      softBreaks: ((_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.softBreaks) === 'inherit'
    };
  }

  return {
    kind: 'block',
    inlineMarks,
    softBreaks: ((_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.softBreaks) === 'inherit',
    documentFeatures: {
      layouts: [],
      dividers: options.dividers === 'inherit' ? editorDocumentFeatures.dividers : false,
      formatting: {
        alignment: ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.alignment) === 'inherit' ? editorDocumentFeatures.formatting.alignment : {
          center: false,
          end: false
        },
        blockTypes: ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.blockTypes) === 'inherit' ? editorDocumentFeatures.formatting.blockTypes : {
          blockquote: false,
          code: false
        },
        headingLevels: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.headingLevels) === 'inherit' ? editorDocumentFeatures.formatting.headingLevels : ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.headingLevels) || [],
        listTypes: ((_options$formatting8 = options.formatting) === null || _options$formatting8 === void 0 ? void 0 : _options$formatting8.listTypes) === 'inherit' ? editorDocumentFeatures.formatting.listTypes : {
          ordered: false,
          unordered: false
        }
      },
      links: options.links === 'inherit',
      relationships: options.relationships === 'inherit'
    }
  };
}
function getChildFieldAtPropPath([key, ...restOfPath], values, props) {
  let prop = props[key];

  if (!prop || prop.kind === 'form' || prop.kind === 'relationship') {
    return;
  }

  if (prop.kind === 'conditional') {
    const propVal = prop.values[values[key].discriminant];
    return getChildFieldAtPropPath(restOfPath, values, {
      value: propVal
    });
  }

  if (prop.kind === 'object') {
    return getChildFieldAtPropPath(restOfPath, values[key], prop.value);
  }

  return prop;
}
function clientSideValidateProp(prop, value) {
  switch (prop.kind) {
    case 'child':
    case 'relationship':
      {
        return true;
      }

    case 'form':
      {
        return prop.validate(value);
      }

    case 'conditional':
      {
        if (!prop.discriminant.validate(value.discriminant)) {
          return false;
        }

        return clientSideValidateProp(prop.values[value.discriminant], value.value);
      }

    case 'object':
      {
        for (const [key, childProp] of Object.entries(prop.value)) {
          if (!clientSideValidateProp(childProp, value[key])) {
            return false;
          }
        }

        return true;
      }
  }
}

function _getPreviewProps(prop, value, childrenByPath, path, relationships, onFormPropsChange) {
  switch (prop.kind) {
    case 'form':
      return {
        value,

        onChange(newValue) {
          onFormPropsChange(newValue);
        },

        options: prop.options
      };

    case 'child':
      return childrenByPath[JSON.stringify(path)];

    case 'object':
      {
        const previewProps = {};
        Object.keys(prop.value).forEach(key => {
          previewProps[key] = _getPreviewProps(prop.value[key], value[key], childrenByPath, path.concat(key), relationships, newVal => {
            onFormPropsChange(_objectSpread(_objectSpread({}, value), {}, {
              [key]: newVal
            }));
          });
        });
        return previewProps;
      }

    case 'relationship':
      {
        return {
          value,

          onChange(newValue) {
            onFormPropsChange(newValue);
          }

        };
      }

    case 'conditional':
      {
        return {
          discriminant: value.discriminant,

          onChange(newDiscriminant) {
            onFormPropsChange(getPropsForConditionalChange({
              discriminant: newDiscriminant,
              value: value.value
            }, value, prop, relationships));
          },

          options: prop.discriminant.options,
          value: _getPreviewProps(prop.values[value.discriminant], value.value, childrenByPath, path.concat('value'), relationships, val => {
            onFormPropsChange({
              discriminant: value.discriminant,
              value: val
            });
          })
        };
      }
  }
}

function createPreviewProps(element, componentBlock, childrenByPath, relationships, setNode) {
  return _getPreviewProps({
    kind: 'object',
    value: componentBlock.props
  }, element.props, childrenByPath, [], relationships, props => {
    setNode({
      props
    });
  });
}

// this is in a different component to the other form inputs because it uses useKeystone
// and we want to render the editor outside of the Admin UI on the docs site
// and a call to useKeystone will break on the docs site
function RelationshipFormInput({
  prop,
  path,
  value,
  onChange,
  stringifiedPropPathToAutoFocus
}) {
  const relationships = useDocumentFieldRelationships();
  const keystone = context.useKeystone();
  const relationship = relationships[prop.relationship];
  const stringifiedPath = JSON.stringify(path);
  return /*#__PURE__*/React__default["default"].createElement(fields.FieldContainer, null, /*#__PURE__*/React__default["default"].createElement(fields.FieldLabel, null, prop.label), /*#__PURE__*/React__default["default"].createElement(RelationshipSelect.RelationshipSelect, {
    autoFocus: stringifiedPath === stringifiedPropPathToAutoFocus,
    controlShouldRenderValue: true,
    isDisabled: false,
    list: keystone.adminMeta.lists[relationship.listKey],
    extraSelection: relationship.selection || '',
    portalMenu: true,
    state: relationship.many ? {
      kind: 'many',
      value: value.map(x => ({
        id: x.id,
        label: x.label || x.id,
        data: x.data
      })),
      onChange
    } : {
      kind: 'one',
      value: value ? _objectSpread(_objectSpread({}, value), {}, {
        label: value.label || value.id
      }) : null,
      onChange
    }
  }));
}

function FormValueContent({
  prop,
  path,
  value,
  onChange,
  stringifiedPropPathToAutoFocus,
  forceValidation
}) {
  const relationships = useDocumentFieldRelationships();
  if (prop.kind === 'child') return null;

  if (prop.kind === 'object') {
    return /*#__PURE__*/React__default["default"].createElement(core.Stack, {
      gap: "xlarge"
    }, Object.entries(prop.value).map(([key, propVal]) => /*#__PURE__*/React__default["default"].createElement(FormValueContent, {
      key: key,
      forceValidation: forceValidation,
      stringifiedPropPathToAutoFocus: stringifiedPropPathToAutoFocus,
      path: path.concat(key),
      prop: propVal,
      value: value[key],
      onChange: val => {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          [key]: val
        }));
      }
    })));
  }

  if (prop.kind === 'conditional') {
    return /*#__PURE__*/React__default["default"].createElement(core.Stack, {
      gap: "xlarge"
    }, /*#__PURE__*/React__default["default"].createElement(prop.discriminant.Input, {
      autoFocus: JSON.stringify(path.concat('discriminant')) === stringifiedPropPathToAutoFocus,
      value: value.discriminant,
      onChange: discriminant => {
        onChange(getPropsForConditionalChange({
          discriminant,
          value: value.value
        }, value, prop, relationships));
      },
      forceValidation: forceValidation && !prop.discriminant.validate(value)
    }), /*#__PURE__*/React__default["default"].createElement(FormValueContent, {
      forceValidation: forceValidation,
      stringifiedPropPathToAutoFocus: stringifiedPropPathToAutoFocus,
      path: path.concat('value'),
      prop: prop.values[value.discriminant],
      value: value.value,
      onChange: val => {
        onChange({
          discriminant: value.discriminant,
          value: val
        });
      }
    }));
  }

  if (prop.kind === 'relationship') {
    return /*#__PURE__*/React__default["default"].createElement(RelationshipFormInput, {
      prop: prop,
      path: path,
      value: value,
      onChange: onChange,
      stringifiedPropPathToAutoFocus: stringifiedPropPathToAutoFocus
    });
  }

  return /*#__PURE__*/React__default["default"].createElement(prop.Input, {
    autoFocus: JSON.stringify(path) === stringifiedPropPathToAutoFocus,
    value: value,
    onChange: onChange,
    forceValidation: forceValidation && !prop.validate(value)
  });
} // child as in the props are a tree and you want the children of a prop, not as in the kind === 'inline'

function getChildProps(prop, value) {
  if (prop.kind === 'conditional') {
    return {
      discriminant: prop.discriminant,
      value: prop.values[value.discriminant]
    };
  } else if (prop.kind === 'form' || prop.kind === 'child' || prop.kind === 'relationship') {
    return {};
  } else if (prop.kind === 'object') {
    return prop.value;
  } else {
    assertNever(prop); // TypeScript should understand that this will never happen but for some reason it doesn't

    return {};
  }
}

function findFirstFocusablePropPath(props, path, value) {
  for (const key of Object.keys(props)) {
    const prop = props[key];
    const newPath = path.concat(key);

    if (prop.kind === 'form' || prop.kind === 'relationship') {
      return newPath;
    }

    let children = getChildProps(prop, value[key]);
    const childFocusable = findFirstFocusablePropPath(children, newPath, value[key]);

    if (childFocusable) {
      return childFocusable;
    }
  }
}

function FormValue({
  value,
  onClose,
  onChange,
  componentBlock,
  isValid
}) {
  const [forceValidation, setForceValidation] = React.useState(false);
  const focusablePath = JSON.stringify(findFirstFocusablePropPath(componentBlock.props, [], value));
  return /*#__PURE__*/React__default["default"].createElement(core.Stack, {
    gap: "xlarge",
    contentEditable: false
  }, /*#__PURE__*/React__default["default"].createElement(FormValueContent, {
    forceValidation: forceValidation,
    onChange: onChange,
    path: [],
    prop: {
      kind: 'object',
      value: componentBlock.props
    },
    value: value,
    stringifiedPropPathToAutoFocus: focusablePath
  }), /*#__PURE__*/React__default["default"].createElement(button.Button, {
    size: "small",
    tone: "active",
    weight: "bold",
    onClick: () => {
      if (isValid) {
        onClose();
      } else {
        setForceValidation(true);
      }
    }
  }, "Done"));
}

function areArraysEqual(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }

  for (let i = 0; i < arrA.length; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }

  return true;
}

function normalizeTextBasedOnInlineMarksAndSoftBreaks([node, path], editor, inlineMarks, softBreaks) {
  const marksToRemove = Object.keys(node).filter(x => x !== 'text' && x !== 'insertMenu' && inlineMarks[x] !== true);

  if (marksToRemove.length) {
    slate.Transforms.unsetNodes(editor, marksToRemove, {
      at: path
    });
    return true;
  }

  if (!softBreaks) {
    const hasSoftBreaks = node.text.includes('\n');

    if (hasSoftBreaks) {
      const [parentNode] = slate.Editor.parent(editor, path);

      if (parentNode.type !== 'code') {
        for (const position of slate.Editor.positions(editor, {
          at: path
        })) {
          const character = slate.Node.get(editor, position.path).text[position.offset];

          if (character === '\n') {
            slate.Transforms.delete(editor, {
              at: position
            });
            return true;
          }
        }
      }
    }
  }

  return false;
}
function normalizeInlineBasedOnLinksAndRelationships([node, path], editor, links, relationshipsEnabled, relationships) {
  if (node.type === 'link' && !links) {
    slate.Transforms.insertText(editor, ` (${node.href})`, {
      at: slate.Editor.end(editor, path)
    });
    slate.Transforms.unwrapNodes(editor, {
      at: path
    });
    return true;
  }

  if (node.type === 'relationship' && (!relationshipsEnabled || relationships[node.relationship] === undefined || relationships[node.relationship].kind !== 'inline')) {
    const data = node.data;

    if (data) {
      const relationship = relationships[node.relationship];
      slate.Transforms.insertText(editor, `${data.label || data.id || ''} (${(relationship === null || relationship === void 0 ? void 0 : relationship.kind) === 'inline' ? relationship.label : node.relationship}:${data.id || ''})`, {
        at: slate.Editor.before(editor, path)
      });
    }

    slate.Transforms.removeNodes(editor, {
      at: path
    });
    return true;
  }

  return false;
}
function normalizeElementBasedOnDocumentFeatures([node, path], editor, {
  formatting,
  dividers,
  layouts,
  links,
  relationships: relationshipsEnabled
}, relationships) {
  if (node.type === 'heading' && (!formatting.headingLevels.length || !formatting.headingLevels.includes(node.level)) || node.type === 'ordered-list' && !formatting.listTypes.ordered || node.type === 'unordered-list' && !formatting.listTypes.unordered || node.type === 'code' && !formatting.blockTypes.code || node.type === 'blockquote' && !formatting.blockTypes.blockquote || node.type === 'layout' && (layouts.length === 0 || !layouts.some(layout => areArraysEqual(layout, node.layout)))) {
    slate.Transforms.unwrapNodes(editor, {
      at: path
    });
    return true;
  }

  if ((node.type === 'paragraph' || node.type === 'heading') && (!formatting.alignment.center && node.textAlign === 'center' || !formatting.alignment.end && node.textAlign === 'end' || 'textAlign' in node && node.textAlign !== 'center' && node.textAlign !== 'end')) {
    slate.Transforms.unsetNodes(editor, 'textAlign', {
      at: path
    });
    return true;
  }

  if (node.type === 'divider' && !dividers) {
    slate.Transforms.removeNodes(editor, {
      at: path
    });
    return true;
  }

  return normalizeInlineBasedOnLinksAndRelationships([node, path], editor, links, relationshipsEnabled, relationships);
}
function withDocumentFeaturesNormalization(documentFeatures, relationships, editor) {
  const {
    normalizeNode
  } = editor;

  const documentFeaturesForNormalization = _objectSpread(_objectSpread({}, documentFeatures), {}, {
    relationships: true
  });

  editor.normalizeNode = ([node, path]) => {
    if (slate.Text.isText(node)) {
      normalizeTextBasedOnInlineMarksAndSoftBreaks([node, path], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);
    } else if (slate.Element.isElement(node)) {
      normalizeElementBasedOnDocumentFeatures([node, path], editor, documentFeaturesForNormalization, relationships);
    }

    normalizeNode([node, path]);
  };

  return editor;
}

function getAncestorComponentBlock(editor) {
  if (editor.selection) {
    const ancestorEntry = slate.Editor.above(editor, {
      match: node => slate.Editor.isBlock(editor, node) && node.type !== 'paragraph'
    });

    if (ancestorEntry && (ancestorEntry[0].type === 'component-block-prop' || ancestorEntry[0].type === 'component-inline-prop')) {
      return {
        isInside: true,
        componentBlock: slate.Editor.parent(editor, ancestorEntry[1]),
        prop: ancestorEntry
      };
    }
  }

  return {
    isInside: false
  };
}

const alreadyNormalizedThings = new WeakMap();

function normalizeNodeWithinComponentProp([node, path], editor, fieldOptions, relationships) {
  let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);

  if (!alreadyNormalizedNodes) {
    alreadyNormalizedNodes = new WeakSet();
    alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);
  }

  if (alreadyNormalizedNodes.has(node)) {
    return false;
  }

  let didNormalization = false;

  if (fieldOptions.inlineMarks !== 'inherit' && slate.Text.isText(node)) {
    didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([node, path], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);
  }

  if (slate.Element.isElement(node)) {
    let childrenHasChanged = node.children.map((node, i) => normalizeNodeWithinComponentProp([node, [...path, i]], editor, fieldOptions, relationships)) // .map then .some because we don't want to exit early
    .some(x => x);

    if (fieldOptions.kind === 'block') {
      didNormalization = normalizeElementBasedOnDocumentFeatures([node, path], editor, fieldOptions.documentFeatures, relationships) || childrenHasChanged;
    } else {
      didNormalization = normalizeInlineBasedOnLinksAndRelationships([node, path], editor, fieldOptions.documentFeatures.links, fieldOptions.documentFeatures.relationships, relationships);
    }
  }

  if (didNormalization === false) {
    alreadyNormalizedNodes.add(node);
  }

  return didNormalization;
}

function withComponentBlocks(blockComponents, editorDocumentFeatures, relationships, editor) {
  // note that conflicts between the editor document features
  // and the child field document features are dealt with elsewhere
  const memoizedGetDocumentFeaturesForChildField = weakMemoize__default["default"](options => {
    return getDocumentFeaturesForChildField(editorDocumentFeatures, options);
  });
  const {
    normalizeNode,
    deleteBackward,
    insertBreak
  } = editor;

  editor.deleteBackward = unit => {
    if (editor.selection) {
      const ancestorComponentBlock = getAncestorComponentBlock(editor);

      if (ancestorComponentBlock.isInside && slate.Range.isCollapsed(editor.selection) && slate.Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {
        slate.Transforms.unwrapNodes(editor, {
          at: ancestorComponentBlock.componentBlock[1]
        });
        return;
      }
    }

    deleteBackward(unit);
  };

  editor.insertBreak = () => {
    const ancestorComponentBlock = getAncestorComponentBlock(editor);

    if (editor.selection && ancestorComponentBlock.isInside) {
      const {
        prop: [componentPropNode, componentPropPath],
        componentBlock: [componentBlockNode, componentBlockPath]
      } = ancestorComponentBlock;
      const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;

      if (componentPropNode.type === 'component-block-prop') {
        const [[paragraphNode, paragraphPath]] = slate.Editor.nodes(editor, {
          match: node => node.type === 'paragraph'
        });
        const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;

        if (slate.Node.string(paragraphNode) === '' && isLastParagraph) {
          if (isLastProp) {
            slate.Transforms.moveNodes(editor, {
              at: paragraphPath,
              to: slate.Path.next(ancestorComponentBlock.componentBlock[1])
            });
          } else {
            // TODO: this goes to the start of the next block, is that right?
            // should we just insertBreak always here?
            slate.Transforms.move(editor, {
              distance: 1,
              unit: 'line'
            });
            slate.Transforms.removeNodes(editor, {
              at: paragraphPath
            });
          }

          return;
        }
      }

      if (componentPropNode.type === 'component-inline-prop') {
        slate.Editor.withoutNormalizing(editor, () => {
          slate.Transforms.splitNodes(editor, {
            always: true
          });
          const splitNodePath = slate.Path.next(componentPropPath);

          if (isLastProp) {
            slate.Transforms.moveNodes(editor, {
              at: splitNodePath,
              to: slate.Path.next(componentBlockPath)
            });
          } else {
            moveChildren(editor, splitNodePath, [...slate.Path.next(splitNodePath), 0]);
            slate.Transforms.removeNodes(editor, {
              at: splitNodePath
            });
          }
        });
        return;
      }
    }

    insertBreak();
  };

  editor.normalizeNode = entry => {
    const [node, path] = entry;

    if (slate.Element.isElement(node) || slate.Editor.isEditor(node)) {
      if (node.type === 'component-inline-prop' && !node.propPath && (node.children.length !== 1 || !slate.Text.isText(node.children[0]) || node.children[0].text !== '')) {
        slate.Transforms.removeNodes(editor, {
          at: path
        });
        return;
      }

      if (slate.Element.isElement(node) && node.type === 'component-block') {
        const componentBlock = blockComponents[node.component];

        if (componentBlock) {
          let missingKeys = new Map(findChildPropPaths(node.props, componentBlock.props).map(x => [JSON.stringify(x.path), x.options.kind]));
          node.children.forEach(node => {
            assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop');
            missingKeys.delete(JSON.stringify(node.propPath));
          });

          if (missingKeys.size) {
            slate.Transforms.insertNodes(editor, [...missingKeys].map(([prop, kind]) => ({
              type: `component-${kind}-prop`,
              propPath: prop ? JSON.parse(prop) : prop,
              children: [{
                text: ''
              }]
            })), {
              at: [...path, node.children.length]
            });
            return;
          }

          let foundProps = new Set();
          let stringifiedInlinePropPaths = {};
          findChildPropPaths(node.props, blockComponents[node.component].props).forEach((x, index) => {
            stringifiedInlinePropPaths[JSON.stringify(x.path)] = {
              options: x.options,
              index
            };
          });

          for (const [index, childNode] of node.children.entries()) {
            if ( // children that are not these will be handled by
            // the generic allowedChildren normalization
            childNode.type === 'component-inline-prop' || childNode.type === 'component-block-prop') {
              const childPath = [...path, index];
              const stringifiedPropPath = JSON.stringify(childNode.propPath);

              if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
                slate.Transforms.removeNodes(editor, {
                  at: childPath
                });
                return;
              } else {
                if (foundProps.has(stringifiedPropPath)) {
                  slate.Transforms.removeNodes(editor, {
                    at: childPath
                  });
                  return;
                }

                foundProps.add(stringifiedPropPath);
                const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];
                const expectedIndex = propInfo.index;

                if (index !== expectedIndex) {
                  slate.Transforms.moveNodes(editor, {
                    at: childPath,
                    to: [...path, expectedIndex]
                  });
                  return;
                }

                const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;

                if (childNode.type !== expectedChildNodeType) {
                  slate.Transforms.setNodes(editor, {
                    type: expectedChildNodeType
                  }, {
                    at: childPath
                  });
                  return;
                }

                const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);

                if (normalizeNodeWithinComponentProp([childNode, childPath], editor, documentFeatures, relationships)) {
                  return;
                }
              }
            }
          }
        }
      }
    }

    normalizeNode(entry);
  };

  return editor;
}

const ComponentBlockContext = /*#__PURE__*/React.createContext({});
function getPlaceholderTextForPropPath(propPath, fields, formProps) {
  const prop = propPath[0];
  const field = fields[prop];

  if (field.kind === 'relationship' || field.kind === 'form') {
    throw new Error('unexpected prop field when finding placeholder text for child prop');
  }

  if (field.kind === 'object') {
    return getPlaceholderTextForPropPath(propPath.slice(1), field.value, formProps[prop]);
  }

  if (field.kind === 'conditional') {
    return getPlaceholderTextForPropPath(propPath.slice(1), {
      value: field.values[formProps[prop].discriminant]
    }, formProps[prop]);
  }

  return field.options.placeholder;
}
function ComponentInlineProp(props) {
  return core.jsx("span", props.attributes, props.children);
}
function insertComponentBlock(editor, componentBlocks, componentBlock, relationships) {
  let node = getInitialValue(componentBlock, componentBlocks[componentBlock], relationships);
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, node);
  const componentBlockEntry = slate.Editor.above(editor, {
    match: node => node.type === 'component-block'
  });

  if (componentBlockEntry) {
    const start = slate.Editor.start(editor, componentBlockEntry[1]);
    slate.Transforms.setSelection(editor, {
      anchor: start,
      focus: start
    });
  }
}
const BlockComponentsButtons = ({
  onClose
}) => {
  const editor = slateReact.useSlateStatic();
  const blockComponents = React.useContext(ComponentBlockContext);
  const relationships = useDocumentFieldRelationships();
  return core.jsx(React.Fragment, null, Object.keys(blockComponents).map(key => core.jsx(toolbar.ToolbarButton, {
    key: key,
    onMouseDown: event => {
      event.preventDefault();
      insertComponentBlock(editor, blockComponents, key, relationships);
      onClose();
    }
  }, blockComponents[key].label)));
};
const ComponentBlocksElement = ({
  attributes,
  children,
  element: __elementToGetPath
}) => {
  const editor = slateReact.useSlateStatic();
  const focused = slateReact.useFocused();
  const selected = slateReact.useSelected();
  const [editMode, setEditMode] = React.useState(false);
  const [currentElement, setElement] = useElementWithSetNodes(editor, __elementToGetPath);
  const {
    colors,
    fields,
    spacing,
    typography
  } = core.useTheme();
  const blockComponents = React.useContext(ComponentBlockContext);
  const componentBlock = blockComponents[currentElement.component];
  const isValid = React.useMemo(() => {
    return componentBlock ? clientSideValidateProp({
      kind: 'object',
      value: componentBlock.props
    }, currentElement.props) : true;
  }, [componentBlock, currentElement.props]);
  const documentFieldRelationships = useDocumentFieldRelationships();

  if (!componentBlock) {
    return core.jsx("div", {
      css: {
        border: 'red 4px solid',
        padding: spacing.medium
      }
    }, core.jsx("pre", {
      contentEditable: false,
      css: {
        userSelect: 'none'
      }
    }, `The block "${currentElement.component}" no longer exists.

Props:

${JSON.stringify(currentElement.props, null, 2)}

Content:`), children);
  }

  return core.jsx("div", _extends({
    "data-with-chrome": !componentBlock.chromeless,
    css: {
      marginBottom: spacing.xlarge,
      marginTop: spacing.xlarge,
      '&[data-with-chrome=true]': {
        paddingLeft: spacing.xlarge,
        position: 'relative',
        ':before': {
          content: '" "',
          backgroundColor: editMode ? colors.linkColor : colors.border,
          borderRadius: 4,
          width: 4,
          position: 'absolute',
          left: 0,
          top: 0,
          bottom: 0,
          zIndex: 1
        }
      }
    }
  }, attributes), !componentBlock.chromeless && core.jsx(api.NotEditable, {
    css: {
      color: fields.legendColor,
      display: 'block',
      fontSize: typography.fontSize.small,
      fontWeight: typography.fontWeight.bold,
      lineHeight: 1,
      marginBottom: spacing.small,
      textTransform: 'uppercase'
    }
  }, componentBlock.label), editMode && core.jsx(FormValue, {
    isValid: isValid,
    componentBlock: componentBlock,
    onClose: () => {
      setEditMode(false);
    },
    value: currentElement.props,
    onChange: val => {
      setElement({
        props: val
      });
    }
  }), core.jsx("div", {
    css: {
      display: editMode ? 'none' : 'block',
      position: 'relative'
    }
  }, editMode ? children : core.jsx(ComponentBlockRender, {
    children: children,
    componentBlock: componentBlock,
    element: currentElement,
    onElementChange: setElement
  }), !editMode && (() => {
    const toolbarProps = createPreviewProps(currentElement, componentBlock, {}, documentFieldRelationships, setElement);
    const ChromefulToolbar = componentBlock.toolbar ? componentBlock.toolbar : DefaultToolbarWithChrome;
    const ChromelessToolbar = componentBlock.chromeless && componentBlock.toolbar ? componentBlock.toolbar : DefaultToolbarWithoutChrome;
    return componentBlock.chromeless ? focused && selected && core.jsx(toolbar.InlineDialog, {
      isRelative: true
    }, core.jsx(ChromelessToolbar, {
      onRemove: () => {
        const path = slateReact.ReactEditor.findPath(editor, __elementToGetPath);
        slate.Transforms.removeNodes(editor, {
          at: path
        });
      },
      props: toolbarProps
    })) : core.jsx(ChromefulToolbar, {
      isValid: isValid,
      onRemove: () => {
        const path = slateReact.ReactEditor.findPath(editor, __elementToGetPath);
        slate.Transforms.removeNodes(editor, {
          at: path
        });
      },
      onShowEditMode: () => {
        setEditMode(true);
      },
      props: toolbarProps
    });
  })()));
};

function DefaultToolbarWithChrome({
  onShowEditMode,
  onRemove,
  isValid
}) {
  const theme = core.useTheme();
  return core.jsx(toolbar.ToolbarGroup, {
    as: api.NotEditable,
    marginTop: "small"
  }, core.jsx(toolbar.ToolbarButton, {
    onClick: () => {
      onShowEditMode();
    }
  }, "Edit"), core.jsx(toolbar.ToolbarSeparator, null), core.jsx(tooltip.Tooltip, {
    content: "Remove",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    variant: "destructive",
    onClick: () => {
      onRemove();
    }
  }, attrs), core.jsx(Trash2Icon.Trash2Icon, {
    size: "small"
  }))), !isValid && core.jsx(React.Fragment, null, core.jsx(toolbar.ToolbarSeparator, null), core.jsx("span", {
    css: {
      color: theme.palette.red500,
      display: 'flex',
      alignItems: 'center',
      paddingLeft: theme.spacing.small
    }
  }, "Please edit the form, there are invalid fields.")));
}

function DefaultToolbarWithoutChrome({
  onRemove
}) {
  return core.jsx(tooltip.Tooltip, {
    content: "Remove",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    variant: "destructive",
    onMouseDown: event => {
      event.preventDefault();
      onRemove();
    }
  }, attrs), core.jsx(Trash2Icon.Trash2Icon, {
    size: "small"
  })));
}

function ComponentBlockRender({
  componentBlock,
  element,
  onElementChange,
  children: _children
}) {
  const childrenByPath = {};

  const children = _children.type(_children.props).props.children;

  let maybeChild;
  children.forEach(child => {
    let stringified = JSON.stringify(child.props.element.propPath);

    if (stringified === undefined) {
      maybeChild = child;
    } else {
      childrenByPath[stringified] = child;
    }
  });
  const previewProps = createPreviewProps(element, componentBlock, childrenByPath, useDocumentFieldRelationships(), onElementChange);
  return core.jsx(React.Fragment, null, core.jsx(componentBlock.component, previewProps), core.jsx("span", {
    css: {
      display: 'none'
    }
  }, maybeChild));
}

const LayoutOptionsContext = /*#__PURE__*/React.createContext([]);
const LayoutOptionsProvider = LayoutOptionsContext.Provider; // UI Components

const LayoutContainer = ({
  attributes,
  children,
  element
}) => {
  const {
    spacing
  } = core.useTheme();
  const focused = slateReact.useFocused();
  const selected = slateReact.useSelected();
  const editor = slateReact.useSlateStatic();
  const layout = element.layout;
  const layoutOptions = React.useContext(LayoutOptionsContext);
  return core.jsx("div", _extends({
    css: {
      marginBottom: spacing.medium,
      marginTop: spacing.medium,
      position: 'relative'
    }
  }, attributes), core.jsx("div", {
    css: {
      columnGap: spacing.small,
      display: 'grid',
      gridTemplateColumns: layout.map(x => `${x}fr`).join(' ')
    }
  }, children), focused && selected && core.jsx(toolbar.InlineDialog, {
    isRelative: true
  }, core.jsx(toolbar.ToolbarGroup, null, layoutOptions.map((layoutOption, i) => core.jsx(toolbar.ToolbarButton, {
    isSelected: layoutOption.toString() === layout.toString(),
    key: i,
    onMouseDown: event => {
      event.preventDefault();
      const path = slateReact.ReactEditor.findPath(editor, element);
      slate.Transforms.setNodes(editor, {
        type: 'layout',
        layout: layoutOption
      }, {
        at: path
      });
    }
  }, makeLayoutIcon(layoutOption))), core.jsx(toolbar.ToolbarSeparator, null), core.jsx(tooltip.Tooltip, {
    content: "Remove",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    variant: "destructive",
    onMouseDown: event => {
      event.preventDefault();
      const path = slateReact.ReactEditor.findPath(editor, element);
      slate.Transforms.removeNodes(editor, {
        at: path
      });
    }
  }, attrs), core.jsx(Trash2Icon.Trash2Icon, {
    size: "small"
  }))))));
};
const LayoutArea = ({
  attributes,
  children
}) => {
  const {
    colors,
    radii,
    spacing
  } = core.useTheme();
  return core.jsx("div", _extends({
    css: {
      border: `2px dashed ${colors.border}`,
      borderRadius: radii.small,
      paddingLeft: spacing.medium,
      paddingRight: spacing.medium
    }
  }, attributes), children);
};
const insertLayout = (editor, layout) => {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, [{
    type: 'layout',
    layout,
    children: [{
      type: 'layout-area',
      children: [{
        type: 'paragraph',
        children: [{
          text: ''
        }]
      }]
    }]
  }]);
  const layoutEntry = slate.Editor.above(editor, {
    match: x => x.type === 'layout'
  });

  if (layoutEntry) {
    slate.Transforms.select(editor, [...layoutEntry[1], 0]);
  }
}; // Plugin

function withLayouts(editor) {
  const {
    normalizeNode,
    deleteBackward
  } = editor;

  editor.deleteBackward = unit => {
    if (editor.selection && slate.Range.isCollapsed(editor.selection) && // this is just an little optimisation
    // we're only doing things if we're at the start of a layout area
    // and the start of anything will always be offset 0
    // so we'll bailout if we're not at offset 0
    editor.selection.anchor.offset === 0) {
      const [aboveNode, abovePath] = slate.Editor.above(editor, {
        match: node => node.type === 'layout-area'
      }) || [editor, []];

      if (aboveNode.type === 'layout-area' && slate.Point.equals(slate.Editor.start(editor, abovePath), editor.selection.anchor)) {
        return;
      }
    }

    deleteBackward(unit);
  };

  editor.normalizeNode = entry => {
    const [node, path] = entry;

    if (slate.Element.isElement(node) && node.type === 'layout') {
      if (node.layout === undefined) {
        slate.Transforms.unwrapNodes(editor, {
          at: path
        });
        return;
      }

      if (node.children.length < node.layout.length) {
        slate.Transforms.insertNodes(editor, Array.from({
          length: node.layout.length - node.children.length
        }).map(() => ({
          type: 'layout-area',
          children: [paragraphElement()]
        })), {
          at: [...path, node.children.length]
        });
        return;
      }

      if (node.children.length > node.layout.length) {
        Array.from({
          length: node.children.length - node.layout.length
        }).map((_, i) => i).reverse().forEach(i => {
          const layoutAreaToRemovePath = [...path, i + node.layout.length];
          const child = node.children[i + node.layout.length];
          moveChildren(editor, layoutAreaToRemovePath, [...path, node.layout.length - 1, node.children[node.layout.length - 1].children.length], node => node.type !== 'paragraph' || slate.Node.string(child) !== '');
          slate.Transforms.removeNodes(editor, {
            at: layoutAreaToRemovePath
          });
        });
        return;
      }
    }

    normalizeNode(entry);
  };

  return editor;
} // Utils
// ------------------------------

function makeLayoutIcon(ratios) {
  const size = 16;
  const element = core.jsx("div", {
    role: "img",
    css: {
      display: 'grid',
      gridTemplateColumns: ratios.map(r => `${r}fr`).join(' '),
      gap: 2,
      width: size,
      height: size
    }
  }, ratios.map((_, i) => {
    return core.jsx("div", {
      key: i,
      css: {
        backgroundColor: 'currentcolor',
        borderRadius: 1
      }
    });
  }));
  return element;
}

const layoutsIcon = core.jsx(ColumnsIcon.ColumnsIcon, {
  size: "small"
});
const LayoutsButton = ({
  layouts
}) => {
  const {
    editor,
    layouts: {
      isSelected
    }
  } = useToolbarState();
  return React.useMemo(() => core.jsx(tooltip.Tooltip, {
    content: "Layouts",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    isSelected: isSelected,
    onMouseDown: event => {
      event.preventDefault();

      if (isElementActive(editor, 'layout')) {
        slate.Transforms.unwrapNodes(editor, {
          match: node => node.type === 'layout'
        });
        return;
      }

      insertLayout(editor, layouts[0]);
    }
  }, attrs), layoutsIcon)), [editor, isSelected, layouts]);
};

const _excluded$1 = ["type"];
const isListType = type => type === 'ordered-list' || type === 'unordered-list';
const isListNode = node => isListType(node.type);
const toggleList = (editor, format) => {
  const listAbove = getListTypeAbove(editor);
  const isActive = isElementActive(editor, format) && (listAbove === 'none' || listAbove === format);
  slate.Editor.withoutNormalizing(editor, () => {
    slate.Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true,
      mode: isActive ? 'all' : 'lowest'
    });

    if (!isActive) {
      slate.Transforms.wrapNodes(editor, {
        type: format,
        children: []
      }, {
        match: x => x.type !== 'list-item-content' && slate.Editor.isBlock(editor, x)
      });
    }
  });
};

function getAncestorList(editor) {
  if (editor.selection) {
    const listItem = slate.Editor.above(editor, {
      match: nodeTypeMatcher('list-item')
    });
    const list = slate.Editor.above(editor, {
      match: isListNode
    });

    if (listItem && list) {
      return {
        isInside: true,
        listItem,
        list
      };
    }
  }

  return {
    isInside: false
  };
}

function withList(editor) {
  const {
    insertBreak,
    normalizeNode,
    deleteBackward
  } = editor;

  editor.deleteBackward = unit => {
    if (editor.selection) {
      const ancestorList = getAncestorList(editor);

      if (ancestorList.isInside && slate.Range.isCollapsed(editor.selection) && slate.Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {
        slate.Transforms.unwrapNodes(editor, {
          match: isListNode,
          split: true
        });
        return;
      }
    }

    deleteBackward(unit);
  };

  editor.insertBreak = () => {
    const [listItem] = slate.Editor.nodes(editor, {
      match: node => node.type === 'list-item',
      mode: 'lowest'
    });

    if (listItem && slate.Node.string(listItem[0]) === '') {
      slate.Transforms.unwrapNodes(editor, {
        match: isListNode,
        split: true
      });
      return;
    }

    insertBreak();
  };

  editor.normalizeNode = entry => {
    const [node, path] = entry;

    if (slate.Element.isElement(node) || slate.Editor.isEditor(node)) {
      const isElementBeingNormalizedAList = isListNode(node);

      for (const [childNode, childPath] of slate.Node.children(editor, path)) {
        const index = childPath[childPath.length - 1]; // merge sibling lists

        if (isListNode(childNode)) {
          var _node$children;

          if (((_node$children = node.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {
            const siblingNodePath = slate.Path.next(childPath);
            moveChildren(editor, siblingNodePath, [...childPath, childNode.children.length]);
            slate.Transforms.removeNodes(editor, {
              at: siblingNodePath
            });
            return;
          }

          if (isElementBeingNormalizedAList) {
            const previousChild = node.children[index - 1];

            if (slate.Element.isElement(previousChild)) {
              slate.Transforms.moveNodes(editor, {
                at: childPath,
                to: [...slate.Path.previous(childPath), previousChild.children.length - 1]
              });
            } else {
              slate.Transforms.unwrapNodes(editor, {
                at: childPath
              });
            }

            return;
          }
        }

        if (node.type === 'list-item' && childNode.type !== 'list-item-content' && index === 0 && slate.Editor.isBlock(editor, childNode)) {
          if (path[path.length - 1] !== 0) {
            const previousChild = slate.Node.get(editor, slate.Path.previous(path));

            if (slate.Element.isElement(previousChild)) {
              slate.Transforms.moveNodes(editor, {
                at: path,
                to: [...slate.Path.previous(path), previousChild.children.length]
              });
              return;
            }
          }

          slate.Transforms.unwrapNodes(editor, {
            at: childPath
          });
          return;
        }

        if (node.type === 'list-item' && childNode.type === 'list-item-content' && index !== 0) {
          slate.Transforms.splitNodes(editor, {
            at: childPath
          });
          return;
        }
      }
    }

    normalizeNode(entry);
  };

  return editor;
}
const ListButton = /*#__PURE__*/React.forwardRef(function ListButton(props, ref) {
  const {
    editor,
    lists: {
      [props.type === 'ordered-list' ? 'ordered' : 'unordered']: {
        isDisabled,
        isSelected
      }
    }
  } = useToolbarState();
  return React.useMemo(() => {
    const {
      type
    } = props,
          restProps = _objectWithoutProperties(props, _excluded$1);

    return core.jsx(toolbar.ToolbarButton, _extends({
      ref: ref,
      isDisabled: isDisabled,
      isSelected: isSelected,
      onMouseDown: event => {
        event.preventDefault();
        toggleList(editor, type);
      }
    }, restProps));
  }, [props, ref, isDisabled, isSelected, editor]);
});
function nestList(editor) {
  const block = slate.Editor.above(editor, {
    match: n => slate.Editor.isBlock(editor, n)
  });

  if (!block || block[0].type !== 'list-item-content') {
    return false;
  }

  const listItemPath = slate.Path.parent(block[1]); // we're the first item in the list therefore we can't nest

  if (listItemPath[listItemPath.length - 1] === 0) {
    return false;
  }

  const previousListItemPath = slate.Path.previous(listItemPath);
  const previousListItemNode = slate.Node.get(editor, previousListItemPath);

  if (previousListItemNode.children.length !== 1) {
    // there's a list nested inside our previous sibling list item so move there
    slate.Transforms.moveNodes(editor, {
      at: listItemPath,
      to: [...previousListItemPath, previousListItemNode.children.length - 1, previousListItemNode.children[previousListItemNode.children.length - 1].children.length]
    });
    return true;
  }

  const type = slate.Editor.parent(editor, slate.Path.parent(block[1]))[0].type;
  slate.Transforms.wrapNodes(editor, {
    type,
    children: []
  });
  return true;
}
function unnestList(editor) {
  const block = slate.Editor.above(editor, {
    match: n => slate.Editor.isBlock(editor, n)
  });

  if (block && block[0].type === 'list-item-content') {
    slate.Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true
    });
    return true;
  }

  return false;
}

const ToolbarStateContext = /*#__PURE__*/React__default["default"].createContext(null);
function useToolbarState() {
  const toolbarState = React.useContext(ToolbarStateContext);

  if (!toolbarState) {
    throw new Error('ToolbarStateProvider must be used to use useToolbarState');
  }

  return toolbarState;
}
function getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {
  const ancestorComponentProp = slate.Editor.above(editor, {
    match: nodeTypeMatcher('component-block-prop', 'component-inline-prop')
  });

  if (ancestorComponentProp) {
    const propPath = ancestorComponentProp[0].propPath;
    const ancestorComponent = slate.Editor.parent(editor, ancestorComponentProp[1]);

    if (ancestorComponent[0].type === 'component-block') {
      const component = ancestorComponent[0].component;
      const componentBlock = componentBlocks[component];

      if (componentBlock && propPath) {
        var _getChildFieldAtPropP;

        const options = (_getChildFieldAtPropP = getChildFieldAtPropPath(propPath, ancestorComponent[0].props, componentBlock.props)) === null || _getChildFieldAtPropP === void 0 ? void 0 : _getChildFieldAtPropP.options;

        if (options) {
          return getDocumentFeaturesForChildField(editorDocumentFeatures, options);
        }
      }
    }
  }
}
const createToolbarState = (editor, componentBlocks, editorDocumentFeatures) => {
  const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) || {
    kind: 'block',
    inlineMarks: 'inherit',
    documentFeatures: {
      dividers: true,
      formatting: {
        alignment: {
          center: true,
          end: true
        },
        blockTypes: {
          blockquote: true,
          code: true
        },
        headingLevels: [1, 2, 3, 4, 5, 6],
        listTypes: {
          ordered: true,
          unordered: true
        }
      },
      layouts: editorDocumentFeatures.layouts,
      links: true,
      relationships: true
    },
    softBreaks: true
  };
  let [maybeCodeBlockEntry] = slate.Editor.nodes(editor, {
    match: node => node.type !== 'code' && slate.Editor.isBlock(editor, node)
  });
  const editorMarks = slate.Editor.marks(editor) || {};
  const marks = Object.fromEntries(allMarks.map(mark => [mark, {
    isDisabled: locationDocumentFeatures.inlineMarks !== 'inherit' && !locationDocumentFeatures.inlineMarks[mark] || !maybeCodeBlockEntry,
    isSelected: !!editorMarks[mark]
  }])); // Editor.marks is "what are the marks that would be applied if text was inserted now"
  // that's not really the UX we want, if we have some a document like this
  // <paragraph>
  //   <text>
  //     <anchor />
  //     content
  //   </text>
  //   <text bold>bold</text>
  //   <text>
  //     content
  //     <focus />
  //   </text>
  // </paragraph>
  // we want bold to be shown as selected even though if you inserted text from that selection, it wouldn't be bold
  // so we look at all the text nodes in the selection to get their marks
  // but only if the selection is expanded because if you're in the middle of some text
  // with your selection collapsed with a mark but you've removed it(i.e. editor.removeMark)
  // the text nodes you're in will have the mark but the ui should show the mark as not being selected

  if (editor.selection && slate.Range.isExpanded(editor.selection)) {
    for (const node of slate.Editor.nodes(editor, {
      match: slate.Text.isText
    })) {
      for (const key of Object.keys(node[0])) {
        if (key === 'insertMenu' || key === 'text') {
          continue;
        }

        if (key in marks) {
          marks[key].isSelected = true;
        }
      }
    }
  }

  let [headingEntry] = slate.Editor.nodes(editor, {
    match: nodeTypeMatcher('heading')
  });
  let [listEntry] = slate.Editor.nodes(editor, {
    match: isListNode
  });
  let [alignableEntry] = slate.Editor.nodes(editor, {
    match: nodeTypeMatcher('paragraph', 'heading')
  }); // (we're gonna use markdown here because the equivelant slate structure is quite large and doesn't add value here)
  // let's imagine a document that looks like this:
  // - thing
  //   1. something<cursor />
  // in the toolbar, you don't want to see that both ordered and unordered lists are selected
  // you want to see only ordered list selected, because
  // - you want to know what list you're actually in, you don't really care about the outer list
  // - when you want to change the list to a unordered list, the unordered list button should be inactive to show you can change to it

  const listTypeAbove = getListTypeAbove(editor);
  return {
    marks,
    textStyles: {
      selected: headingEntry ? headingEntry[0].level : 'normal',
      allowedHeadingLevels: locationDocumentFeatures.kind === 'block' && !listEntry ? locationDocumentFeatures.documentFeatures.formatting.headingLevels : []
    },
    relationships: {
      isDisabled: !locationDocumentFeatures.documentFeatures.relationships
    },
    code: {
      isSelected: isElementActive(editor, 'code'),
      isDisabled: !(locationDocumentFeatures.kind === 'block' && locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)
    },
    lists: {
      ordered: {
        isSelected: isElementActive(editor, 'ordered-list') && (listTypeAbove === 'none' || listTypeAbove === 'ordered-list'),
        isDisabled: !(locationDocumentFeatures.kind === 'block' && locationDocumentFeatures.documentFeatures.formatting.listTypes.ordered && !headingEntry)
      },
      unordered: {
        isSelected: isElementActive(editor, 'unordered-list') && (listTypeAbove === 'none' || listTypeAbove === 'unordered-list'),
        isDisabled: !(locationDocumentFeatures.kind === 'block' && locationDocumentFeatures.documentFeatures.formatting.listTypes.unordered && !headingEntry)
      }
    },
    alignment: {
      isDisabled: !alignableEntry && !(locationDocumentFeatures.kind === 'block' && locationDocumentFeatures.documentFeatures.formatting.alignment),
      selected: (alignableEntry === null || alignableEntry === void 0 ? void 0 : alignableEntry[0].textAlign) || 'start'
    },
    blockquote: {
      isDisabled: !(locationDocumentFeatures.kind === 'block' && locationDocumentFeatures.documentFeatures.formatting.blockTypes.blockquote),
      isSelected: isElementActive(editor, 'blockquote')
    },
    layouts: {
      isSelected: isElementActive(editor, 'layout')
    },
    links: {
      isDisabled: !editor.selection || slate.Range.isCollapsed(editor.selection) || !locationDocumentFeatures.documentFeatures.links,
      isSelected: isElementActive(editor, 'link')
    },
    editor,
    dividers: {
      isDisabled: locationDocumentFeatures.kind === 'inline' || !locationDocumentFeatures.documentFeatures.dividers
    },
    clearFormatting: {
      isDisabled: !(Object.values(marks).some(x => x.isSelected) || !!hasBlockThatClearsOnClearFormatting(editor))
    },
    editorDocumentFeatures
  };
};

function hasBlockThatClearsOnClearFormatting(editor) {
  const [node] = slate.Editor.nodes(editor, {
    match: node => node.type === 'heading' || node.type === 'code' || node.type === 'blockquote'
  });
  return !!node;
}

function getListTypeAbove(editor) {
  const listAbove = slate.Editor.above(editor, {
    match: isListNode
  });

  if (!listAbove) {
    return 'none';
  }

  return listAbove[0].type;
}
const ToolbarStateProvider = ({
  children,
  componentBlocks,
  editorDocumentFeatures,
  relationships
}) => {
  const editor = slateReact.useSlate();
  return /*#__PURE__*/React__default["default"].createElement(DocumentFieldRelationshipsProvider, {
    value: relationships
  }, /*#__PURE__*/React__default["default"].createElement(LayoutOptionsProvider, {
    value: editorDocumentFeatures.layouts
  }, /*#__PURE__*/React__default["default"].createElement(ComponentBlockContext.Provider, {
    value: componentBlocks
  }, /*#__PURE__*/React__default["default"].createElement(ToolbarStateContext.Provider, {
    value: createToolbarState(editor, componentBlocks, editorDocumentFeatures)
  }, children))));
};

const isLinkActive = editor => {
  return isElementActive(editor, 'link');
};

const wrapLink = (editor, url) => {
  if (isLinkActive(editor)) {
    slate.Transforms.unwrapNodes(editor, {
      match: n => n.type === 'link'
    });
    return;
  }

  const {
    selection
  } = editor;
  const isCollapsed = selection && slate.Range.isCollapsed(selection);

  if (isCollapsed) {
    slate.Transforms.insertNodes(editor, {
      type: 'link',
      href: url,
      children: [{
        text: url
      }]
    });
  } else {
    slate.Transforms.wrapNodes(editor, {
      type: 'link',
      href: url,
      children: [{
        text: ''
      }]
    }, {
      split: true
    });
  }
};
const LinkElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const {
    typography
  } = core.useTheme();
  const editor = slateReact.useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const href = currentElement.href;
  const selected = slateReact.useSelected();
  const focused = slateReact.useFocused();
  const [focusedInInlineDialog, setFocusedInInlineDialog] = React.useState(false);
  const [localForceValidation, setLocalForceValidation] = React.useState(false);
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: selected && focused || focusedInInlineDialog,
    onClose: () => {}
  }, {
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  const unlink = useEventCallback(() => {
    slate.Transforms.unwrapNodes(editor, {
      at: slateReact.ReactEditor.findPath(editor, __elementForGettingPath)
    });
  });
  const forceValidation = useForceValidation();
  const showInvalidState = api.isValidURL(href) ? false : forceValidation || localForceValidation;
  return core.jsx("span", _extends({}, attributes, {
    css: {
      position: 'relative',
      display: 'inline-block'
    }
  }), core.jsx("a", _extends({}, trigger.props, {
    css: {
      color: showInvalidState ? 'red' : undefined
    },
    ref: trigger.ref,
    href: href
  }), children), (selected && focused || focusedInInlineDialog) && core.jsx(core.Portal, null, core.jsx(toolbar.InlineDialog, _extends({}, dialog.props, {
    ref: dialog.ref,
    onFocus: () => {
      setFocusedInInlineDialog(true);
    },
    onBlur: () => {
      setFocusedInInlineDialog(false);
      setLocalForceValidation(true);
    }
  }), core.jsx("div", {
    css: {
      display: 'flex',
      flexDirection: 'column'
    }
  }, core.jsx(toolbar.ToolbarGroup, null, core.jsx("input", {
    css: {
      fontSize: typography.fontSize.small,
      width: 240
    },
    value: href,
    onChange: event => {
      setNode({
        href: event.target.value
      });
    }
  }), core.jsx(tooltip.Tooltip, {
    content: "Open link in new tab",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    as: "a",
    onMouseDown: event => {
      event.preventDefault();
    },
    href: href,
    target: "_blank",
    rel: "noreferrer",
    variant: "action"
  }, attrs), externalLinkIcon)), separator, core.jsx(UnlinkButton, {
    onUnlink: unlink
  })), showInvalidState && core.jsx("span", {
    css: {
      color: 'red'
    }
  }, "Please enter a valid URL")))));
};
const separator = core.jsx(toolbar.ToolbarSeparator, null);
const externalLinkIcon = core.jsx(ExternalLinkIcon.ExternalLinkIcon, {
  size: "small"
});
const UnlinkButton = /*#__PURE__*/React.memo(function UnlinkButton({
  onUnlink
}) {
  return core.jsx(tooltip.Tooltip, {
    content: "Unlink",
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    variant: "destructive",
    onMouseDown: event => {
      event.preventDefault();
      onUnlink();
    }
  }, attrs), core.jsx(Trash2Icon.Trash2Icon, {
    size: "small"
  })));
});
let linkIcon = core.jsx(LinkIcon.LinkIcon, {
  size: "small"
});
const LinkButton = /*#__PURE__*/React.forwardRef(function LinkButton(props, ref) {
  const {
    editor,
    links: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    ref: ref,
    isDisabled: isDisabled,
    isSelected: isSelected,
    onMouseDown: event => {
      event.preventDefault();
      wrapLink(editor, '');
    }
  }, props), linkIcon), [isSelected, isDisabled, editor, props, ref]);
});
const linkButton = core.jsx(tooltip.Tooltip, {
  content: "Link",
  weight: "subtle"
}, attrs => core.jsx(LinkButton, attrs));
const markdownLinkPattern = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function withLink(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    isInline,
    normalizeNode
  } = editor;

  editor.isInline = element => {
    return element.type === 'link' ? true : isInline(element);
  };

  if (editorDocumentFeatures.links) {
    editor.insertText = text => {
      insertText(text);
      if (text !== ')' || !editor.selection) return;
      const startOfBlock = slate.Editor.start(editor, slate.Editor.above(editor, {
        match: node => slate.Editor.isBlock(editor, node)
      })[1]);
      const startOfBlockToEndOfShortcutString = slate.Editor.string(editor, {
        anchor: editor.selection.anchor,
        focus: startOfBlock
      });
      const match = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);
      if (!match) return;
      const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);

      if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {
        return;
      }

      const [, maybeWhitespace, linkText, href] = match; // by doing this, the insertText(')') above will happen in a different undo than the link replacement
      // so that means that when someone does an undo after this
      // it will undo the the state of "[content](link)" rather than "[content](link" (note the missing closing bracket)

      editor.history.undos.push([]);
      const startOfShortcut = match.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
        distance: match.index
      });
      const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {
        distance: maybeWhitespace === '' ? 1 : 2
      });
      const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {
        distance: linkText.length
      });
      slate.Transforms.delete(editor, {
        at: {
          anchor: endOfLinkText,
          focus: editor.selection.anchor
        }
      });
      slate.Transforms.delete(editor, {
        at: {
          anchor: startOfShortcut,
          focus: startOfLinkText
        }
      });
      slate.Transforms.wrapNodes(editor, {
        type: 'link',
        href,
        children: []
      }, {
        at: {
          anchor: editor.selection.anchor,
          focus: startOfShortcut
        }
      });
    };
  }

  editor.normalizeNode = ([node, path]) => {
    if (node.type === 'link' && slate.Node.string(node) === '') {
      slate.Transforms.unwrapNodes(editor, {
        at: path
      });
      return;
    }

    normalizeNode([node, path]);
  };

  return editor;
}

const insertBlockquote = editor => {
  const isActive = isElementActive(editor, 'blockquote');

  if (isActive) {
    slate.Transforms.unwrapNodes(editor, {
      match: node => node.type === 'blockquote'
    });
  } else {
    slate.Transforms.wrapNodes(editor, {
      type: 'blockquote',
      children: []
    });
  }
};

function getDirectBlockquoteParentFromSelection(editor) {
  if (!editor.selection) return {
    isInside: false
  };
  const [, parentPath] = slate.Editor.parent(editor, editor.selection);
  const [maybeBlockquoteParent, maybeBlockquoteParentPath] = slate.Editor.parent(editor, parentPath);
  const isBlockquote = maybeBlockquoteParent.type === 'blockquote';
  return isBlockquote ? {
    isInside: true,
    path: maybeBlockquoteParentPath
  } : {
    isInside: false
  };
}

function withBlockquote(editor) {
  const {
    insertBreak,
    deleteBackward
  } = editor;

  editor.deleteBackward = unit => {
    if (editor.selection) {
      const parentBlockquote = getDirectBlockquoteParentFromSelection(editor);

      if (parentBlockquote.isInside && slate.Range.isCollapsed(editor.selection) && // the selection is at the start of the paragraph
      editor.selection.anchor.offset === 0 && // it's the first paragraph in the panel
      editor.selection.anchor.path[editor.selection.anchor.path.length - 2] === 0) {
        slate.Transforms.unwrapNodes(editor, {
          match: node => node.type === 'blockquote',
          split: true
        });
        return;
      }
    }

    deleteBackward(unit);
  };

  editor.insertBreak = () => {
    const panel = getDirectBlockquoteParentFromSelection(editor);

    if (editor.selection && panel.isInside) {
      const [node, nodePath] = slate.Editor.node(editor, editor.selection);

      if (slate.Path.isDescendant(nodePath, panel.path) && slate.Node.string(node) === '') {
        slate.Transforms.unwrapNodes(editor, {
          match: node => node.type === 'blockquote',
          split: true
        });
        return;
      }
    }

    insertBreak();
  };

  return editor;
}
const BlockquoteElement = ({
  attributes,
  children
}) => {
  const {
    colors,
    spacing
  } = core.useTheme();
  return core.jsx("blockquote", _extends({
    css: {
      borderLeft: '3px solid #CBD5E0',
      color: colors.foregroundDim,
      margin: 0,
      padding: `0 ${spacing.xlarge}px`
    }
  }, attributes), children);
};

const BlockquoteButton = ({
  attrs
}) => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    isSelected: isSelected,
    isDisabled: isDisabled,
    onMouseDown: event => {
      event.preventDefault();
      insertBlockquote(editor);
    }
  }, attrs), core.jsx(QuoteIcon, null)), [editor, attrs, isDisabled, isSelected]);
};

const blockquoteButton = core.jsx(tooltip.Tooltip, {
  content: core.jsx(React.Fragment, null, "Quote", core.jsx(toolbar.KeyboardInTooltip, null, '> ')),
  weight: "subtle"
}, attrs => core.jsx(BlockquoteButton, {
  attrs: attrs
}));

const QuoteIcon = () => core.jsx(IconBase, null, core.jsx("path", {
  d: "M11.3031 2C9.83843 2 8.64879 3.22321 8.64879 4.73171C8.64879 6.23928 9.83843 7.46342 11.3031 7.46342C13.8195 7.46342 12.3613 12.2071 9.18767 12.7012C9.03793 12.7239 8.90127 12.7995 8.80243 12.9143C8.70358 13.029 8.64908 13.1754 8.64879 13.3268C8.64879 13.7147 8.99561 14.0214 9.37973 13.9627C15.148 13.0881 17.1991 2.00093 11.3031 2.00093V2ZM3.65526 2C2.18871 2 1 3.22228 1 4.73171C1 6.23835 2.18871 7.46155 3.65526 7.46155C6.17067 7.46155 4.71252 12.2071 1.53888 12.7012C1.3893 12.7239 1.25277 12.7993 1.15394 12.9139C1.05511 13.0285 1.00051 13.1746 1 13.3259C1 13.7137 1.34682 14.0205 1.73001 13.9617C7.50016 13.0872 9.55128 2 3.65526 2Z"
}));

function withCodeBlock(editor) {
  const {
    insertBreak,
    normalizeNode
  } = editor;

  editor.insertBreak = () => {
    const [node, path] = slate.Editor.above(editor, {
      match: n => slate.Editor.isBlock(editor, n)
    }) || [editor, []];

    if (node.type === 'code' && slate.Text.isText(node.children[0])) {
      const text = node.children[0].text;

      if (text[text.length - 1] === '\n' && editor.selection && slate.Range.isCollapsed(editor.selection) && slate.Point.equals(slate.Editor.end(editor, path), editor.selection.anchor)) {
        insertBreak();
        slate.Transforms.setNodes(editor, {
          type: 'paragraph',
          children: []
        });
        slate.Transforms.delete(editor, {
          distance: 1,
          at: {
            path: [...path, 0],
            offset: text.length - 1
          }
        });
        return;
      }

      editor.insertText('\n');
      return;
    }

    insertBreak();
  };

  editor.normalizeNode = ([node, path]) => {
    if (node.type === 'code' && slate.Element.isElement(node)) {
      for (const [index, childNode] of node.children.entries()) {
        if (!slate.Text.isText(childNode)) {
          if (editor.isVoid(childNode)) {
            slate.Transforms.removeNodes(editor, {
              at: [...path, index]
            });
          } else {
            slate.Transforms.unwrapNodes(editor, {
              at: [...path, index]
            });
          }

          return;
        }

        const marks = Object.keys(childNode).filter(x => x !== 'text');

        if (marks.length) {
          slate.Transforms.unsetNodes(editor, marks, {
            at: [...path, index]
          });
          return;
        }
      }
    }

    normalizeNode([node, path]);
  };

  return editor;
}

function CodeButton({
  attrs
}) {
  const {
    editor,
    code: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    isSelected: isSelected,
    isDisabled: isDisabled,
    onMouseDown: event => {
      event.preventDefault();

      if (isSelected) {
        slate.Transforms.unwrapNodes(editor, {
          match: node => node.type === 'code'
        });
      } else {
        slate.Transforms.wrapNodes(editor, {
          type: 'code',
          children: [{
            text: ''
          }]
        });
      }
    }
  }, attrs), core.jsx(CodeIcon.CodeIcon, {
    size: "small"
  })), [isDisabled, isSelected, attrs, editor]);
}

const codeButton = core.jsx(tooltip.Tooltip, {
  weight: "subtle",
  content: core.jsx(React.Fragment, null, "Code block ", core.jsx(toolbar.KeyboardInTooltip, null, "```"))
}, attrs => core.jsx(CodeButton, {
  attrs: attrs
}));

const TextAlignMenu = ({
  alignment
}) => {
  const [showMenu, setShowMenu] = React.useState(false);
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: showMenu,
    onClose: () => setShowMenu(false)
  }, {
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return core.jsx("div", {
    css: {
      display: 'inline-block',
      position: 'relative'
    }
  }, core.jsx(tooltip.Tooltip, {
    content: "Text alignment",
    weight: "subtle"
  }, attrs => core.jsx(TextAlignButton, {
    attrs: attrs,
    onToggle: () => {
      setShowMenu(x => !x);
    },
    trigger: trigger,
    showMenu: showMenu
  })), showMenu ? core.jsx(toolbar.InlineDialog, _extends({
    ref: dialog.ref
  }, dialog.props), core.jsx(TextAlignDialog, {
    alignment: alignment,
    onClose: () => {
      setShowMenu(false);
    }
  })) : null);
};

function TextAlignDialog({
  alignment,
  onClose
}) {
  const {
    alignment: {
      selected
    },
    editor
  } = useToolbarState();
  const alignments = ['start', ...Object.keys(alignment).filter(key => alignment[key])];
  return core.jsx(toolbar.ToolbarGroup, null, alignments.map(alignment => core.jsx(tooltip.Tooltip, {
    key: alignment,
    content: `Align ${alignment}`,
    weight: "subtle"
  }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
    isSelected: selected === alignment,
    onMouseDown: event => {
      event.preventDefault();

      if (alignment === 'start') {
        slate.Transforms.unsetNodes(editor, 'textAlign', {
          match: node => node.type === 'paragraph' || node.type === 'heading'
        });
      } else {
        slate.Transforms.setNodes(editor, {
          textAlign: alignment
        }, {
          match: node => node.type === 'paragraph' || node.type === 'heading'
        });
      }

      onClose();
    }
  }, attrs), alignmentIcons[alignment]))));
}

const alignmentIcons = {
  start: core.jsx(AlignLeftIcon.AlignLeftIcon, {
    size: "small"
  }),
  center: core.jsx(AlignCenterIcon.AlignCenterIcon, {
    size: "small"
  }),
  end: core.jsx(AlignRightIcon.AlignRightIcon, {
    size: "small"
  })
};

function TextAlignButton(props) {
  const {
    alignment: {
      isDisabled,
      selected
    }
  } = useToolbarState();
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    isDisabled: isDisabled,
    isPressed: props.showMenu,
    onMouseDown: event => {
      event.preventDefault();
      props.onToggle();
    }
  }, props.attrs, props.trigger.props, {
    ref: applyRef.applyRefs(props.attrs.ref, props.trigger.ref)
  }), alignmentIcons[selected], downIcon$1), [isDisabled, selected, props]);
}

const downIcon$1 = core.jsx(ChevronDownIcon.ChevronDownIcon, {
  size: "small"
});

const minusIcon = /*#__PURE__*/React__default["default"].createElement(MinusIcon.MinusIcon, {
  size: "small"
});
function insertDivider(editor) {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
    type: 'divider',
    children: [{
      text: ''
    }]
  });
  slate.Editor.insertNode(editor, {
    type: 'paragraph',
    children: [{
      text: ''
    }]
  });
}

const DividerButton = ({
  attrs
}) => {
  const {
    editor,
    dividers: {
      isDisabled
    }
  } = useToolbarState();
  return React.useMemo(() => /*#__PURE__*/React__default["default"].createElement(toolbar.ToolbarButton, _extends({
    isDisabled: isDisabled,
    onMouseDown: event => {
      event.preventDefault();
      insertDivider(editor);
    }
  }, attrs), minusIcon), [editor, isDisabled, attrs]);
};

const dividerButton = /*#__PURE__*/React__default["default"].createElement(tooltip.Tooltip, {
  content: /*#__PURE__*/React__default["default"].createElement(React.Fragment, null, "Divider", /*#__PURE__*/React__default["default"].createElement(toolbar.KeyboardInTooltip, null, "---")),
  weight: "subtle"
}, attrs => /*#__PURE__*/React__default["default"].createElement(DividerButton, {
  attrs: attrs
}));
function withDivider(editor) {
  const {
    isVoid
  } = editor;

  editor.isVoid = node => {
    return node.type === 'divider' || isVoid(node);
  };

  return editor;
}

const _excluded = ["type"],
      _excluded2 = ["ref"];
function Toolbar({
  documentFeatures,
  viewState
}) {
  const relationship = React.useContext(DocumentFieldRelationshipsContext);
  const blockComponent = React.useContext(ComponentBlockContext);
  const hasBlockItems = Object.entries(relationship).length || Object.keys(blockComponent).length;
  return core.jsx(ToolbarContainer, null, !!documentFeatures.formatting.headingLevels.length && core.jsx(React.Fragment, null, core.jsx(HeadingMenu, {
    headingLevels: documentFeatures.formatting.headingLevels
  }), core.jsx(toolbar.ToolbarSeparator, null)), Object.values(documentFeatures.formatting.inlineMarks).some(x => x) && core.jsx(React.Fragment, null, core.jsx(InlineMarks, {
    marks: documentFeatures.formatting.inlineMarks
  }), core.jsx(toolbar.ToolbarSeparator, null)), (documentFeatures.formatting.alignment.center || documentFeatures.formatting.alignment.end) && core.jsx(TextAlignMenu, {
    alignment: documentFeatures.formatting.alignment
  }), documentFeatures.formatting.listTypes.unordered && core.jsx(tooltip.Tooltip, {
    content: core.jsx(React.Fragment, null, "Bullet List ", core.jsx(toolbar.KeyboardInTooltip, null, "- ")),
    weight: "subtle"
  }, attrs => core.jsx(ListButton, _extends({
    type: "unordered-list"
  }, attrs), core.jsx(BulletListIcon, null))), documentFeatures.formatting.listTypes.ordered && core.jsx(tooltip.Tooltip, {
    content: core.jsx(React.Fragment, null, "Numbered List ", core.jsx(toolbar.KeyboardInTooltip, null, "1. ")),
    weight: "subtle"
  }, attrs => core.jsx(ListButton, _extends({
    type: "ordered-list"
  }, attrs), core.jsx(NumberedListIcon, null))), (documentFeatures.formatting.alignment.center || documentFeatures.formatting.alignment.end || documentFeatures.formatting.listTypes.unordered || documentFeatures.formatting.listTypes.ordered) && core.jsx(toolbar.ToolbarSeparator, null), documentFeatures.dividers && dividerButton, documentFeatures.links && linkButton, documentFeatures.formatting.blockTypes.blockquote && blockquoteButton, !!documentFeatures.layouts.length && core.jsx(LayoutsButton, {
    layouts: documentFeatures.layouts
  }), documentFeatures.formatting.blockTypes.code && codeButton, !!hasBlockItems && core.jsx(InsertBlockMenu, null), core.jsx(toolbar.ToolbarSeparator, null), React.useMemo(() => {
    const ExpandIcon = viewState !== null && viewState !== void 0 && viewState.expanded ? Minimize2Icon.Minimize2Icon : Maximize2Icon.Maximize2Icon;
    return viewState && core.jsx(tooltip.Tooltip, {
      content: viewState.expanded ? 'Collapse' : 'Expand',
      weight: "subtle"
    }, attrs => core.jsx(toolbar.ToolbarButton, _extends({
      onMouseDown: event => {
        event.preventDefault();
        viewState.toggle();
      }
    }, attrs), core.jsx(ExpandIcon, {
      size: "small"
    })));
  }, [viewState]));
}
/* UI Components */

const MarkButton = /*#__PURE__*/React.forwardRef(function MarkButton(props, ref) {
  const {
    editor,
    marks: {
      [props.type]: {
        isDisabled,
        isSelected
      }
    }
  } = useToolbarState();
  return React.useMemo(() => {
    const restProps = _objectWithoutProperties(props, _excluded);

    return core.jsx(toolbar.ToolbarButton, _extends({
      ref: ref,
      isDisabled: isDisabled,
      isSelected: isSelected,
      onMouseDown: event => {
        event.preventDefault();

        if (isSelected) {
          slate.Editor.removeMark(editor, props.type);
        } else {
          slate.Editor.addMark(editor, props.type, true);
        }
      }
    }, restProps));
  }, [editor, isDisabled, isSelected, props, ref]);
});

const ToolbarContainer = ({
  children
}) => {
  const {
    colors,
    spacing
  } = core.useTheme();
  return core.jsx("div", {
    css: {
      backgroundColor: colors.background,
      boxShadow: `0 1px ${colors.border}, 0 -1px ${colors.border}`,
      paddingBottom: spacing.small,
      paddingTop: spacing.small,
      position: 'sticky',
      top: 0,
      zIndex: 2
    }
  }, core.jsx(toolbar.ToolbarGroup, null, children));
};

const downIcon = core.jsx(ChevronDownIcon.ChevronDownIcon, {
  size: "small"
});

function HeadingButton({
  trigger,
  onToggleShowMenu,
  showMenu
}) {
  const {
    textStyles
  } = useToolbarState();
  let buttonLabel = textStyles.selected === 'normal' ? 'Normal text' : 'Heading ' + textStyles.selected;
  const isDisabled = textStyles.allowedHeadingLevels.length === 0;
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    ref: trigger.ref,
    isPressed: showMenu,
    isDisabled: isDisabled,
    onMouseDown: event => {
      event.preventDefault();
      onToggleShowMenu();
    },
    style: {
      textAlign: 'left',
      width: 116
    }
  }, trigger.props), core.jsx("span", {
    css: {
      flex: 1
    }
  }, buttonLabel), downIcon), [buttonLabel, trigger, showMenu, onToggleShowMenu, isDisabled]);
}

const HeadingMenu = ({
  headingLevels
}) => {
  const [showMenu, setShowMenu] = React.useState(false);
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: showMenu,
    onClose: () => setShowMenu(false)
  }, {
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return core.jsx("div", {
    css: {
      display: 'inline-block',
      position: 'relative'
    }
  }, core.jsx(HeadingButton, {
    showMenu: showMenu,
    trigger: trigger,
    onToggleShowMenu: () => {
      setShowMenu(x => !x);
    }
  }), showMenu ? core.jsx(toolbar.InlineDialog, _extends({
    ref: dialog.ref
  }, dialog.props), core.jsx(HeadingDialog, {
    headingLevels: headingLevels,
    onCloseMenu: () => {
      setShowMenu(false);
    }
  })) : null);
};

function HeadingDialog({
  headingLevels,
  onCloseMenu
}) {
  const {
    editor,
    textStyles
  } = useToolbarState();
  return core.jsx(toolbar.ToolbarGroup, {
    direction: "column"
  }, headingLevels.map(hNum => {
    let Tag = `h${hNum}`;
    const isSelected = textStyles.selected === hNum;
    return core.jsx(toolbar.ToolbarButton, {
      key: hNum,
      isSelected: isSelected,
      onMouseDown: event => {
        event.preventDefault();

        if (isSelected) {
          slate.Transforms.unwrapNodes(editor, {
            match: n => n.type === 'heading'
          });
        } else {
          slate.Transforms.setNodes(editor, {
            type: 'heading',
            level: hNum
          }, {
            match: node => node.type === 'paragraph' || node.type === 'heading'
          });
        }

        onCloseMenu();
      }
    }, core.jsx(Tag, null, "Heading ", hNum));
  }));
}

function InsertBlockMenu() {
  const [showMenu, setShowMenu] = React.useState(false);
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: showMenu,
    onClose: () => setShowMenu(false)
  }, {
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return core.jsx("div", {
    css: {
      display: 'inline-block',
      position: 'relative'
    }
  }, core.jsx(tooltip.Tooltip, {
    content: core.jsx(React.Fragment, null, "Insert ", core.jsx(toolbar.KeyboardInTooltip, null, "/")),
    weight: "subtle"
  }, _ref => {
    let {
      ref
    } = _ref,
        attrs = _objectWithoutProperties(_ref, _excluded2);

    return core.jsx(toolbar.ToolbarButton, _extends({
      ref: applyRef.applyRefs(ref, trigger.ref),
      isPressed: showMenu,
      onMouseDown: event => {
        event.preventDefault();
        setShowMenu(v => !v);
      }
    }, trigger.props, attrs), core.jsx(PlusIcon.PlusIcon, {
      size: "small",
      style: {
        strokeWidth: 3
      }
    }), core.jsx(ChevronDownIcon.ChevronDownIcon, {
      size: "small"
    }));
  }), showMenu ? core.jsx(toolbar.InlineDialog, _extends({
    ref: dialog.ref
  }, dialog.props), core.jsx(toolbar.ToolbarGroup, {
    direction: "column"
  }, core.jsx(RelationshipButton, {
    onClose: () => setShowMenu(false)
  }), core.jsx(BlockComponentsButtons, {
    onClose: () => setShowMenu(false)
  }))) : null);
}

function InlineMarks({
  marks
}) {
  const [showMenu, setShowMenu] = React.useState(false);
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: showMenu,
    onClose: () => setShowMenu(false)
  }, {
    placement: 'bottom-start',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return core.jsx(React.Fragment, null, marks.bold && core.jsx(tooltip.Tooltip, {
    content: core.jsx(React.Fragment, null, "Bold", core.jsx(toolbar.KeyboardInTooltip, null, modifierKeyText, "B")),
    weight: "subtle"
  }, attrs => core.jsx(MarkButton, _extends({
    type: "bold"
  }, attrs), core.jsx(BoldIcon.BoldIcon, {
    size: "small",
    style: {
      strokeWidth: 3
    }
  }))), marks.italic && core.jsx(tooltip.Tooltip, {
    content: core.jsx(React.Fragment, null, "Italic", core.jsx(toolbar.KeyboardInTooltip, null, modifierKeyText, "I")),
    weight: "subtle"
  }, attrs => core.jsx(MarkButton, _extends({
    type: "italic"
  }, attrs), core.jsx(ItalicIcon.ItalicIcon, {
    size: "small"
  }))), core.jsx(tooltip.Tooltip, {
    content: "More formatting",
    weight: "subtle"
  }, attrs => core.jsx(MoreFormattingButton, {
    isOpen: showMenu,
    onToggle: () => {
      setShowMenu(v => !v);
    },
    trigger: trigger,
    attrs: attrs
  })), showMenu && core.jsx(MoreFormattingDialog, {
    onCloseMenu: () => {
      setShowMenu(false);
    },
    dialog: dialog,
    marks: marks
  }));
}

function MoreFormattingDialog({
  dialog,
  marks,
  onCloseMenu
}) {
  // not doing optimisations in here because this will only render when it's open
  // which will be rare and you won't be typing while it's open
  const {
    editor,
    clearFormatting: {
      isDisabled
    }
  } = useToolbarState();
  return core.jsx(toolbar.InlineDialog, _extends({
    onMouseDown: event => {
      if (event.target.nodeName === 'BUTTON') {
        onCloseMenu();
      }
    },
    ref: dialog.ref
  }, dialog.props), core.jsx(toolbar.ToolbarGroup, {
    direction: "column"
  }, marks.underline && core.jsx(MarkButton, {
    type: "underline"
  }, core.jsx(ContentInButtonWithShortcut, {
    content: "Underline",
    shortcut: `${modifierKeyText}U`
  })), marks.strikethrough && core.jsx(MarkButton, {
    type: "strikethrough"
  }, "Strikethrough"), marks.code && core.jsx(MarkButton, {
    type: "code"
  }, "Code"), marks.keyboard && core.jsx(MarkButton, {
    type: "keyboard"
  }, "Keyboard"), marks.subscript && core.jsx(MarkButton, {
    type: "subscript"
  }, "Subscript"), marks.superscript && core.jsx(MarkButton, {
    type: "superscript"
  }, "Superscript"), core.jsx(toolbar.ToolbarButton, {
    isDisabled: isDisabled,
    onMouseDown: event => {
      event.preventDefault();
      clearFormatting(editor);
    }
  }, core.jsx(ContentInButtonWithShortcut, {
    content: "Clear Formatting",
    shortcut: `${modifierKeyText}\\`
  }))));
}

function ContentInButtonWithShortcut({
  content,
  shortcut
}) {
  const theme = core.useTheme();
  return core.jsx("span", {
    css: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      width: '100%'
    }
  }, core.jsx("span", null, content), core.jsx("kbd", {
    css: {
      fontFamily: 'inherit',
      marginLeft: theme.spacing.small,
      padding: theme.spacing.xxsmall,
      paddingLeft: theme.spacing.xsmall,
      paddingRight: theme.spacing.xsmall,
      backgroundColor: theme.palette.neutral400,
      borderRadius: theme.radii.xsmall,
      color: theme.colors.foregroundDim,
      whiteSpace: 'pre'
    }
  }, shortcut));
}

function MoreFormattingButton({
  onToggle,
  isOpen,
  trigger,
  attrs
}) {
  const {
    marks
  } = useToolbarState();
  const isActive = marks.strikethrough.isSelected || marks.underline.isSelected || marks.code.isSelected || marks.keyboard.isSelected || marks.subscript.isSelected || marks.superscript.isSelected;
  return React.useMemo(() => core.jsx(toolbar.ToolbarButton, _extends({
    isPressed: isOpen,
    isSelected: isActive,
    onMouseDown: event => {
      event.preventDefault();
      onToggle();
    }
  }, trigger.props, attrs, {
    ref: applyRef.applyRefs(attrs.ref, trigger.ref)
  }), core.jsx(MoreHorizontalIcon.MoreHorizontalIcon, {
    size: "small"
  })), [isActive, onToggle, isOpen, trigger, attrs]);
} // Custom (non-feather) Icons
// ------------------------------


const IconBase = props => core.jsx("svg", _extends({
  "aria-hidden": "true",
  fill: "currentColor",
  focusable: "false",
  height: "16",
  role: "presentation",
  viewBox: "0 0 16 16",
  width: "16"
}, props));

const BulletListIcon = () => core.jsx(IconBase, null, core.jsx("path", {
  d: "M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"
}));

const NumberedListIcon = () => core.jsx(IconBase, null, core.jsx("path", {
  d: "M2.003 2.5a.5.5 0 00-.723-.447l-1.003.5a.5.5 0 00.446.895l.28-.14V6H.5a.5.5 0 000 1h2.006a.5.5 0 100-1h-.503V2.5zM5 3.25a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5A.75.75 0 015 3.25zm0 5a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5A.75.75 0 015 8.25zm0 5a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5a.75.75 0 01-.75-.75zM.924 10.32l.003-.004a.851.851 0 01.144-.153A.66.66 0 011.5 10c.195 0 .306.068.374.146a.57.57 0 01.128.376c0 .453-.269.682-.8 1.078l-.035.025C.692 11.98 0 12.495 0 13.5a.5.5 0 00.5.5h2.003a.5.5 0 000-1H1.146c.132-.197.351-.372.654-.597l.047-.035c.47-.35 1.156-.858 1.156-1.845 0-.365-.118-.744-.377-1.038-.268-.303-.658-.484-1.126-.484-.48 0-.84.202-1.068.392a1.858 1.858 0 00-.348.384l-.007.011-.002.004-.001.002-.001.001a.5.5 0 00.851.525zM.5 10.055l-.427-.26.427.26z"
}));

const headingStylesMap = {
  h1: {
    fontSize: '2.2rem'
  },
  h2: {
    fontSize: '1.8rem'
  },
  h3: {
    fontSize: '1.5rem'
  },
  h4: {
    fontSize: '1.2rem'
  },
  h5: {
    fontSize: '0.83rem'
  },
  h6: {
    fontSize: '0.67rem'
  }
};
const HeadingElement = ({
  attributes,
  children,
  element
}) => {
  const Tag = `h${element.level}`;
  const headingStyle = headingStylesMap[Tag];
  return core.jsx(Tag, _extends({}, attributes, {
    css: _objectSpread(_objectSpread({}, headingStyle), {}, {
      textAlign: element.textAlign
    })
  }), children);
};
function withHeading(editor) {
  const {
    insertBreak
  } = editor;

  editor.insertBreak = () => {
    insertBreak();
    const entry = slate.Editor.above(editor, {
      match: n => n.type === 'heading'
    });
    if (!entry || !editor.selection || !slate.Range.isCollapsed(editor.selection)) return;
    const path = entry[1];

    if ( // we want to unwrap the heading when the user inserted a break at the end of the heading
    // when the user inserts a break at the end of a heading, the new heading
    // that we want to unwrap will be empty so the end will be equal to the selection
    slate.Point.equals(slate.Editor.end(editor, path), editor.selection.anchor)) {
      slate.Transforms.unwrapNodes(editor, {
        at: path
      });
      return;
    } // we also want to unwrap the _previous_ heading when the user inserted a break
    // at the start of the heading, essentially just inserting an empty paragraph above the heading


    if (!slate.Path.hasPrevious(path)) return;
    const previousPath = slate.Path.previous(path);
    const previousNode = slate.Node.get(editor, previousPath);

    if (previousNode.type === 'heading' && previousNode.children.length === 1 && slate.Text.isText(previousNode.children[0]) && previousNode.children[0].text === '') {
      slate.Transforms.unwrapNodes(editor, {
        at: previousPath
      });
    }
  };

  return editor;
}

// and TS doesn't understand the type narrowing when doing a spread for some reason
// so that's why things aren't being spread in some cases

const renderElement = props => {
  switch (props.element.type) {
    case 'layout':
      return core.jsx(LayoutContainer, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });

    case 'layout-area':
      return core.jsx(LayoutArea, props);

    case 'code':
      return core.jsx(CodeElement, props);

    case 'component-block':
      {
        return core.jsx(ComponentBlocksElement, {
          attributes: props.attributes,
          children: props.children,
          element: props.element
        });
      }

    case 'component-inline-prop':
    case 'component-block-prop':
      return core.jsx(ComponentInlineProp, props);

    case 'heading':
      return core.jsx(HeadingElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });

    case 'link':
      return core.jsx(LinkElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });

    case 'ordered-list':
      return core.jsx("ol", props.attributes, props.children);

    case 'unordered-list':
      return core.jsx("ul", props.attributes, props.children);

    case 'list-item':
      return core.jsx("li", props.attributes, props.children);

    case 'list-item-content':
      return core.jsx("span", props.attributes, props.children);

    case 'blockquote':
      return core.jsx(BlockquoteElement, props);

    case 'relationship':
      return core.jsx(RelationshipElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });

    case 'divider':
      return core.jsx(DividerElement, props);

    default:
      return core.jsx("p", _extends({
        css: {
          textAlign: props.element.textAlign
        }
      }, props.attributes), props.children);
  }
};
/* Block Elements */

const CodeElement = ({
  attributes,
  children
}) => {
  const {
    colors,
    radii,
    spacing,
    typography
  } = core.useTheme();
  return core.jsx("pre", _extends({
    spellCheck: "false",
    css: {
      backgroundColor: colors.backgroundDim,
      border: `1px solid ${colors.border}`,
      borderRadius: radii.xsmall,
      fontFamily: typography.fontFamily.monospace,
      fontSize: typography.fontSize.small,
      padding: `${spacing.small}px ${spacing.medium}px`
    }
  }, attributes), core.jsx("code", {
    css: {
      fontFamily: 'inherit'
    }
  }, children));
};

const DividerElement = ({
  attributes,
  children
}) => {
  const {
    colors,
    spacing
  } = core.useTheme();
  const selected = slateReact.useSelected();
  return core.jsx("div", _extends({}, attributes, {
    css: {
      paddingBottom: spacing.medium,
      paddingTop: spacing.medium,
      marginBottom: spacing.medium,
      marginTop: spacing.medium,
      caretColor: 'transparent'
    }
  }), core.jsx("hr", {
    css: {
      backgroundColor: selected ? colors.linkColor : colors.border,
      border: 0,
      height: 2
    }
  }), children);
};

const allMarkdownShortcuts = {
  bold: ['**', '__'],
  italic: ['*', '_'],
  strikethrough: ['~~'],
  code: ['`']
};

function applyMark(editor, mark, shortcutText, startOfStartPoint) {
  // so that this starts a new undo group
  editor.history.undos.push([]);
  const startPointRef = slate.Editor.pointRef(editor, startOfStartPoint);
  slate.Transforms.delete(editor, {
    at: editor.selection.anchor,
    distance: shortcutText.length,
    reverse: true
  });
  slate.Transforms.delete(editor, {
    at: startOfStartPoint,
    distance: shortcutText.length
  });
  slate.Transforms.setNodes(editor, {
    [mark]: true
  }, {
    match: slate.Text.isText,
    split: true,
    at: {
      anchor: startPointRef.unref(),
      focus: editor.selection.anchor
    }
  }); // once you've ended the shortcut, you're done with the mark
  // so we need to remove it so the text you insert after doesn't have it

  editor.removeMark(mark);
}

function withMarks(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    insertBreak
  } = editor;

  editor.insertBreak = () => {
    insertBreak();
    const marksAfterInsertBreak = slate.Editor.marks(editor);
    if (!marksAfterInsertBreak || !editor.selection) return;
    const parentBlock = slate.Editor.above(editor, {
      match: node => slate.Editor.isBlock(editor, node)
    });
    if (!parentBlock) return;
    const point = EditorAfterButIgnoringingPointsWithNoContent(editor, editor.selection.anchor);
    const marksAfterInsertBreakArr = Object.keys(marksAfterInsertBreak);

    if (!point || !slate.Path.isDescendant(point.path, parentBlock[1])) {
      for (const mark of marksAfterInsertBreakArr) {
        editor.removeMark(mark);
      }

      return;
    }

    const textNode = slate.Node.get(editor, point.path);

    for (const mark of marksAfterInsertBreakArr) {
      if (!textNode[mark]) {
        editor.removeMark(mark);
      }
    }
  };

  const selectedMarkdownShortcuts = {};
  const enabledMarks = editorDocumentFeatures.formatting.inlineMarks;
  Object.keys(allMarkdownShortcuts).forEach(mark => {
    if (enabledMarks[mark]) {
      selectedMarkdownShortcuts[mark] = allMarkdownShortcuts[mark];
    }
  });
  if (Object.keys(selectedMarkdownShortcuts).length === 0) return editor;

  editor.insertText = text => {
    insertText(text);

    if (editor.selection && slate.Range.isCollapsed(editor.selection)) {
      for (const [mark, shortcuts] of Object.entries(selectedMarkdownShortcuts)) {
        for (const shortcutText of shortcuts) {
          if (text === shortcutText[shortcutText.length - 1]) {
            const startOfBlock = slate.Editor.start(editor, slate.Editor.above(editor, {
              match: node => slate.Editor.isBlock(editor, node)
            })[1]);
            let startOfBlockToEndOfShortcutString = slate.Editor.string(editor, {
              anchor: editor.selection.anchor,
              focus: startOfBlock
            });
            const hasWhitespaceBeforeEndOfShortcut = /\s/.test(startOfBlockToEndOfShortcutString.substr(-shortcutText.length - 1, 1));
            const endOfShortcutContainsExpectedContent = shortcutText === startOfBlockToEndOfShortcutString.slice(-shortcutText.length);

            if (hasWhitespaceBeforeEndOfShortcut || !endOfShortcutContainsExpectedContent) {
              continue;
            }

            const strToMatchOn = startOfBlockToEndOfShortcutString.slice(0, -shortcutText.length - 1); // TODO: use regex probs

            for (const [offsetFromStartOfBlock] of [...strToMatchOn].reverse().entries()) {
              const expectedShortcutText = strToMatchOn.substr(offsetFromStartOfBlock, shortcutText.length);

              if (expectedShortcutText !== shortcutText) {
                continue;
              }

              const startOfStartOfShortcut = offsetFromStartOfBlock === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
                distance: offsetFromStartOfBlock
              });
              const endOfStartOfShortcut = slate.Editor.after(editor, startOfStartOfShortcut, {
                distance: shortcutText.length
              });

              if (offsetFromStartOfBlock !== 0 && !/\s/.test(slate.Editor.string(editor, {
                anchor: slate.Editor.before(editor, startOfStartOfShortcut, {
                  unit: 'character'
                }),
                focus: startOfStartOfShortcut
              }))) {
                continue;
              }

              const contentBetweenShortcuts = slate.Editor.string(editor, {
                anchor: endOfStartOfShortcut,
                focus: editor.selection.anchor
              }).slice(0, -shortcutText.length);

              if (contentBetweenShortcuts === '' || /\s/.test(contentBetweenShortcuts[0])) {
                continue;
              } // this is a bit of a weird one
              // let's say you had <text>__thing _<cursor /></text> and you insert `_`.
              // without the below, that would turn into <text italic>_thing _<cursor /></text>
              // but it's probably meant to be bold but it's not because of the space before the ending _
              // there's probably a better way to do this but meh, this works


              if (mark === 'italic' && (contentBetweenShortcuts[0] === '_' || contentBetweenShortcuts[0] === '*')) {
                continue;
              }

              const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);

              if (ancestorComponentChildFieldDocumentFeatures && ancestorComponentChildFieldDocumentFeatures.inlineMarks !== 'inherit' && ancestorComponentChildFieldDocumentFeatures.inlineMarks[mark] === false) {
                continue;
              }

              applyMark(editor, mark, shortcutText, startOfStartOfShortcut);
              return;
            }
          }
        }
      }
    }
  };

  return editor;
}

let noop = () => {};

function getOptions(toolbarState, componentBlocks, relationships) {
  const options = [...Object.entries(relationships).filter(x => x[1].kind === 'inline').map(([relationship, {
    label
  }]) => ({
    label,
    insert: editor => {
      slate.Transforms.insertNodes(editor, {
        type: 'relationship',
        relationship,
        data: null,
        children: [{
          text: ''
        }]
      });
    }
  })), ...Object.keys(componentBlocks).map(key => ({
    label: componentBlocks[key].label,
    insert: editor => {
      insertComponentBlock(editor, componentBlocks, key, relationships);
    }
  })), ...toolbarState.textStyles.allowedHeadingLevels.map(level => ({
    label: `Heading ${level}`,

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'heading',
        level,
        children: [{
          text: ''
        }]
      });
    }

  })), !toolbarState.blockquote.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.blockquote && {
    label: 'Blockquote',

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'blockquote',
        children: [{
          text: ''
        }]
      });
    }

  }, !toolbarState.code.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.code && {
    label: 'Code block',

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'code',
        children: [{
          text: ''
        }]
      });
    }

  }, !toolbarState.dividers.isDisabled && toolbarState.editorDocumentFeatures.dividers && {
    label: 'Divider',

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'divider',
        children: [{
          text: ''
        }]
      });
    }

  }, !!toolbarState.editorDocumentFeatures.layouts.length && {
    label: 'Layout',

    insert(editor) {
      insertLayout(editor, toolbarState.editorDocumentFeatures.layouts[0]);
    }

  }, !toolbarState.lists.ordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.ordered && {
    label: 'Numbered List',
    keywords: ['ordered list'],

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'ordered-list',
        children: [{
          text: ''
        }]
      });
    }

  }, !toolbarState.lists.unordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.unordered && {
    label: 'Bullet List',
    keywords: ['unordered list'],

    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: 'unordered-list',
        children: [{
          text: ''
        }]
      });
    }

  }];
  return options.filter(x => typeof x !== 'boolean');
}

function insertOption(editor, text, option) {
  const path = slateReact.ReactEditor.findPath(editor, text);
  slate.Transforms.delete(editor, {
    at: {
      focus: slate.Editor.start(editor, path),
      anchor: slate.Editor.end(editor, path)
    }
  });
  option.insert(editor);
} // TODO: the changing width of the menu when searching isn't great


function InsertMenu({
  children,
  text
}) {
  const toolbarState = useToolbarState();
  const {
    editor,
    relationships: {
      isDisabled: relationshipsDisabled
    }
  } = toolbarState;
  const {
    dialog,
    trigger
  } = popover.useControlledPopover({
    isOpen: true,
    onClose: noop
  }, {
    placement: 'bottom-start'
  });
  const componentBlocks = React.useContext(ComponentBlockContext);
  const relationships = useDocumentFieldRelationships();
  const options = matchSorter.matchSorter(getOptions(toolbarState, componentBlocks, relationshipsDisabled ? {} : relationships), text.text.slice(1), {
    keys: ['label', 'keywords']
  });
  const [selectedIndex, setSelectedIndex] = React.useState(0);

  if (options.length && selectedIndex >= options.length) {
    setSelectedIndex(0);
  }

  const stateRef = React.useRef({
    selectedIndex,
    options,
    text
  });
  React.useEffect(() => {
    stateRef.current = {
      selectedIndex,
      options,
      text
    };
  });
  const dialogRef = React.useRef(null);
  React.useEffect(() => {
    var _dialogRef$current, _dialogRef$current$ch;

    const element = (_dialogRef$current = dialogRef.current) === null || _dialogRef$current === void 0 ? void 0 : (_dialogRef$current$ch = _dialogRef$current.children) === null || _dialogRef$current$ch === void 0 ? void 0 : _dialogRef$current$ch[selectedIndex];

    if (dialogRef.current && element) {
      scrollIntoView__default["default"](element, {
        scrollMode: 'if-needed',
        boundary: dialogRef.current,
        block: 'nearest'
      });
    }
  }, [selectedIndex]);
  React.useEffect(() => {
    const domNode = slateReact.ReactEditor.toDOMNode(editor, editor);

    let listener = event => {
      if (event.defaultPrevented) return;

      switch (event.key) {
        case 'ArrowDown':
          {
            if (stateRef.current.options.length) {
              event.preventDefault();
              setSelectedIndex(stateRef.current.selectedIndex === stateRef.current.options.length - 1 ? 0 : stateRef.current.selectedIndex + 1);
            }

            return;
          }

        case 'ArrowUp':
          {
            if (stateRef.current.options.length) {
              event.preventDefault();
              setSelectedIndex(stateRef.current.selectedIndex === 0 ? stateRef.current.options.length - 1 : stateRef.current.selectedIndex - 1);
            }

            return;
          }

        case 'Enter':
          {
            const option = stateRef.current.options[stateRef.current.selectedIndex];

            if (option) {
              insertOption(editor, stateRef.current.text, option);
              event.preventDefault();
            }

            return;
          }

        case 'Escape':
          {
            const path = slateReact.ReactEditor.findPath(editor, stateRef.current.text);
            slate.Transforms.unsetNodes(editor, 'insertMenu', {
              at: path
            });
            event.preventDefault();
            return;
          }
      }
    };

    domNode.addEventListener('keydown', listener);
    return () => {
      domNode.removeEventListener('keydown', listener);
    };
  }, [editor]);
  const DIALOG_HEIGHT = 300;
  return core.jsx(React.Fragment, null, core.jsx("span", _extends({}, trigger.props, {
    css: {
      color: 'blue'
    },
    ref: trigger.ref
  }), children), core.jsx(core.Portal, null, core.jsx(toolbar.InlineDialog, _extends({
    contentEditable: false
  }, dialog.props, {
    css: {
      display: options.length ? undefined : 'none',
      userSelect: 'none',
      maxHeight: DIALOG_HEIGHT
    },
    ref: dialog.ref
  }), core.jsx("div", {
    ref: dialogRef,
    css: {
      overflowY: 'auto',
      maxHeight: DIALOG_HEIGHT - 8 * 2
    }
  }, options.map((option, index) => core.jsx(toolbar.ToolbarButton, {
    key: option.label,
    isPressed: index === selectedIndex,
    onMouseEnter: () => {
      setSelectedIndex(index);
    },
    onMouseDown: event => {
      event.preventDefault();
      insertOption(editor, text, option);
    }
  }, option.label))))));
}
const nodeListsWithoutInsertMenu = new WeakSet();
const nodesWithoutInsertMenu = new WeakSet();

function findPathWithInsertMenu(node, path) {
  if (slate.Text.isText(node)) {
    return node.insertMenu ? path : undefined;
  }

  if (nodeListsWithoutInsertMenu.has(node.children)) {
    return;
  }

  for (const [index, child] of node.children.entries()) {
    if (nodesWithoutInsertMenu.has(child)) continue;
    let maybePath = findPathWithInsertMenu(child, [...path, index]);

    if (maybePath) {
      return maybePath;
    }

    nodesWithoutInsertMenu.add(child);
  }

  nodeListsWithoutInsertMenu.add(node.children);
}

function removeInsertMenuMarkWhenOutsideOfSelection(editor) {
  var _Editor$marks;

  const path = findPathWithInsertMenu(editor, []);

  if (path && !((_Editor$marks = slate.Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks.insertMenu) && (!editor.selection || !slate.Path.equals(editor.selection.anchor.path, path) || !slate.Path.equals(editor.selection.focus.path, path))) {
    slate.Transforms.unsetNodes(editor, 'insertMenu', {
      at: path
    });
    return true;
  }

  return false;
}

function withInsertMenu(editor) {
  const {
    normalizeNode,
    apply,
    insertText
  } = editor;

  editor.normalizeNode = ([node, path]) => {
    if (slate.Text.isText(node) && node.insertMenu) {
      if (node.text[0] !== '/') {
        slate.Transforms.unsetNodes(editor, 'insertMenu', {
          at: path
        });
        return;
      }

      const whitespaceMatch = /\s/.exec(node.text);

      if (whitespaceMatch) {
        slate.Transforms.unsetNodes(editor, 'insertMenu', {
          at: {
            anchor: {
              path,
              offset: whitespaceMatch.index
            },
            focus: slate.Editor.end(editor, path)
          },
          match: slate.Text.isText,
          split: true
        });
        return;
      }
    }

    if (slate.Editor.isEditor(editor) && removeInsertMenuMarkWhenOutsideOfSelection(editor)) {
      return;
    }

    normalizeNode([node, path]);
  };

  editor.apply = op => {
    apply(op); // we're calling this here AND in normalizeNode
    // because normalizeNode won't be called on selection changes
    // but apply will
    // we're still calling this from normalizeNode though because we want it to happen
    // when normalization happens

    if (op.type === 'set_selection') {
      removeInsertMenuMarkWhenOutsideOfSelection(editor);
    }
  };

  editor.insertText = text => {
    insertText(text);

    if (editor.selection && text === '/') {
      const startOfBlock = slate.Editor.start(editor, slate.Editor.above(editor, {
        match: node => slate.Editor.isBlock(editor, node)
      })[1]);
      const before = slate.Editor.before(editor, editor.selection.anchor, {
        unit: 'character'
      });

      if (before && (slate.Point.equals(startOfBlock, before) || before.offset !== 0 && /\s/.test(slate.Node.get(editor, before.path).text[before.offset - 1]))) {
        slate.Transforms.setNodes(editor, {
          insertMenu: true
        }, {
          at: {
            anchor: before,
            focus: editor.selection.anchor
          },
          match: slate.Text.isText,
          split: true
        });
      }
    }
  };

  return editor;
}

/** @jsxRuntime classic */

function Placeholder({
  placeholder,
  children
}) {
  const [width, setWidth] = React.useState(0);
  return core.jsx("span", {
    css: {
      position: 'relative',
      display: 'inline-block',
      width
    }
  }, core.jsx("span", {
    contentEditable: false,
    style: {
      position: 'absolute',
      pointerEvents: 'none',
      display: 'inline-block',
      left: 0,
      top: 0,
      maxWidth: '100%',
      whiteSpace: 'nowrap',
      opacity: '0.5',
      userSelect: 'none',
      fontStyle: 'normal',
      fontWeight: 'normal',
      textDecoration: 'none',
      textAlign: 'left'
    }
  }, core.jsx("span", {
    ref: node => {
      if (node) {
        const offsetWidth = node.offsetWidth;

        if (offsetWidth !== width) {
          setWidth(offsetWidth);
        }
      }
    }
  }, placeholder)), children);
}

const Leaf = ({
  leaf,
  text,
  children,
  attributes
}) => {
  const {
    colors,
    radii,
    spacing,
    typography
  } = core.useTheme();
  const {
    underline,
    strikethrough,
    bold,
    italic,
    code,
    keyboard,
    superscript,
    subscript,
    placeholder,
    insertMenu
  } = leaf;

  if (placeholder !== undefined) {
    children = core.jsx(Placeholder, {
      placeholder: placeholder
    }, children);
  }

  if (insertMenu) {
    children = core.jsx(InsertMenu, {
      text: text
    }, children);
  }

  if (code) {
    children = core.jsx("code", {
      css: {
        backgroundColor: colors.backgroundDim,
        borderRadius: radii.xsmall,
        display: 'inline-block',
        fontFamily: typography.fontFamily.monospace,
        fontSize: typography.fontSize.small,
        padding: `0 ${spacing.xxsmall}px`
      }
    }, children);
  }

  if (bold) {
    children = core.jsx("strong", null, children);
  }

  if (strikethrough) {
    children = core.jsx("s", null, children);
  }

  if (italic) {
    children = core.jsx("em", null, children);
  }

  if (keyboard) {
    children = core.jsx("kbd", null, children);
  }

  if (superscript) {
    children = core.jsx("sup", null, children);
  }

  if (subscript) {
    children = core.jsx("sub", null, children);
  }

  if (underline) {
    children = core.jsx("u", null, children);
  }

  return core.jsx("span", attributes, children);
};

const renderLeaf = props => {
  return core.jsx(Leaf, props);
};

function withSoftBreaks(isShiftPressedRef, editor) {
  const {
    insertBreak
  } = editor; // TODO: should soft breaks only work in particular places

  editor.insertBreak = () => {
    if (isShiftPressedRef.current) {
      slate.Transforms.insertText(editor, '\n');
    } else {
      insertBreak();
    }
  };

  return editor;
}
function useKeyDownRef(targetKey) {
  const ref = React.useRef(false);
  React.useEffect(() => {
    const handleKeyDown = e => {
      if (e.key !== targetKey) return;
      ref.current = true;
    };

    const handleKeyUp = e => {
      if (e.key !== targetKey) return;
      ref.current = false;
    };

    document.addEventListener('keydown', handleKeyDown, {
      passive: true
    });
    document.addEventListener('keyup', handleKeyUp, {
      passive: true
    });
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, [targetKey]);
  return ref;
}

const shortcuts = {
  '...': 'â€¦',
  '-->': 'â†’',
  '->': 'â†’',
  '<-': 'â†',
  '<--': 'â†',
  '--': 'â€“'
};
function withShortcuts(editor) {
  const {
    insertText
  } = editor;

  editor.insertText = text => {
    insertText(text);

    if (text === ' ' && editor.selection && slate.Range.isCollapsed(editor.selection)) {
      const selectionPoint = editor.selection.anchor;
      const ancestorBlock = slate.Editor.above(editor, {
        match: node => slate.Editor.isBlock(editor, node)
      });

      if (ancestorBlock) {
        Object.keys(shortcuts).forEach(shortcut => {
          const pointBefore = slate.Editor.before(editor, selectionPoint, {
            unit: 'character',
            distance: shortcut.length + 1
          });

          if (pointBefore && slate.Path.isDescendant(pointBefore.path, ancestorBlock[1])) {
            const range = {
              anchor: selectionPoint,
              focus: pointBefore
            };
            const str = slate.Editor.string(editor, range);

            if (str.substr(0, shortcut.length) === shortcut) {
              editor.history.undos.push([]);
              slate.Transforms.select(editor, range);
              editor.insertText(shortcuts[shortcut] + ' ');
            }
          }
        });
      }
    }
  };

  return editor;
}

function withBlockMarkdownShortcuts(documentFeatures, componentBlocks, editor) {
  const {
    insertText
  } = editor;
  const shortcuts = Object.create(null);

  const editorDocumentFeaturesForNormalizationToCheck = _objectSpread(_objectSpread({}, documentFeatures), {}, {
    relationships: true
  });

  let addShortcut = (text, insert, shouldBeEnabledInComponentBlock, type = 'paragraph') => {
    if (!shouldBeEnabledInComponentBlock(editorDocumentFeaturesForNormalizationToCheck)) return;
    const trigger = text[text.length - 1];

    if (!shortcuts[trigger]) {
      shortcuts[trigger] = Object.create(null);
    }

    shortcuts[trigger][text] = {
      insert,
      type,
      shouldBeEnabledInComponentBlock
    };
  };

  addShortcut('1. ', () => {
    slate.Transforms.wrapNodes(editor, {
      type: 'ordered-list',
      children: []
    }, {
      match: n => slate.Editor.isBlock(editor, n)
    });
  }, features => features.formatting.listTypes.ordered);
  addShortcut('- ', () => {
    slate.Transforms.wrapNodes(editor, {
      type: 'unordered-list',
      children: []
    }, {
      match: n => slate.Editor.isBlock(editor, n)
    });
  }, features => features.formatting.listTypes.unordered);
  addShortcut('* ', () => {
    slate.Transforms.wrapNodes(editor, {
      type: 'unordered-list',
      children: []
    }, {
      match: n => slate.Editor.isBlock(editor, n)
    });
  }, features => features.formatting.listTypes.unordered);
  documentFeatures.formatting.headingLevels.forEach(level => {
    addShortcut('#'.repeat(level) + ' ', () => {
      slate.Transforms.setNodes(editor, {
        type: 'heading',
        level
      }, {
        match: node => node.type === 'paragraph' || node.type === 'heading'
      });
    }, features => features.formatting.headingLevels.includes(level), 'heading-or-paragraph');
  });
  addShortcut('> ', () => {
    slate.Transforms.wrapNodes(editor, {
      type: 'blockquote',
      children: []
    }, {
      match: node => node.type === 'paragraph'
    });
  }, features => features.formatting.blockTypes.blockquote);
  addShortcut('```', () => {
    slate.Transforms.wrapNodes(editor, {
      type: 'code',
      children: []
    }, {
      match: node => node.type === 'paragraph'
    });
  }, features => features.formatting.blockTypes.code);
  addShortcut('---', () => {
    insertDivider(editor);
  }, features => features.dividers);

  editor.insertText = text => {
    insertText(text);
    const shortcutsForTrigger = shortcuts[text];

    if (shortcutsForTrigger && editor.selection && slate.Range.isCollapsed(editor.selection)) {
      const {
        anchor
      } = editor.selection;
      const block = slate.Editor.above(editor, {
        match: node => slate.Editor.isBlock(editor, node)
      });
      if (!block || block[0].type !== 'paragraph' && block[0].type !== 'heading') return;
      const start = slate.Editor.start(editor, block[1]);
      const range = {
        anchor,
        focus: start
      };
      const shortcutText = slate.Editor.string(editor, range);
      const shortcut = shortcutsForTrigger[shortcutText];

      if (!shortcut || shortcut.type === 'paragraph' && block[0].type !== 'paragraph') {
        return;
      }

      const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);

      if (locationDocumentFeatures && (locationDocumentFeatures.kind === 'inline' || !shortcut.shouldBeEnabledInComponentBlock(locationDocumentFeatures.documentFeatures))) {
        return;
      } // so that this starts a new undo group


      editor.history.undos.push([]);
      slate.Transforms.select(editor, range);
      slate.Transforms.delete(editor);
      shortcut.insert();
    }
  };

  return editor;
}

// a v important note
// marks in the markdown ast/html are represented quite differently to how they are in slate
// if you had the markdown **something https://keystonejs.com something**
// the bold node is the parent of the link node
// but in slate, marks are only represented on text nodes
const currentlyActiveMarks = new Set();
const currentlyDisabledMarks = new Set();
function addMarkToChildren(mark, cb) {
  const wasPreviouslyActive = currentlyActiveMarks.has(mark);
  currentlyActiveMarks.add(mark);

  try {
    return cb();
  } finally {
    if (!wasPreviouslyActive) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function addMarksToChildren(marks, cb) {
  const marksToRemove = new Set();

  for (const mark of marks) {
    if (!currentlyActiveMarks.has(mark)) {
      marksToRemove.add(mark);
    }

    currentlyActiveMarks.add(mark);
  }

  try {
    return cb();
  } finally {
    for (const mark of marksToRemove) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function forceDisableMarkForChildren(mark, cb) {
  const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);
  currentlyDisabledMarks.add(mark);

  try {
    return cb();
  } finally {
    if (!wasPreviouslyDisabled) {
      currentlyDisabledMarks.delete(mark);
    }
  }
}
function getTextNodeForCurrentlyActiveMarks(text) {
  const node = {
    text
  };

  for (const mark of currentlyActiveMarks) {
    if (!currentlyDisabledMarks.has(mark)) {
      node[mark] = true;
    }
  }

  return node;
}

function getAlignmentFromElement(element) {
  const parent = element.parentElement; // confluence

  const attribute = parent === null || parent === void 0 ? void 0 : parent.getAttribute('data-align'); // note: we don't show html that confluence would parse as alignment
  // we could change that but meh
  // (they match on div.fabric-editor-block-mark with data-align)

  if (attribute === 'center' || attribute === 'end') {
    return attribute;
  }

  if (element instanceof HTMLElement) {
    // Google docs
    const textAlign = element.style.textAlign;

    if (textAlign === 'center') {
      return 'center';
    } // TODO: RTL things?


    if (textAlign === 'right' || textAlign === 'end') {
      return 'end';
    }
  }
} // See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types


const ELEMENT_TAGS = {
  A: el => ({
    type: 'link',
    href: el.getAttribute('href'),
    // underline is on links in Google Docs
    children: forceDisableMarkForChildren('underline', () => deserializeChildren$1(el.childNodes))
  }),
  BLOCKQUOTE: () => ({
    type: 'blockquote'
  }),
  H1: el => ({
    type: 'heading',
    level: 1,
    textAlign: getAlignmentFromElement(el)
  }),
  H2: el => ({
    type: 'heading',
    level: 2,
    textAlign: getAlignmentFromElement(el)
  }),
  H3: el => ({
    type: 'heading',
    level: 3,
    textAlign: getAlignmentFromElement(el)
  }),
  H4: el => ({
    type: 'heading',
    level: 4,
    textAlign: getAlignmentFromElement(el)
  }),
  H5: el => ({
    type: 'heading',
    level: 5,
    textAlign: getAlignmentFromElement(el)
  }),
  H6: el => ({
    type: 'heading',
    level: 6,
    textAlign: getAlignmentFromElement(el)
  }),
  IMG: el => ({
    type: 'paragraph',
    children: [{
      text: `<img alt=${JSON.stringify(el.getAttribute('alt') || '')} src=${JSON.stringify(el.getAttribute('src') || '')}>`
    }]
  }),
  LI: () => ({
    type: 'list-item'
  }),
  OL: () => ({
    type: 'ordered-list'
  }),
  P: el => ({
    type: 'paragraph',
    textAlign: getAlignmentFromElement(el)
  }),
  PRE: () => ({
    type: 'code'
  }),
  UL: () => ({
    type: 'unordered-list'
  }),
  HR: () => ({
    type: 'divider',
    children: [{
      text: ''
    }]
  })
};
const TEXT_TAGS = {
  CODE: 'code',
  DEL: 'strikethrough',
  S: 'strikethrough',
  STRIKE: 'strikethrough',
  EM: 'italic',
  I: 'italic',
  STRONG: 'bold',
  U: 'underline',
  SUP: 'superscript',
  SUB: 'subscript'
};

function marksFromElementAttributes(element) {
  const marks = new Set();

  if (element instanceof HTMLElement) {
    const style = element.style;
    const {
      nodeName
    } = element;
    const markFromNodeName = TEXT_TAGS[nodeName];

    if (markFromNodeName) {
      marks.add(markFromNodeName);
    }

    const {
      fontWeight,
      textDecoration,
      verticalAlign
    } = style;

    if (textDecoration === 'underline') {
      marks.add('underline');
    } else if (textDecoration === 'line-through') {
      marks.add('strikethrough');
    } // confluence


    if (nodeName === 'SPAN' && element.classList.contains('code')) {
      marks.add('code');
    } // Google Docs does weird things with <b>


    if (nodeName === 'B' && fontWeight !== 'normal') {
      marks.add('bold');
    } else if (typeof fontWeight === 'string' && (fontWeight === 'bold' || fontWeight === 'bolder' || fontWeight === '1000' || /^[5-9]\d{2}$/.test(fontWeight))) {
      marks.add('bold');
    }

    if (style.fontStyle === 'italic') {
      marks.add('italic');
    } // Google Docs uses vertical align for subscript and superscript instead of <sup> and <sub>


    if (verticalAlign === 'super') {
      marks.add('superscript');
    } else if (verticalAlign === 'sub') {
      marks.add('subscript');
    }
  }

  return marks;
}

function deserializeHTML(html) {
  const parsed = new DOMParser().parseFromString(html, 'text/html');
  return deserializeHTMLNode(parsed.body);
}
function deserializeHTMLNode(el) {
  if (el.nodeType === 3) {
    const text = el.textContent;

    if (!(text !== null && text !== void 0 && text.trim())) {
      return [];
    }

    return [getTextNodeForCurrentlyActiveMarks(text)];
  }

  if (el.nodeType !== 1) {
    return [];
  }

  let {
    nodeName
  } = el;

  if (nodeName === 'BR') {
    return [getTextNodeForCurrentlyActiveMarks('\n')];
  }

  const marks = marksFromElementAttributes(el); // Dropbox Paper displays blockquotes as lists for some reason

  if (el instanceof globalThis.Element && el.classList.contains('listtype-quote')) {
    marks.delete('italic');
    nodeName = 'BLOCKQUOTE';
  }

  return addMarksToChildren(marks, () => {
    if (ELEMENT_TAGS[nodeName]) {
      const attrs = ELEMENT_TAGS[nodeName](el);

      if (attrs.children) {
        return [attrs];
      }

      let children = deserializeChildren$1(el.childNodes);
      return [_objectSpread(_objectSpread({}, attrs), {}, {
        children: children
      })];
    }

    return deserializeChildren$1(el.childNodes);
  });
}

function deserializeChildren$1(nodes) {
  const outputNodes = [];

  for (const node of nodes) {
    const result = deserializeHTMLNode(node);

    if (result.length) {
      outputNodes.push(...result);
    }
  }

  if (!outputNodes.length) {
    outputNodes.push({
      text: ''
    });
  }

  return outputNodes;
}

const markdownConfig = {
  mdastExtensions: [autoLinkLiteralFromMarkdownExtension__default["default"], gfmStrikethroughFromMarkdownExtension__default["default"]],
  extensions: [autoLinkLiteralMarkdownSyntax__default["default"], gfmStrikethroughMarkdownSyntax__default["default"]()]
};
function deserializeMarkdown(markdown) {
  const root = mdASTUtilFromMarkdown__default["default"](markdown, markdownConfig);
  const getDefinition = definitions__default["default"](root);
  let nodes = root.children;

  if (nodes.length === 1 && nodes[0].type === 'paragraph') {
    nodes = nodes[0].children;
  }

  return deserializeChildren(nodes, getDefinition);
}

function deserializeChildren(nodes, getDefinition) {
  const outputNodes = [];

  for (const node of nodes) {
    const result = deserializeMarkdownNode(node, getDefinition);

    if (result.length) {
      outputNodes.push(...result);
    }
  }

  if (!outputNodes.length) {
    outputNodes.push({
      text: ''
    });
  }

  return outputNodes;
}

function deserializeMarkdownNode(node, getDefinition) {
  switch (node.type) {
    case 'blockquote':
      {
        return [{
          type: 'blockquote',
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'linkReference':
      {
        var _getDefinition;

        return [{
          type: 'link',
          href: ((_getDefinition = getDefinition(node.identifier)) === null || _getDefinition === void 0 ? void 0 : _getDefinition.url) || '',
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'link':
      {
        return [{
          type: 'link',
          href: node.url,
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'code':
      {
        return [{
          type: 'code',
          children: [{
            text: node.value
          }]
        }];
      }

    case 'paragraph':
      {
        return [{
          type: 'paragraph',
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'heading':
      {
        return [{
          type: 'heading',
          level: node.depth,
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'list':
      {
        return [{
          type: node.ordered ? 'ordered-list' : 'unordered-list',
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'imageReference':
      {
        var _getDefinition2;

        return [getTextNodeForCurrentlyActiveMarks(`![${node.alt || ''}](${((_getDefinition2 = getDefinition(node.identifier)) === null || _getDefinition2 === void 0 ? void 0 : _getDefinition2.url) || ''})`)];
      }

    case 'image':
      {
        return [getTextNodeForCurrentlyActiveMarks(`![${node.alt || ''}](${node.url})`)];
      }

    case 'listItem':
      {
        return [{
          type: 'list-item',
          children: deserializeChildren(node.children, getDefinition)
        }];
      }

    case 'thematicBreak':
      {
        return [{
          type: 'divider',
          children: [{
            text: ''
          }]
        }];
      }

    case 'break':
      {
        return [getTextNodeForCurrentlyActiveMarks('\n')];
      }

    case 'delete':
      {
        return addMarkToChildren('strikethrough', () => deserializeChildren(node.children, getDefinition));
      }

    case 'strong':
      {
        return addMarkToChildren('bold', () => deserializeChildren(node.children, getDefinition));
      }

    case 'emphasis':
      {
        return addMarkToChildren('italic', () => deserializeChildren(node.children, getDefinition));
      }

    case 'inlineCode':
      {
        return addMarkToChildren('code', () => [getTextNodeForCurrentlyActiveMarks(node.value)]);
      }
    // while it would be nice if we parsed the html here
    // it's a bit more complicated than just parsing the html
    // because an html node might just be an opening/closing node
    // but we just have an opening/closing node here
    // not the opening and closing and children

    case 'html':
    case 'text':
      {
        return [getTextNodeForCurrentlyActiveMarks(node.value)];
      }
  }

  return [];
}

function insertFragmentButDifferent(editor, nodes) {
  if (slate.Editor.isBlock(editor, nodes[0])) {
    insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes);
  } else {
    slate.Transforms.insertFragment(editor, nodes);
  }
}

function withPasting(editor) {
  const {
    insertData,
    setFragmentData
  } = editor;

  editor.setFragmentData = data => {
    if (editor.selection) {
      data.setData('application/x-keystone-document-editor', 'true');
    }

    setFragmentData(data);
  };

  editor.insertData = data => {
    // this exists because behind the scenes, Slate sets the slate document
    // on the data transfer, this is great because it means when you copy and paste
    // something in the editor or between editors, it'll use the actual Slate data
    // rather than the serialized html so component blocks and etc. will work fine
    // we're setting application/x-keystone-document-editor
    // though so that we only accept slate data from Keystone's editor
    // because other editors will likely have a different structure
    // so we'll rely on the html deserialization instead
    // (note that yes, we do call insertData at the end of this function
    // which is where Slate's logic will run, it'll never do anything there though
    // since anything that will have slate data will also have text/html which we handle
    // before we call insertData)
    // TODO: handle the case of copying between editors with different components blocks
    // (right now, things will blow up in most cases)
    if (data.getData('application/x-keystone-document-editor') === 'true') {
      insertData(data);
      return;
    }

    const blockAbove = slate.Editor.above(editor, {
      match: node => slate.Editor.isBlock(editor, node)
    });

    if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove[0].type) === 'code') {
      const plain = data.getData('text/plain');
      editor.insertText(plain);
      return;
    }

    let vsCodeEditorData = data.getData('vscode-editor-data');

    if (vsCodeEditorData) {
      try {
        const vsCodeData = JSON.parse(vsCodeEditorData);

        if ((vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === 'markdown' || (vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === 'mdx') {
          const plain = data.getData('text/plain');

          if (plain) {
            const fragment = deserializeMarkdown(plain);
            insertFragmentButDifferent(editor, fragment);
            return;
          }
        }
      } catch (err) {
        console.log(err);
      }
    }

    let html = data.getData('text/html');

    if (html) {
      const fragment = deserializeHTML(html);
      insertFragmentButDifferent(editor, fragment);
      return;
    }

    const plain = data.getData('text/plain');

    if (plain) {
      const fragment = deserializeMarkdown(plain);
      insertFragmentButDifferent(editor, fragment);
      return;
    }

    insertData(data);
  };

  return editor;
}

/** @jsxRuntime classic */
const HOTKEYS = {
  'mod+b': 'bold',
  'mod+i': 'italic',
  'mod+u': 'underline'
};
const IS_NODE_LIST_CACHE = new WeakMap(); // a workaround until https://github.com/ianstormtaylor/slate/pull/4072 is merged
// this has taken an average keypress from ~40-50ms to ~20-30ms in dev

slate.Node.isNodeList = value => {
  if (!Array.isArray(value)) {
    return false;
  }

  const cachedResult = IS_NODE_LIST_CACHE.get(value);

  if (cachedResult !== undefined) {
    return cachedResult;
  }

  const isNodeList = value.every(val => slate.Node.isNode(val));
  IS_NODE_LIST_CACHE.set(value, isNodeList);
  return isNodeList;
};

const IS_OPERATION_LIST_CACHE = new WeakMap(); // this has taken pasting a pretty large document from ~5 seconds to ~3 seconds in dev

slate.Operation.isOperationList = value => {
  if (!Array.isArray(value)) {
    return false;
  }

  const cachedResult = IS_OPERATION_LIST_CACHE.get(value);

  if (cachedResult !== undefined) {
    return cachedResult;
  }

  const isOperationList = value.every(val => slate.Operation.isOperation(val));
  IS_OPERATION_LIST_CACHE.set(value, isOperationList);
  return isOperationList;
};

function isMarkActive(editor, mark) {
  const marks = slate.Editor.marks(editor);

  if (marks !== null && marks !== void 0 && marks[mark]) {
    return true;
  } // see the stuff about marks in toolbar-state for why this is here


  for (const entry of slate.Editor.nodes(editor, {
    match: slate.Text.isText
  })) {
    if (entry[0][mark]) {
      return true;
    }
  }

  return false;
}

const getKeyDownHandler = editor => event => {
  if (event.defaultPrevented) return;

  for (const hotkey in HOTKEYS) {
    if (isHotkey__default["default"](hotkey, event.nativeEvent)) {
      event.preventDefault();
      const mark = HOTKEYS[hotkey];
      const isActive = isMarkActive(editor, mark);

      if (isActive) {
        slate.Editor.removeMark(editor, mark);
      } else {
        slate.Editor.addMark(editor, mark, true);
      }

      return;
    }
  }

  if (isHotkey__default["default"]('mod+\\', event.nativeEvent)) {
    clearFormatting(editor);
    return;
  }

  if (isHotkey__default["default"]('mod+k', event.nativeEvent)) {
    event.preventDefault();
    wrapLink(editor, '');
    return;
  }

  if (event.key === 'Tab') {
    if (event.shiftKey) {
      unnestList(editor);
    } else {
      nestList(editor);
    }

    event.preventDefault();
    return;
  }

  if (event.key === 'Tab' && editor.selection) {
    const layoutArea = slate.Editor.above(editor, {
      match: node => node.type === 'layout-area'
    });

    if (layoutArea) {
      const layoutAreaToEnter = event.shiftKey ? slate.Editor.before(editor, layoutArea[1], {
        unit: 'block'
      }) : slate.Editor.after(editor, layoutArea[1], {
        unit: 'block'
      });
      slate.Transforms.setSelection(editor, {
        anchor: layoutAreaToEnter,
        focus: layoutAreaToEnter
      });
      event.preventDefault();
    }
  }
};

function createDocumentEditor(documentFeatures, componentBlocks, relationships, isShiftPressedRef) {
  return withPasting(withSoftBreaks(isShiftPressedRef, withBlocksSchema(withLink(documentFeatures, componentBlocks, withList(withHeading(withRelationship(withInsertMenu(withComponentBlocks(componentBlocks, documentFeatures, relationships, withParagraphs(withShortcuts(withDivider(withLayouts(withMarks(documentFeatures, componentBlocks, withCodeBlock(withBlockMarkdownShortcuts(documentFeatures, componentBlocks, withBlockquote(withDocumentFeaturesNormalization(documentFeatures, relationships, slateHistory.withHistory(slateReact.withReact(slate.createEditor()))))))))))))))))))));
}
function DocumentEditor({
  autoFocus,
  onChange,
  value,
  componentBlocks,
  relationships,
  documentFeatures
}) {
  const isShiftPressedRef = useKeyDownRef('Shift');
  const {
    colors,
    spacing
  } = core.useTheme();
  const [expanded, setExpanded] = React.useState(false);
  const editor = React.useMemo(() => createDocumentEditor(documentFeatures, componentBlocks, relationships, isShiftPressedRef), [documentFeatures, componentBlocks, relationships, isShiftPressedRef]);
  return core.jsx("div", {
    css: [{
      display: 'flex',
      flexDirection: 'column'
    }, expanded && {
      background: colors.background,
      bottom: 0,
      left: 0,
      overflowY: 'auto',
      // required to keep the toolbar stuck in place
      position: 'absolute',
      right: 0,
      top: 0,
      zIndex: 100
    }]
  }, core.jsx(DocumentEditorProvider, {
    componentBlocks: componentBlocks,
    documentFeatures: documentFeatures,
    relationships: relationships,
    editor: editor,
    value: value,
    onChange: value => {
      onChange === null || onChange === void 0 ? void 0 : onChange(value); // this fixes a strange issue in Safari where the selection stays inside of the editor
      // after a blur event happens but the selection is still in the editor
      // so the cursor is visually in the wrong place and it inserts text backwards

      const selection = window.getSelection();

      if (selection && !slateReact.ReactEditor.isFocused(editor)) {
        const editorNode = slateReact.ReactEditor.toDOMNode(editor, editor);

        if (selection.anchorNode === editorNode) {
          slateReact.ReactEditor.focus(editor);
        }
      }
    }
  }, React.useMemo(() => core.jsx(Toolbar, {
    documentFeatures: documentFeatures,
    viewState: {
      expanded,
      toggle: () => {
        setExpanded(v => !v);
      }
    }
  }), [expanded, documentFeatures]), core.jsx(DocumentEditorEditable, {
    css: expanded && {
      marginLeft: spacing.medium,
      marginRight: spacing.medium
    },
    autoFocus: autoFocus,
    readOnly: onChange === undefined
  }), // for debugging
  false ));
}
function DocumentEditorProvider({
  children,
  editor,
  onChange,
  value,
  componentBlocks,
  documentFeatures,
  relationships
}) {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const identity = React.useMemo(() => Math.random().toString(36), [editor]);
  return core.jsx(slateReact.Slate // this fixes issues with Slate crashing when a fast refresh occcurs
  , {
    key: identity,
    editor: editor,
    value: value,
    onChange: value => {
      onChange(value); // this fixes a strange issue in Safari where the selection stays inside of the editor
      // after a blur event happens but the selection is still in the editor
      // so the cursor is visually in the wrong place and it inserts text backwards

      const selection = window.getSelection();

      if (selection && !slateReact.ReactEditor.isFocused(editor)) {
        const editorNode = slateReact.ReactEditor.toDOMNode(editor, editor);

        if (selection.anchorNode === editorNode) {
          slateReact.ReactEditor.focus(editor);
        }
      }
    }
  }, core.jsx(ToolbarStateProvider, {
    componentBlocks: componentBlocks,
    editorDocumentFeatures: documentFeatures,
    relationships: relationships
  }, children));
}
function DocumentEditorEditable({
  autoFocus,
  readOnly,
  className
}) {
  const editor = slateReact.useSlate();
  const componentBlocks = React.useContext(ComponentBlockContext);
  const onKeyDown = React.useMemo(() => getKeyDownHandler(editor), [editor]);
  return core.jsx(slateReact.Editable, {
    decorate: React.useCallback(([node, path]) => {
      let decorations = [];

      if (node.type === 'component-block') {
        if (node.children.length === 1 && slate.Element.isElement(node.children[0]) && node.children[0].type === 'component-inline-prop' && node.children[0].propPath === undefined) {
          return decorations;
        }

        node.children.forEach((child, index) => {
          if (slate.Node.string(child) === '' && slate.Element.isElement(child) && (child.type === 'component-block-prop' || child.type === 'component-inline-prop') && child.propPath !== undefined) {
            const start = slate.Editor.start(editor, [...path, index]);
            const placeholder = getPlaceholderTextForPropPath(child.propPath, componentBlocks[node.component].props, node.props);

            if (placeholder) {
              decorations.push({
                placeholder,
                anchor: start,
                focus: start
              });
            }
          }
        });
      }

      return decorations;
    }, [editor, componentBlocks]),
    css: styles,
    autoFocus: autoFocus,
    onKeyDown: onKeyDown,
    readOnly: readOnly,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    className: className
  });
}

const orderedListStyles = ['lower-roman', 'decimal', 'lower-alpha'];
const unorderedListStyles = ['square', 'disc', 'circle'];
let styles = {
  flex: 1
};
let listDepth = 10;

while (listDepth--) {
  let arr = Array.from({
    length: listDepth
  });

  if (arr.length) {
    styles[arr.map(() => `ol`).join(' ')] = {
      listStyle: orderedListStyles[listDepth % 3]
    };
    styles[arr.map(() => `ul`).join(' ')] = {
      listStyle: unorderedListStyles[listDepth % 3]
    };
  }
}

function makeEditorSchema(obj) {
  let ret = {};
  Object.keys(obj).forEach(key => {
    const val = obj[key];

    if (val.kind === 'blocks') {
      ret[key] = {
        kind: 'blocks',
        allowedChildren: new Set(val.allowedChildren),
        blockToWrapInlinesIn: val.allowedChildren[0],
        invalidPositionHandleMode: val.invalidPositionHandleMode
      };
    } else {
      ret[key] = val;
    }
  });
  return ret;
}

const blockquoteChildren = ['paragraph', 'code', 'heading', 'ordered-list', 'unordered-list', 'divider'];
const paragraphLike = [...blockquoteChildren, 'blockquote'];
const insideOfLayouts = [...paragraphLike, 'component-block'];
const editorSchema = makeEditorSchema({
  editor: {
    kind: 'blocks',
    allowedChildren: [...insideOfLayouts, 'layout'],
    invalidPositionHandleMode: 'move'
  },
  layout: {
    kind: 'blocks',
    allowedChildren: ['layout-area'],
    invalidPositionHandleMode: 'move'
  },
  'layout-area': {
    kind: 'blocks',
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: 'unwrap'
  },
  blockquote: {
    kind: 'blocks',
    allowedChildren: blockquoteChildren,
    invalidPositionHandleMode: 'move'
  },
  paragraph: {
    kind: 'inlines',
    invalidPositionHandleMode: 'unwrap'
  },
  code: {
    kind: 'inlines',
    invalidPositionHandleMode: 'move'
  },
  divider: {
    kind: 'inlines',
    invalidPositionHandleMode: 'move'
  },
  heading: {
    kind: 'inlines',
    invalidPositionHandleMode: 'unwrap'
  },
  'component-block': {
    kind: 'blocks',
    allowedChildren: ['component-block-prop', 'component-inline-prop'],
    invalidPositionHandleMode: 'move'
  },
  'component-inline-prop': {
    kind: 'inlines',
    invalidPositionHandleMode: 'unwrap'
  },
  'component-block-prop': {
    kind: 'blocks',
    allowedChildren: paragraphLike,
    invalidPositionHandleMode: 'unwrap'
  },
  'ordered-list': {
    kind: 'blocks',
    allowedChildren: ['list-item'],
    invalidPositionHandleMode: 'move'
  },
  'unordered-list': {
    kind: 'blocks',
    allowedChildren: ['list-item'],
    invalidPositionHandleMode: 'move'
  },
  'list-item': {
    kind: 'blocks',
    allowedChildren: ['list-item-content', 'ordered-list', 'unordered-list'],
    invalidPositionHandleMode: 'unwrap'
  },
  'list-item-content': {
    kind: 'inlines',
    invalidPositionHandleMode: 'unwrap'
  }
});

function withBlocksSchema(editor) {
  const {
    normalizeNode
  } = editor;

  editor.normalizeNode = ([node, path]) => {
    if (!slate.Text.isText(node) && node.type !== 'link' && node.type !== 'relationship') {
      const nodeType = slate.Editor.isEditor(node) ? 'editor' : node.type;

      if (typeof nodeType !== 'string' || editorSchema[nodeType] === undefined) {
        slate.Transforms.unwrapNodes(editor, {
          at: path
        });
        return;
      }

      const info = editorSchema[nodeType];

      for (const [index, childNode] of node.children.entries()) {
        const childPath = [...path, index];

        if (info.kind === 'inlines') {
          if (!slate.Text.isText(childNode) && !slate.Editor.isInline(editor, childNode)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path);
            return;
          }
        } else {
          if (!slate.Editor.isBlock(editor, childNode) || // these checks are implicit in Editor.isBlock
          // but that isn't encoded in types so these will make TS happy
          childNode.type === 'link' || childNode.type === 'relationship') {
            slate.Transforms.wrapNodes(editor, {
              type: info.blockToWrapInlinesIn,
              children: []
            }, {
              at: childPath
            });
            return;
          }

          if (!info.allowedChildren.has(childNode.type)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path);
            return;
          }
        }
      }
    }

    normalizeNode([node, path]);
  };

  return editor;
}

function handleNodeInInvalidPosition(editor, [node, path], parentPath) {
  const nodeType = node.type;
  const childNodeInfo = editorSchema[nodeType];

  if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === 'unwrap') {
    slate.Transforms.unwrapNodes(editor, {
      at: path
    });
    return;
  } // the parent of a block will never be an inline so this casting is okay


  const parentNode = slate.Node.get(editor, parentPath);
  const info = editorSchema[parentNode.type || 'editor'];

  if ((info === null || info === void 0 ? void 0 : info.kind) === 'blocks' && info.allowedChildren.has(nodeType)) {
    if (parentPath.length === 0) {
      slate.Transforms.moveNodes(editor, {
        at: path,
        to: [path[0] + 1]
      });
    } else {
      slate.Transforms.moveNodes(editor, {
        at: path,
        to: slate.Path.next(parentPath)
      });
    }

    return;
  }

  if (slate.Editor.isEditor(parentNode)) {
    slate.Transforms.moveNodes(editor, {
      at: path,
      to: [path[0] + 1]
    });
    slate.Transforms.unwrapNodes(editor, {
      at: [path[0] + 1]
    });
    return;
  }

  handleNodeInInvalidPosition(editor, [node, path], parentPath.slice(0, -1));
} // to print the editor schema in Graphviz if you want to visualize it
// function printEditorSchema(editorSchema: EditorSchema) {
//   return `digraph G {
//   concentrate=true;
//   ${Object.keys(editorSchema)
//     .map(key => {
//       let val = editorSchema[key];
//       if (val.kind === 'inlines') {
//         return `"${key}" -> inlines`;
//       }
//       if (val.kind === 'blocks') {
//         return `"${key}" -> {${[...val.allowedChildren].map(x => JSON.stringify(x)).join(' ')}}`;
//       }
//     })
//     .join('\n  ')}
// }`;
// }

exports.DocumentEditor = DocumentEditor;
exports.ForceValidationProvider = ForceValidationProvider;
exports.assertNever = assertNever;
exports.clientSideValidateProp = clientSideValidateProp;
exports.createDocumentEditor = createDocumentEditor;


/***/ }),

/***/ "../../node_modules/@keystone-next/fields-document/dist/toolbar-2700d97c.cjs.dev.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/fields-document/dist/toolbar-2700d97c.cjs.dev.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var React = __webpack_require__(/*! react */ "react");

const _excluded$1 = ["isRelative"];
const InlineDialog = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  let {
    isRelative
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$1);

  const {
    radii,
    spacing
  } = core.useTheme();
  const relativeStyles = isRelative ? {
    left: '50%',
    margin: spacing.small,
    transform: 'translateX(-50%)'
  } : {};
  return core.jsx("div", _extends({
    ref: ref,
    contentEditable: false,
    css: _objectSpread({
      background: 'white',
      borderRadius: radii.small,
      boxShadow: `rgba(9, 30, 66, 0.31) 0px 0px 1px, rgba(9, 30, 66, 0.25) 0px 4px 8px -2px`,
      padding: spacing.small,
      position: 'absolute',
      userSelect: 'none',
      zIndex: 1
    }, relativeStyles)
  }, props));
});

const _excluded = ["children", "direction"],
      _excluded2 = ["as", "isDisabled", "isPressed", "isSelected", "variant"];
// ------------------------------

const ToolbarSpacer = () => {
  const {
    spacing
  } = core.useTheme();
  return core.jsx("span", {
    css: {
      display: 'inline-block',
      width: spacing.large
    }
  });
};
const ToolbarSeparator = () => {
  const {
    colors,
    spacing
  } = core.useTheme();
  return core.jsx("span", {
    css: {
      alignSelf: 'stretch',
      background: colors.border,
      display: 'inline-block',
      marginLeft: spacing.xsmall,
      marginRight: spacing.xsmall,
      width: 1
    }
  });
}; // Groups
// ------------------------------

const autoFlowDirection = {
  column: 'row',
  row: 'column'
};
const ToolbarGroupContext = /*#__PURE__*/React.createContext({
  direction: 'row'
});

const useToolbarGroupContext = () => React.useContext(ToolbarGroupContext);

const ToolbarGroup = core.forwardRefWithAs((_ref, ref) => {
  let {
    children,
    direction = 'row'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    spacing
  } = core.useTheme();
  return core.jsx(ToolbarGroupContext.Provider, {
    value: {
      direction
    }
  }, core.jsx(core.Box, _extends({
    ref: ref,
    css: {
      display: 'inline-grid',
      gap: spacing.xxsmall,
      gridAutoFlow: autoFlowDirection[direction]
    }
  }, props), children));
}); // Buttons
// ------------------------------

const ToolbarButton = core.forwardRefWithAs(function ToolbarButton(_ref2, ref) {
  let {
    as: Tag = 'button',
    isDisabled,
    isPressed,
    isSelected,
    variant = 'default'
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2);

  const extraProps = {};
  const {
    direction: groupDirection
  } = useToolbarGroupContext();
  const {
    colors,
    palette,
    radii,
    sizing,
    spacing,
    typography
  } = core.useTheme();

  if (Tag === 'button') {
    extraProps.type = 'button';
  }

  const variants = {
    default: {
      bgHover: palette.neutral200,
      bgActive: palette.neutral300,
      fg: palette.neutral800
    },
    action: {
      bgHover: palette.blue50,
      bgActive: palette.blue100,
      fg: palette.blue600
    },
    destructive: {
      bgHover: palette.red50,
      bgActive: palette.red100,
      fg: palette.red600
    }
  };
  const style = variants[variant];
  return core.jsx(Tag, _extends({}, extraProps, {
    ref: ref,
    disabled: isDisabled,
    "data-pressed": isPressed,
    "data-selected": isSelected,
    "data-display-mode": groupDirection,
    css: {
      alignItems: 'center',
      background: 0,
      border: 0,
      borderRadius: radii.xsmall,
      color: style.fg,
      cursor: 'pointer',
      display: 'flex',
      fontSize: typography.fontSize.small,
      fontWeight: typography.fontWeight.medium,
      height: sizing.medium,
      whiteSpace: 'nowrap',
      ':hover': {
        background: style.bgHover
      },
      ':active': {
        background: style.bgActive
      },
      '&:disabled': {
        color: colors.foregroundDisabled,
        pointerEvents: 'none'
      },
      '&[data-pressed=true]': {
        background: style.bgActive
      },
      '&[data-selected=true]': {
        background: colors.foregroundMuted,
        color: colors.background
      },
      // alternate styles within button group
      '&[data-display-mode=row]': {
        paddingLeft: spacing.small,
        paddingRight: spacing.small
      },
      '&[data-display-mode=column]': {
        paddingLeft: spacing.medium,
        paddingRight: spacing.medium
      }
    }
  }, props));
});
function KeyboardInTooltip({
  children
}) {
  const theme = core.useTheme();
  return core.jsx("kbd", {
    css: {
      margin: 2,
      padding: theme.spacing.xxsmall,
      fontFamily: 'inherit',
      backgroundColor: theme.colors.foreground,
      borderRadius: theme.radii.xsmall,
      color: theme.colors.background,
      whiteSpace: 'pre'
    }
  }, children);
}

exports.InlineDialog = InlineDialog;
exports.KeyboardInTooltip = KeyboardInTooltip;
exports.ToolbarButton = ToolbarButton;
exports.ToolbarGroup = ToolbarGroup;
exports.ToolbarSeparator = ToolbarSeparator;
exports.ToolbarSpacer = ToolbarSpacer;


/***/ }),

/***/ "../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.dev.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.dev.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var slate = __webpack_require__(/*! slate */ "slate");
var weakMemoize = __webpack_require__(/*! @emotion/weak-memoize */ "@emotion/weak-memoize");
var index = __webpack_require__(/*! ../../dist/index-9ba2e5f2.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/dist/index-9ba2e5f2.cjs.dev.js");
var api = __webpack_require__(/*! ../../dist/api-93436025.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/dist/api-93436025.cjs.dev.js");
__webpack_require__(/*! react */ "react");
__webpack_require__(/*! is-hotkey */ "is-hotkey");
__webpack_require__(/*! slate-react */ "slate-react");
__webpack_require__(/*! slate-history */ "slate-history");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/tooltip */ "@keystone-ui/tooltip");
__webpack_require__(/*! @keystone-ui/icons/icons/LinkIcon */ "@keystone-ui/icons/icons/LinkIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/Trash2Icon */ "@keystone-ui/icons/icons/Trash2Icon");
__webpack_require__(/*! @keystone-ui/icons/icons/ExternalLinkIcon */ "@keystone-ui/icons/icons/ExternalLinkIcon");
__webpack_require__(/*! ../../dist/toolbar-2700d97c.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/dist/toolbar-2700d97c.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! @keystone-next/keystone/admin-ui/context */ "@keystone-next/keystone/admin-ui/context");
__webpack_require__(/*! @keystone-next/keystone/fields/types/relationship/views/RelationshipSelect */ "@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/ColumnsIcon */ "@keystone-ui/icons/icons/ColumnsIcon");
__webpack_require__(/*! apply-ref */ "apply-ref");
__webpack_require__(/*! @keystone-ui/icons/icons/BoldIcon */ "@keystone-ui/icons/icons/BoldIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ItalicIcon */ "@keystone-ui/icons/icons/ItalicIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/PlusIcon */ "@keystone-ui/icons/icons/PlusIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronDownIcon */ "@keystone-ui/icons/icons/ChevronDownIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/Maximize2Icon */ "@keystone-ui/icons/icons/Maximize2Icon");
__webpack_require__(/*! @keystone-ui/icons/icons/Minimize2Icon */ "@keystone-ui/icons/icons/Minimize2Icon");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/CodeIcon */ "@keystone-ui/icons/icons/CodeIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/AlignLeftIcon */ "@keystone-ui/icons/icons/AlignLeftIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/AlignRightIcon */ "@keystone-ui/icons/icons/AlignRightIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/AlignCenterIcon */ "@keystone-ui/icons/icons/AlignCenterIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/MinusIcon */ "@keystone-ui/icons/icons/MinusIcon");
__webpack_require__(/*! match-sorter */ "match-sorter");
__webpack_require__(/*! scroll-into-view-if-needed */ "scroll-into-view-if-needed");
__webpack_require__(/*! mdast-util-from-markdown */ "mdast-util-from-markdown");
__webpack_require__(/*! mdast-util-gfm-autolink-literal/from-markdown */ "mdast-util-gfm-autolink-literal/from-markdown");
__webpack_require__(/*! micromark-extension-gfm-autolink-literal */ "micromark-extension-gfm-autolink-literal");
__webpack_require__(/*! mdast-util-gfm-strikethrough/from-markdown */ "mdast-util-gfm-strikethrough/from-markdown");
__webpack_require__(/*! micromark-extension-gfm-strikethrough */ "micromark-extension-gfm-strikethrough");
__webpack_require__(/*! mdast-util-definitions */ "mdast-util-definitions");
__webpack_require__(/*! @braintree/sanitize-url */ "@braintree/sanitize-url");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var weakMemoize__default = /*#__PURE__*/_interopDefault(weakMemoize);

/** @jsxRuntime classic */
const Field = ({
  field,
  value,
  onChange,
  autoFocus,
  forceValidation
}) => core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), core.jsx(index.ForceValidationProvider, {
  value: !!forceValidation
}, core.jsx(index.DocumentEditor, {
  autoFocus: autoFocus,
  value: value,
  onChange: onChange,
  componentBlocks: field.componentBlocks,
  relationships: field.relationships,
  documentFeatures: field.documentFeatures
})));
const Cell = () => {
  return null;
};
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), core.jsx("pre", null, JSON.stringify(item[field.path], null, 2)));
};
const allowedExportsOnCustomViews = ['componentBlocks'];
const controller = config => {
  const memoizedIsComponentBlockValid = weakMemoize__default["default"](componentBlock => weakMemoize__default["default"](props => index.clientSideValidateProp({
    kind: 'object',
    value: componentBlock.props
  }, props)));
  const componentBlocks = config.customViews.componentBlocks || {};
  const serverSideComponentBlocksSet = new Set(config.fieldMeta.componentBlocksPassedOnServer);
  const componentBlocksOnlyBeingPassedOnTheClient = Object.keys(componentBlocks).filter(x => !serverSideComponentBlocksSet.has(x));

  if (componentBlocksOnlyBeingPassedOnTheClient.length) {
    throw new Error(`(${config.listKey}:${config.path}) The following component blocks are being passed in the custom view but not in the server-side field config: ${JSON.stringify(componentBlocksOnlyBeingPassedOnTheClient)}`);
  }

  const clientSideComponentBlocksSet = new Set(Object.keys(componentBlocks));
  const componentBlocksOnlyBeingPassedOnTheServer = config.fieldMeta.componentBlocksPassedOnServer.filter(x => !clientSideComponentBlocksSet.has(x));

  if (componentBlocksOnlyBeingPassedOnTheServer.length) {
    throw new Error(`(${config.listKey}:${config.path}) The following component blocks are being passed in the server-side field config but not in the custom view: ${JSON.stringify(componentBlocksOnlyBeingPassedOnTheServer)}`);
  }

  const validateNode = weakMemoize__default["default"](node => {
    if (slate.Text.isText(node)) {
      return true;
    }

    if (node.type === 'component-block') {
      const componentBlock = componentBlocks[node.component];

      if (componentBlock) {
        if (!memoizedIsComponentBlockValid(componentBlock)(node.props)) {
          return false;
        }
      }
    }

    if (node.type === 'link' && (typeof node.href !== 'string' || !api.isValidURL(node.href))) {
      return false;
    }

    return node.children.every(node => validateNode(node));
  });
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: `${config.path} {document(hydrateRelationships: true)}`,
    componentBlocks: config.customViews.componentBlocks || {},
    documentFeatures: config.fieldMeta.documentFeatures,
    relationships: config.fieldMeta.relationships,
    defaultValue: [{
      type: 'paragraph',
      children: [{
        text: ''
      }]
    }],
    deserialize: data => {
      var _data$config$path;

      return ((_data$config$path = data[config.path]) === null || _data$config$path === void 0 ? void 0 : _data$config$path.document) || [{
        type: 'paragraph',
        children: [{
          text: ''
        }]
      }];
    },
    serialize: value => ({
      [config.path]: value
    }),

    validate(value) {
      return value.every(node => validateNode(node));
    }

  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.allowedExportsOnCustomViews = allowedExportsOnCustomViews;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-fields-document-views.cjs.dev.js */ "../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.dev.js":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.dev.js ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var CellContainer = __webpack_require__(/*! ../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
var CellLink = __webpack_require__(/*! ../../../../dist/CellLink-dc41c877.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! react */ "react");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! ../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

/** @jsxRuntime classic */
const Field = () => null;
const Cell = ({
  item,
  field,
  linkTo
}) => {
  let value = item[field.path] + '';
  return linkTo ? core.jsx(CellLink.CellLink, linkTo, value) : core.jsx(CellContainer.CellContainer, null, value);
};
Cell.supportsLinkTo = true;
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), item[field.path]);
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    idFieldKind: config.fieldMeta.kind,
    defaultValue: undefined,
    deserialize: () => {},
    serialize: () => ({}),
    filter: {
      Filter(props) {
        return core.jsx(fields.TextInput, {
          onChange: event => {
            props.onChange(event.target.value);
          },
          value: props.value,
          autoFocus: props.autoFocus
        });
      },

      graphql: ({
        type,
        value
      }) => {
        if (type === 'not') {
          return {
            [config.path]: {
              not: {
                equals: value
              }
            }
          };
        }

        const valueWithoutWhitespace = value.replace(/\s/g, '');
        const key = type === 'is' ? 'equals' : type === 'not_in' ? 'notIn' : type;
        return {
          [config.path]: {
            [key]: ['in', 'not_in'].includes(type) ? valueWithoutWhitespace.split(',') : valueWithoutWhitespace
          }
        };
      },

      Label({
        label,
        value,
        type
      }) {
        let renderedValue = value.replace(/\s/g, '');

        if (['in', 'not_in'].includes(type)) {
          renderedValue = value.split(',').join(', ');
        }

        return `${label.toLowerCase()}: ${renderedValue}`;
      },

      types: {
        is: {
          label: 'Is exactly',
          initialValue: ''
        },
        not: {
          label: 'Is not exactly',
          initialValue: ''
        },
        gt: {
          label: 'Is greater than',
          initialValue: ''
        },
        lt: {
          label: 'Is less than',
          initialValue: ''
        },
        gte: {
          label: 'Is greater than or equal to',
          initialValue: ''
        },
        lte: {
          label: 'Is less than or equal to',
          initialValue: ''
        },
        in: {
          label: 'Is one of',
          initialValue: ''
        },
        not_in: {
          label: 'Is not one of',
          initialValue: ''
        }
      }
    }
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.js":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.js ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var React = __webpack_require__(/*! react */ "react");
var core$1 = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var toast = __webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
var loading = __webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
var modals = __webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
var apolloUploadClient = __webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var hashString = __webpack_require__(/*! @emotion/hash */ "@emotion/hash");
var core = __webpack_require__(/*! ../../../dist/core-c8ecce23.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/core-c8ecce23.cjs.dev.js");
__webpack_require__(/*! ../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");
var adminMetaGraphql = __webpack_require__(/*! ../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
var dataGetter = __webpack_require__(/*! ../../../dist/dataGetter-9fbe2f8e.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/dataGetter-9fbe2f8e.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var hashString__default = /*#__PURE__*/_interopDefault(hashString);

const expectedExports = new Set(['Cell', 'Field', 'controller', 'CardValue']);
const adminMetaLocalStorageKey = 'keystone.adminMeta';
let _mustRenderServerResult = true;

function useMustRenderServerResult() {
  let [, forceUpdate] = React.useState(0);
  React.useEffect(() => {
    _mustRenderServerResult = false;
    forceUpdate(1);
  }, []);

  if (typeof window === 'undefined') {
    return true;
  }

  return _mustRenderServerResult;
}

function useAdminMeta(adminMetaHash, fieldViews) {
  const adminMetaFromLocalStorage = React.useMemo(() => {
    if (typeof window === 'undefined') {
      return;
    }

    const item = localStorage.getItem(adminMetaLocalStorageKey);

    if (item === null) {
      return;
    }

    try {
      let parsed = JSON.parse(item);

      if (parsed.hash === adminMetaHash) {
        return parsed.meta;
      }
    } catch (err) {
      return;
    }
  }, [adminMetaHash]); // it seems like Apollo doesn't skip the first fetch when using skip: true so we're using useLazyQuery instead

  const [fetchStaticAdminMeta, {
    data,
    error,
    called
  }] = client.useLazyQuery(adminMetaGraphql.staticAdminMetaQuery, {
    fetchPolicy: 'network-only'
  });
  let shouldFetchAdminMeta = adminMetaFromLocalStorage === undefined && !called;
  React.useEffect(() => {
    if (shouldFetchAdminMeta) {
      fetchStaticAdminMeta();
    }
  }, [shouldFetchAdminMeta, fetchStaticAdminMeta]);
  const runtimeAdminMeta = React.useMemo(() => {
    if ((!data || error) && !adminMetaFromLocalStorage) {
      return undefined;
    }

    const adminMeta = adminMetaFromLocalStorage ? adminMetaFromLocalStorage : data.keystone.adminMeta;
    const runtimeAdminMeta = {
      enableSessionItem: adminMeta.enableSessionItem,
      enableSignout: adminMeta.enableSignout,
      lists: {}
    };
    adminMeta.lists.forEach(list => {
      runtimeAdminMeta.lists[list.key] = _objectSpread(_objectSpread({}, list), {}, {
        gqlNames: core.getGqlNames({
          listKey: list.key,
          pluralGraphQLName: list.listQueryName
        }),
        fields: {}
      });
      list.fields.forEach(field => {
        var _field$itemView$field, _field$itemView;

        expectedExports.forEach(exportName => {
          if (fieldViews[field.viewsIndex][exportName] === undefined) {
            throw new Error(`The view for the field at ${list.key}.${field.path} is missing the ${exportName} export`);
          }
        });
        Object.keys(fieldViews[field.viewsIndex]).forEach(exportName => {
          if (!expectedExports.has(exportName) && exportName !== 'allowedExportsOnCustomViews') {
            throw new Error(`Unexpected export named ${exportName} from the view from the field at ${list.key}.${field.path}`);
          }
        });

        const views = _objectSpread({}, fieldViews[field.viewsIndex]);

        const customViews = {};

        if (field.customViewsIndex !== null) {
          const customViewsSource = fieldViews[field.customViewsIndex];
          const allowedExportsOnCustomViews = new Set(views.allowedExportsOnCustomViews);
          Object.keys(customViewsSource).forEach(exportName => {
            if (allowedExportsOnCustomViews.has(exportName)) {
              customViews[exportName] = customViewsSource[exportName];
            } else if (expectedExports.has(exportName)) {
              views[exportName] = customViewsSource[exportName];
            } else {
              throw new Error(`Unexpected export named ${exportName} from the custom view from field at ${list.key}.${field.path}`);
            }
          });
        }

        runtimeAdminMeta.lists[list.key].fields[field.path] = _objectSpread(_objectSpread({}, field), {}, {
          itemView: {
            fieldMode: (_field$itemView$field = (_field$itemView = field.itemView) === null || _field$itemView === void 0 ? void 0 : _field$itemView.fieldMode) !== null && _field$itemView$field !== void 0 ? _field$itemView$field : null
          },
          views,
          controller: fieldViews[field.viewsIndex].controller({
            listKey: list.key,
            fieldMeta: field.fieldMeta,
            label: field.label,
            path: field.path,
            customViews
          })
        });
      });
    });

    if (typeof window !== 'undefined' && !adminMetaFromLocalStorage) {
      localStorage.setItem(adminMetaLocalStorageKey, JSON.stringify({
        hash: hashString__default["default"](JSON.stringify(adminMeta)),
        meta: adminMeta
      }));
    }

    return runtimeAdminMeta;
  }, [data, error, adminMetaFromLocalStorage, fieldViews]);
  const mustRenderServerResult = useMustRenderServerResult();

  if (mustRenderServerResult) {
    return {
      state: 'loading'
    };
  }

  if (runtimeAdminMeta) {
    return {
      state: 'loaded',
      value: runtimeAdminMeta
    };
  }

  if (error) {
    return {
      state: 'error',
      error,
      refetch: () => {
        fetchStaticAdminMeta();
      }
    };
  }

  return {
    state: 'loading'
  };
}

function useLazyMetadata(query) {
  let result = client.useQuery(query, {
    errorPolicy: 'all',
    fetchPolicy: 'network-only'
  });
  return React.useMemo(() => {
    var _result$error, _result$error$network, _result$error2, _result$error$network2, _result$error3, _result$error$network3, _result$error4;

    let refetch = () => {
      result.refetch();
    };

    let dataGetter$1 = dataGetter.makeDataGetter(result.data, (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.graphQLErrors);
    const authenticatedItemGetter = dataGetter$1.get('authenticatedItem');
    const keystoneMetaGetter = dataGetter$1.get('keystone');
    return {
      refetch,
      authenticatedItem: getAuthenticatedItem(result, authenticatedItemGetter.errors || ((_result$error$network = (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.networkError) !== null && _result$error$network !== void 0 ? _result$error$network : undefined)),
      visibleLists: getVisibleLists(result, keystoneMetaGetter.errors || ((_result$error$network2 = (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.networkError) !== null && _result$error$network2 !== void 0 ? _result$error$network2 : undefined)),
      createViewFieldModes: getCreateViewFieldModes(result, keystoneMetaGetter.errors || ((_result$error$network3 = (_result$error4 = result.error) === null || _result$error4 === void 0 ? void 0 : _result$error4.networkError) !== null && _result$error$network3 !== void 0 ? _result$error$network3 : undefined))
    };
  }, [result]);
}

function getCreateViewFieldModes({
  data
}, error) {
  if (error) {
    return {
      state: 'error',
      error
    };
  }

  if (data) {
    const lists = {};
    data.keystone.adminMeta.lists.forEach(list => {
      lists[list.key] = {};
      list.fields.forEach(field => {
        lists[list.key][field.path] = field.createView.fieldMode;
      });
    });
    return {
      state: 'loaded',
      lists
    };
  }

  return {
    state: 'loading'
  };
}

function getVisibleLists({
  data
}, error) {
  if (error) {
    return {
      state: 'error',
      error
    };
  }

  if (data) {
    const lists = new Set();
    data.keystone.adminMeta.lists.forEach(list => {
      if (!list.isHidden) {
        lists.add(list.key);
      }
    });
    return {
      state: 'loaded',
      lists
    };
  }

  return {
    state: 'loading'
  };
}

function getAuthenticatedItem({
  data
}, error) {
  if (error) {
    return {
      state: 'error',
      error
    };
  }

  if (data) {
    if (!data.authenticatedItem || // this is for the case where there is a new type
    // in the AuthenticatedItem union and the query
    // that the admin ui has doesn't get the id
    // (yes, undefined is very specific and very intentional, it should not be checking for null)
    data.authenticatedItem.id === undefined) {
      return {
        state: 'unauthenticated'
      };
    }

    const labelField = Object.keys(data.authenticatedItem).filter(x => x !== '__typename' && x !== 'id')[0];
    return {
      state: 'authenticated',
      id: data.authenticatedItem.id,
      label: data.authenticatedItem[labelField] || data.authenticatedItem.id,
      listKey: data.authenticatedItem.__typename
    };
  }

  return {
    state: 'loading'
  };
}

const KeystoneContext = /*#__PURE__*/React.createContext(undefined);

function InternalKeystoneProvider({
  adminConfig,
  fieldViews,
  adminMetaHash,
  children,
  lazyMetadataQuery,
  apiPath
}) {
  const adminMeta = useAdminMeta(adminMetaHash, fieldViews);
  const {
    authenticatedItem,
    visibleLists,
    createViewFieldModes,
    refetch
  } = useLazyMetadata(lazyMetadataQuery);

  const reinitContext = () => {
    var _adminMeta$refetch;

    adminMeta === null || adminMeta === void 0 ? void 0 : (_adminMeta$refetch = adminMeta.refetch) === null || _adminMeta$refetch === void 0 ? void 0 : _adminMeta$refetch.call(adminMeta);
    refetch();
  };

  if (adminMeta.state === 'loading') {
    return /*#__PURE__*/React__default["default"].createElement(core$1.Center, {
      fillView: true
    }, /*#__PURE__*/React__default["default"].createElement(loading.LoadingDots, {
      label: "Loading Admin Metadata",
      size: "large"
    }));
  }

  return /*#__PURE__*/React__default["default"].createElement(toast.ToastProvider, null, /*#__PURE__*/React__default["default"].createElement(modals.DrawerProvider, null, /*#__PURE__*/React__default["default"].createElement(KeystoneContext.Provider, {
    value: {
      adminConfig,
      adminMeta,
      fieldViews,
      authenticatedItem,
      reinitContext,
      visibleLists,
      createViewFieldModes,
      apiPath
    }
  }, children)));
}

const KeystoneProvider = props => {
  const apolloClient = React.useMemo(() => new client.ApolloClient({
    cache: new client.InMemoryCache(),
    link: apolloUploadClient.createUploadLink({
      uri: props.apiPath
    })
  }), [props.apiPath]);
  return /*#__PURE__*/React__default["default"].createElement(client.ApolloProvider, {
    client: apolloClient
  }, /*#__PURE__*/React__default["default"].createElement(InternalKeystoneProvider, props));
};
const useKeystone = () => {
  const value = React.useContext(KeystoneContext);

  if (!value) {
    throw new Error('useKeystone must be called inside a KeystoneProvider component');
  }

  if (value.adminMeta.state === 'error') {
    // If we get an "Access denied" error, it probably means the user doesn't have access to the
    // adminMeta but has navigated (probably client-side) to a page that requires it. We reload
    // the page so the server-side access control can run which should bounce them to the right
    // place (or display the no-access page)
    if (value.adminMeta.error.message === 'Access denied') {
      window.location.reload();
    }

    throw new Error('An error occurred when loading Admin Metadata');
  }

  return {
    adminConfig: value.adminConfig,
    adminMeta: value.adminMeta.value,
    authenticatedItem: value.authenticatedItem,
    visibleLists: value.visibleLists,
    createViewFieldModes: value.createViewFieldModes,
    apiPath: value.apiPath
  };
};
const useReinitContext = () => {
  const value = React.useContext(KeystoneContext);

  if (!value) {
    throw new Error('useReinitContext must be called inside a KeystoneProvider component');
  }

  return value.reinitContext;
};
const useRawKeystone = () => {
  const value = React.useContext(KeystoneContext);

  if (!value) {
    throw new Error('useRawKeystone must be called inside a KeystoneProvider component');
  }

  return value;
};
const useList = key => {
  const {
    adminMeta: {
      lists
    }
  } = useKeystone();

  if (lists[key]) {
    return lists[key];
  } else {
    throw new Error(`Invalid list key provided to useList: ${key}`);
  }
};

exports.KeystoneProvider = KeystoneProvider;
exports.useKeystone = useKeystone;
exports.useList = useList;
exports.useRawKeystone = useRawKeystone;
exports.useReinitContext = useReinitContext;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var router = __webpack_require__(/*! next/router */ "next/router");
var Link$1 = __webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
var React = __webpack_require__(/*! react */ "react");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Link__default = /*#__PURE__*/_interopDefault(Link$1);
var React__default = /*#__PURE__*/_interopDefault(React);

const _excluded = ["href", "as", "replace", "scroll", "shallow", "prefetch"];
const Link = _ref => {
  let {
    href,
    as,
    replace,
    scroll,
    shallow,
    prefetch
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  return /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
    href: href,
    as: as,
    replace: replace,
    scroll: scroll,
    shallow: shallow,
    prefetch: prefetch
  }, /*#__PURE__*/React__default["default"].createElement("a", props));
};

Object.defineProperty(exports, "Router", ({
  enumerable: true,
  get: function () { return router.Router; }
}));
Object.defineProperty(exports, "createRouter", ({
  enumerable: true,
  get: function () { return router.createRouter; }
}));
Object.defineProperty(exports, "makePublicRouterInstance", ({
  enumerable: true,
  get: function () { return router.makePublicRouterInstance; }
}));
Object.defineProperty(exports, "useRouter", ({
  enumerable: true,
  get: function () { return router.useRouter; }
}));
Object.defineProperty(exports, "withRouter", ({
  enumerable: true,
  get: function () { return router.withRouter; }
}));
exports.Link = Link;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");

const _excluded = ["children"];
/**
 * This is the component you should use when you want the standard padding around a cell value
 */

const CellContainer = _ref => {
  let {
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    spacing
  } = core.useTheme();
  return core.jsx("div", _extends({
    css: {
      padding: spacing.small
    }
  }, props), children);
};

exports.CellContainer = CellContainer;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var adminUi_router_dist_keystoneNextKeystoneAdminUiRouter = __webpack_require__(/*! ../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");

/**
 * This is the component you should use when linking a Cell to an item (i.e when the Cell supports
 * the linkTo prop)
 */

const CellLink = props => {
  const {
    colors,
    spacing
  } = core.useTheme();
  return core.jsx(adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link, _extends({
    css: {
      color: colors.foreground,
      display: 'block',
      padding: spacing.small,
      textDecoration: 'none',
      ':hover': {
        textDecoration: 'underline'
      }
    }
  }, props));
};

exports.CellLink = CellLink;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/CreateItemDrawer-fa4e2213.cjs.dev.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/CreateItemDrawer-fa4e2213.cjs.dev.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "react");
var isDeepEqual = __webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var modals = __webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
var toast = __webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
var loading = __webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");
var adminUi_context_dist_keystoneNextKeystoneAdminUiContext = __webpack_require__(/*! ../admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js");
var Fields = __webpack_require__(/*! ./Fields-4afb38f0.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/Fields-4afb38f0.cjs.dev.js");
var GraphQLErrorNotice = __webpack_require__(/*! ./GraphQLErrorNotice-76ff96dd.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/GraphQLErrorNotice-76ff96dd.cjs.dev.js");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var isDeepEqual__default = /*#__PURE__*/_interopDefault(isDeepEqual);

/** @jsxRuntime classic */
function CreateItemDrawer({
  listKey,
  onClose,
  onCreate
}) {
  const {
    createViewFieldModes
  } = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useKeystone();
  const list = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(listKey);
  const toasts = toast.useToasts();
  const [createItem, {
    loading: loading$1,
    error
  }] = client.useMutation(client.gql`mutation($data: ${list.gqlNames.createInputName}!) {
      item: ${list.gqlNames.createMutationName}(data: $data) {
        id
        label: ${list.labelField}
    }
  }`);
  const [value, setValue] = React.useState(() => {
    const value = {};
    Object.keys(list.fields).forEach(fieldPath => {
      value[fieldPath] = {
        kind: 'value',
        value: list.fields[fieldPath].controller.defaultValue
      };
    });
    return value;
  });
  const invalidFields = React.useMemo(() => {
    const invalidFields = new Set();
    Object.keys(value).forEach(fieldPath => {
      const val = value[fieldPath].value;
      const validateFn = list.fields[fieldPath].controller.validate;

      if (validateFn) {
        const result = validateFn(val);

        if (result === false) {
          invalidFields.add(fieldPath);
        }
      }
    });
    return invalidFields;
  }, [list, value]);
  const [forceValidation, setForceValidation] = React.useState(false);
  return core.jsx(modals.Drawer, {
    title: `Create ${list.singular}`,
    width: "wide",
    actions: {
      confirm: {
        label: `Create ${list.singular}`,
        loading: loading$1,
        action: () => {
          const newForceValidation = invalidFields.size !== 0;
          setForceValidation(newForceValidation);
          if (newForceValidation) return;
          const data = {};
          Object.keys(list.fields).forEach(fieldPath => {
            const {
              controller
            } = list.fields[fieldPath];
            const serialized = controller.serialize(value[fieldPath].value);

            if (!isDeepEqual__default["default"](serialized, controller.serialize(controller.defaultValue))) {
              Object.assign(data, serialized);
            }
          });
          createItem({
            variables: {
              data
            }
          }).then(({
            data
          }) => {
            const label = data.item.label || data.item.id;
            onCreate({
              id: data.item.id,
              label
            });
            toasts.addToast({
              title: label,
              message: 'Created Successfully',
              tone: 'positive'
            });
          }).catch(() => {});
        }
      },
      cancel: {
        label: 'Cancel',
        action: onClose
      }
    }
  }, createViewFieldModes.state === 'error' && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: createViewFieldModes.error instanceof Error ? createViewFieldModes.error : undefined,
    errors: createViewFieldModes.error instanceof Error ? undefined : createViewFieldModes.error
  }), createViewFieldModes.state === 'loading' && core.jsx(loading.LoadingDots, {
    label: "Loading create form"
  }), error && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: error === null || error === void 0 ? void 0 : error.networkError,
    errors: error === null || error === void 0 ? void 0 : error.graphQLErrors
  }), core.jsx(core.Box, {
    paddingY: "xlarge"
  }, core.jsx(Fields.Fields, {
    fields: list.fields,
    fieldModes: createViewFieldModes.state === 'loaded' ? createViewFieldModes.lists[list.key] : null,
    forceValidation: forceValidation,
    invalidFields: invalidFields,
    value: value,
    onChange: React.useCallback(getNewValue => {
      setValue(oldValues => getNewValue(oldValues));
    }, [])
  })));
}

exports.CreateItemDrawer = CreateItemDrawer;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/Fields-4afb38f0.cjs.dev.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/Fields-4afb38f0.cjs.dev.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var React = __webpack_require__(/*! react */ "react");

const RenderField = /*#__PURE__*/React.memo(function RenderField({
  field,
  value,
  autoFocus,
  forceValidation,
  onChange
}) {
  return core.jsx(field.views.Field, {
    field: field.controller,
    onChange: React.useMemo(() => {
      if (onChange === undefined) return undefined;
      return value => {
        onChange(val => _objectSpread(_objectSpread({}, val), {}, {
          [field.controller.path]: {
            kind: 'value',
            value
          }
        }));
      };
    }, [onChange, field.controller.path]),
    value: value,
    autoFocus: autoFocus,
    forceValidation: forceValidation
  });
});
function Fields({
  fields,
  value,
  fieldModes,
  forceValidation,
  invalidFields,
  onChange
}) {
  const renderedFields = Object.keys(fields).filter(fieldPath => fieldModes === null || fieldModes[fieldPath] !== 'hidden').map((fieldPath, index) => {
    const field = fields[fieldPath];
    const val = value[fieldPath];
    const fieldMode = fieldModes === null ? 'edit' : fieldModes[fieldPath];

    if (val.kind === 'error') {
      return core.jsx("div", null, field.label, ": ", core.jsx("span", {
        css: {
          color: 'red'
        }
      }, val.errors[0].message));
    }

    return core.jsx(RenderField, {
      key: fieldPath,
      field: field,
      value: val.value,
      forceValidation: forceValidation && invalidFields.has(fieldPath),
      onChange: fieldMode === 'edit' ? onChange : undefined,
      autoFocus: index === 0
    });
  });
  return core.jsx(core.Stack, {
    gap: "xlarge"
  }, renderedFields, renderedFields.length === 0 && 'There are no fields that you can read or edit');
}

exports.Fields = Fields;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/GraphQLErrorNotice-76ff96dd.cjs.dev.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/GraphQLErrorNotice-76ff96dd.cjs.dev.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var notice = __webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
var React = __webpack_require__(/*! react */ "react");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

function GraphQLErrorNotice({
  errors,
  networkError
}) {
  if (networkError) {
    return /*#__PURE__*/React__default["default"].createElement(notice.Notice, {
      tone: "negative",
      marginBottom: "large"
    }, networkError.message);
  }

  if (errors !== null && errors !== void 0 && errors.length) {
    return /*#__PURE__*/React__default["default"].createElement(core.Stack, {
      gap: "small",
      marginBottom: "large"
    }, errors.map(err => /*#__PURE__*/React__default["default"].createElement(notice.Notice, {
      tone: "negative"
    }, err.message)));
  }

  return null;
}

exports.GraphQLErrorNotice = GraphQLErrorNotice;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var React = __webpack_require__(/*! react */ "react");
var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");

/** @jsxRuntime classic */
const END_SESSION = client.gql`
  mutation EndSession {
    endSession
  }
`;

const SignoutButton = ({
  children
}) => {
  const [endSession, {
    loading,
    data
  }] = client.useMutation(END_SESSION);
  React.useEffect(() => {
    if (data !== null && data !== void 0 && data.endSession) {
      window.location.reload();
    }
  }, [data]);
  return core.jsx(button.Button, {
    size: "small",
    isLoading: loading,
    onClick: () => endSession()
  }, children || 'Sign out');
};

exports.SignoutButton = SignoutButton;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");

const staticAdminMetaQuery = client.gql`
  query StaticAdminMeta {
    keystone {
      __typename
      adminMeta {
        __typename
        enableSignout
        enableSessionItem
        lists {
          __typename
          key
          itemQueryName
          listQueryName
          initialSort {
            __typename
            field
            direction
          }
          path
          label
          singular
          plural
          description
          initialColumns
          pageSize
          labelField
          fields {
            __typename
            path
            label
            fieldMeta
            viewsIndex
            customViewsIndex
            search
            itemView {
              fieldMode
            }
          }
        }
      }
    }
  }
`; // generated by https://graphql-code-generator.com with these options:
// generates:
//   types.ts:
//     plugins:
//       - typescript-operations:
//           namingConvention: keep
//       - typescript:
//           enumsAsTypes: true
//           nonOptionalTypename: true
//           namingConvention: keep
//           noExport: true
//           avoidOptionals: true
//           scalars:
//             JSON: JSONValue

exports.staticAdminMetaQuery = staticAdminMetaQuery;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/core-c8ecce23.cjs.dev.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/core-c8ecce23.cjs.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// TODO: don't duplicate this between here and packages/keystone/ListTypes/list.js
function getGqlNames({
  listKey,
  pluralGraphQLName
}) {
  const lowerPluralName = pluralGraphQLName.slice(0, 1).toLowerCase() + pluralGraphQLName.slice(1);
  const lowerSingularName = listKey.slice(0, 1).toLowerCase() + listKey.slice(1);
  return {
    outputTypeName: listKey,
    itemQueryName: lowerSingularName,
    listQueryName: lowerPluralName,
    listQueryCountName: `${lowerPluralName}Count`,
    listOrderName: `${listKey}OrderByInput`,
    deleteMutationName: `delete${listKey}`,
    updateMutationName: `update${listKey}`,
    createMutationName: `create${listKey}`,
    deleteManyMutationName: `delete${pluralGraphQLName}`,
    updateManyMutationName: `update${pluralGraphQLName}`,
    createManyMutationName: `create${pluralGraphQLName}`,
    whereInputName: `${listKey}WhereInput`,
    whereUniqueInputName: `${listKey}WhereUniqueInput`,
    updateInputName: `${listKey}UpdateInput`,
    createInputName: `${listKey}CreateInput`,
    updateManyInputName: `${listKey}UpdateArgs`,
    relateToManyForCreateInputName: `${listKey}RelateToManyForCreateInput`,
    relateToManyForUpdateInputName: `${listKey}RelateToManyForUpdateInput`,
    relateToOneForCreateInputName: `${listKey}RelateToOneForCreateInput`,
    relateToOneForUpdateInputName: `${listKey}RelateToOneForUpdateInput`
  };
}

exports.getGqlNames = getGqlNames;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/dataGetter-9fbe2f8e.cjs.dev.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/dataGetter-9fbe2f8e.cjs.dev.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function dataGetterWithNoErrors(data, path) {
  return {
    data,
    path,

    get(field) {
      var _data$field;

      return dataGetterWithNoErrors((_data$field = data === null || data === void 0 ? void 0 : data[field]) !== null && _data$field !== void 0 ? _data$field : null, path.concat(field));
    }

  };
}

function dataGetterWithErrors(data, errors, path) {
  return {
    data,
    errors,
    path,

    get(field) {
      var _data$field2;

      const newPath = path.concat(field);
      const newItem = (_data$field2 = data === null || data === void 0 ? void 0 : data[field]) !== null && _data$field2 !== void 0 ? _data$field2 : null;
      let errorsForField = errors.filter(error => {
        if (error.path === undefined) {
          return true;
        }

        const errorPath = error.path;
        return newPath.every((value, index) => errorPath[index] === undefined || errorPath[index] === value);
      });

      if (errorsForField.length) {
        return dataGetterWithErrors(newItem, errors, newPath);
      }

      return dataGetterWithNoErrors(newItem, newPath);
    }

  };
}

function makeDataGetter(data, errors) {
  if (errors !== null && errors !== void 0 && errors.length) {
    return dataGetterWithErrors(data, errors, []);
  }

  return dataGetterWithNoErrors(data, []);
}

exports.makeDataGetter = makeDataGetter;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var weakMemoize = __webpack_require__(/*! @emotion/weak-memoize */ "@emotion/weak-memoize");
var graphql = __webpack_require__(/*! graphql */ "graphql");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var weakMemoize__default = /*#__PURE__*/_interopDefault(weakMemoize);

function extractRootFields(selectedFields, selectionSet) {
  selectionSet.selections.forEach(selection => {
    if (selection.kind === 'Field') {
      selectedFields.add(selection.alias ? selection.alias.value : selection.name.value);
    }

    if (selection.kind === 'InlineFragment') {
      extractRootFields(selectedFields, selection.selectionSet);
    } // FragmentSpread will never happen for the use cases of getRootFieldsFromSelection

  });
}

const getRootGraphQLFieldsFromFieldController = weakMemoize__default["default"](controller => {
  const ast = graphql.parse(`fragment X on Y {
  id
  ${controller.graphqlSelection}
  }`);
  const selectedFields = new Set();
  const fragmentNode = ast.definitions[0];
  extractRootFields(selectedFields, fragmentNode.selectionSet);
  return [...selectedFields];
});

exports.getRootGraphQLFieldsFromFieldController = getRootGraphQLFieldsFromFieldController;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var graphqlTsSchema = __webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
var graphqlTypeJson = __webpack_require__(/*! graphql-type-json */ "graphql-type-json");
var GraphQLUpload = __webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
var graphql = __webpack_require__(/*! graphql */ "graphql");
var Decimal$1 = __webpack_require__(/*! decimal.js */ "decimal.js");
var apiWithoutContext = __webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
var apiWithContext = __webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var graphqlTsSchema__namespace = /*#__PURE__*/_interopNamespace(graphqlTsSchema);
var GraphQLUpload__default = /*#__PURE__*/_interopDefault(GraphQLUpload);

const JSON = graphqlTsSchema__namespace.graphql.scalar(graphqlTypeJson.GraphQLJSON);
const Upload = graphqlTsSchema__namespace.graphql.scalar(GraphQLUpload__default["default"]); // - Decimal.js throws on invalid inputs
// - Decimal.js can represent +Infinity and -Infinity, these aren't values in Postgres' decimal,
//   NaN is but Prisma doesn't support it
//   .isFinite refers to +Infinity, -Infinity and NaN

const Decimal = graphqlTsSchema__namespace.graphql.scalar(new graphql.GraphQLScalarType({
  name: 'Decimal',

  serialize(value) {
    if (!Decimal$1.Decimal.isDecimal(value)) {
      throw new graphql.GraphQLError(`unexpected value provided to Decimal scalar: ${value}`);
    }

    if (value.scaleToPrint !== undefined) {
      return value.toFixed(value.scaleToPrint);
    }

    return value.toString();
  },

  parseLiteral(value) {
    if (value.kind !== 'StringValue') {
      throw new graphql.GraphQLError('Decimal only accepts values as strings');
    }

    let decimal = new Decimal$1.Decimal(value.value);

    if (!decimal.isFinite()) {
      throw new graphql.GraphQLError('Decimal values must be finite');
    }

    return decimal;
  },

  parseValue(value) {
    if (Decimal$1.Decimal.isDecimal(value)) {
      if (!value.isFinite()) {
        throw new graphql.GraphQLError('Decimal values must be finite');
      }

      return value;
    }

    if (typeof value !== 'string') {
      throw new graphql.GraphQLError('Decimal only accepts values as strings');
    }

    let decimal = new Decimal$1.Decimal(value);

    if (!decimal.isFinite()) {
      throw new graphql.GraphQLError('Decimal values must be finite');
    }

    return decimal;
  }

})); // from https://github.com/excitement-engineer/graphql-iso-date/blob/master/src/utils/validator.js#L121
// this is also what prisma uses https://github.com/prisma/prisma/blob/20b58fe65d581bcb43c0d5c28d4b89cabc2d99b2/packages/client/src/runtime/utils/common.ts#L126-L128

const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;

function parseDate(input) {
  if (!RFC_3339_REGEX.test(input)) {
    throw new graphql.GraphQLError('DateTime scalars must be in the form of a full ISO 8601 date-time stirng');
  }

  const parsed = new Date(input);

  if (isNaN(parsed.valueOf())) {
    throw new graphql.GraphQLError('DateTime scalars must be in the form of a full ISO 8601 date-time stirng');
  }

  return parsed;
}

const DateTime = graphqlTsSchema__namespace.graphql.scalar(new graphql.GraphQLScalarType({
  name: 'DateTime',
  specifiedByUrl: 'https://datatracker.ietf.org/doc/html/rfc3339#section-5.6',

  serialize(value) {
    if (!(value instanceof Date) || isNaN(value.valueOf())) {
      throw new graphql.GraphQLError(`unexpected value provided to DateTime scalar: ${value}`);
    }

    return value.toISOString();
  },

  parseLiteral(value) {
    if (value.kind !== 'StringValue') {
      throw new graphql.GraphQLError('DateTime only accepts values as strings');
    }

    return parseDate(value.value);
  },

  parseValue(value) {
    if (value instanceof Date) {
      return value;
    }

    if (typeof value !== 'string') {
      throw new graphql.GraphQLError('DateTime only accepts values as strings');
    }

    return parseDate(value);
  }

}));

var graphqlBoundToKeystoneContext = /*#__PURE__*/Object.freeze({
  __proto__: null,
  JSON: JSON,
  Upload: Upload,
  Decimal: Decimal,
  DateTime: DateTime,
  Boolean: apiWithoutContext.Boolean,
  Float: apiWithoutContext.Float,
  ID: apiWithoutContext.ID,
  Int: apiWithoutContext.Int,
  String: apiWithoutContext.String,
  'enum': apiWithoutContext["enum"],
  enumValues: apiWithoutContext.enumValues,
  arg: apiWithoutContext.arg,
  inputObject: apiWithoutContext.inputObject,
  list: apiWithoutContext.list,
  nonNull: apiWithoutContext.nonNull,
  scalar: apiWithoutContext.scalar,
  bindGraphQLSchemaAPIToContext: graphqlTsSchema.bindGraphQLSchemaAPIToContext,
  field: apiWithContext.field,
  fields: apiWithContext.fields,
  'interface': apiWithContext["interface"],
  interfaceField: apiWithContext.interfaceField,
  object: apiWithContext.object,
  union: apiWithContext.union
});

exports.DateTime = DateTime;
exports.Decimal = Decimal;
exports.JSON = JSON;
exports.Upload = Upload;
exports.graphqlBoundToKeystoneContext = graphqlBoundToKeystoneContext;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var graphqlTsSchema = __webpack_require__(/*! ./graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
var apiWithoutContext = __webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");

const orderDirectionEnum = apiWithoutContext["enum"]({
  name: 'OrderDirection',
  values: apiWithoutContext.enumValues(['asc', 'desc'])
});
const QueryMode = apiWithoutContext["enum"]({
  name: 'QueryMode',
  values: apiWithoutContext.enumValues(['default', 'insensitive'])
});
// fieldType(dbField)(fieldInfo) => { ...fieldInfo, dbField };
function fieldType(dbField) {
  return function (graphQLInfo) {
    return _objectSpread(_objectSpread({}, graphQLInfo), {}, {
      dbField
    });
  };
}

// (even though, yes, having EnumFilter by defined as EnumNullableFilter<Enum>, would be the same type but names would show up differently in editors for example)

function enumFilters(enumType) {
  const optional = apiWithoutContext.inputObject({
    name: `${enumType.graphQLType.name}NullableFilter`,
    fields: () => ({
      equals: apiWithoutContext.arg({
        type: enumType
      }),
      in: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      notIn: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      not: apiWithoutContext.arg({
        type: optional
      })
    })
  });
  const required = apiWithoutContext.inputObject({
    name: `${enumType.graphQLType.name}Filter`,
    fields: () => ({
      equals: apiWithoutContext.arg({
        type: enumType
      }),
      in: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      notIn: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      not: apiWithoutContext.arg({
        type: optional
      })
    })
  });
  const many = apiWithoutContext.inputObject({
    name: `${enumType.graphQLType.name}NullableListFilter`,
    fields: () => ({
      // can be null
      equals: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      // can be null
      has: apiWithoutContext.arg({
        type: enumType
      }),
      hasEvery: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      hasSome: apiWithoutContext.arg({
        type: apiWithoutContext.list(apiWithoutContext.nonNull(enumType))
      }),
      isEmpty: apiWithoutContext.arg({
        type: enumType
      })
    })
  });
  return {
    optional,
    required,
    many
  };
}

// Do not manually modify this file, it is automatically generated by the package at /prisma-utils in this repo.
const StringNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'StringNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    mode: apiWithoutContext.arg({
      type: QueryMode
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: NestedStringNullableFilter$1
    })
  })
});
const NestedStringNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'NestedStringNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: NestedStringNullableFilter$1
    })
  })
});
const StringFilter$1 = apiWithoutContext.inputObject({
  name: 'StringFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    mode: apiWithoutContext.arg({
      type: QueryMode
    }),
    not: apiWithoutContext.arg({
      type: NestedStringFilter$1
    })
  })
});
const NestedStringFilter$1 = apiWithoutContext.inputObject({
  name: 'NestedStringFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    not: apiWithoutContext.arg({
      type: NestedStringFilter$1
    })
  })
});
const StringNullableListFilter = apiWithoutContext.inputObject({
  name: 'StringNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const BoolNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'BooleanNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: BoolNullableFilter$1
    })
  })
});
const BoolFilter$1 = apiWithoutContext.inputObject({
  name: 'BooleanFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    }),
    not: apiWithoutContext.arg({
      type: BoolFilter$1
    })
  })
});
const BoolNullableListFilter = apiWithoutContext.inputObject({
  name: 'BooleanNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Boolean))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Boolean))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Boolean))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const IntNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'IntNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: IntNullableFilter$1
    })
  })
});
const IntFilter$1 = apiWithoutContext.inputObject({
  name: 'IntFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    not: apiWithoutContext.arg({
      type: IntFilter$1
    })
  })
});
const IntNullableListFilter = apiWithoutContext.inputObject({
  name: 'IntNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const FloatNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'FloatNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: FloatNullableFilter$1
    })
  })
});
const FloatFilter$1 = apiWithoutContext.inputObject({
  name: 'FloatFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    not: apiWithoutContext.arg({
      type: FloatFilter$1
    })
  })
});
const FloatNullableListFilter = apiWithoutContext.inputObject({
  name: 'FloatNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const DateTimeNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'DateTimeNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: DateTimeNullableFilter$1
    })
  })
});
const DateTimeFilter$1 = apiWithoutContext.inputObject({
  name: 'DateTimeFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    not: apiWithoutContext.arg({
      type: DateTimeFilter$1
    })
  })
});
const DateTimeNullableListFilter = apiWithoutContext.inputObject({
  name: 'DateTimeNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const DecimalNullableFilter$1 = apiWithoutContext.inputObject({
  name: 'DecimalNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: DecimalNullableFilter$1
    })
  })
});
const DecimalFilter$1 = apiWithoutContext.inputObject({
  name: 'DecimalFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    not: apiWithoutContext.arg({
      type: DecimalFilter$1
    })
  })
});
const DecimalNullableListFilter = apiWithoutContext.inputObject({
  name: 'DecimalNullableListFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    // can be null
    has: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    hasEvery: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    hasSome: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    isEmpty: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    })
  })
});
const String$1 = {
  optional: StringNullableFilter$1,
  required: StringFilter$1,
  many: StringNullableListFilter
};
const Boolean$1 = {
  optional: BoolNullableFilter$1,
  required: BoolFilter$1,
  many: BoolNullableListFilter
};
const Int$1 = {
  optional: IntNullableFilter$1,
  required: IntFilter$1,
  many: IntNullableListFilter
};
const Float$1 = {
  optional: FloatNullableFilter$1,
  required: FloatFilter$1,
  many: FloatNullableListFilter
};
const DateTime$1 = {
  optional: DateTimeNullableFilter$1,
  required: DateTimeFilter$1,
  many: DateTimeNullableListFilter
};
const Decimal$1 = {
  optional: DecimalNullableFilter$1,
  required: DecimalFilter$1,
  many: DecimalNullableListFilter
};

var postgresql = /*#__PURE__*/Object.freeze({
  __proto__: null,
  String: String$1,
  Boolean: Boolean$1,
  Int: Int$1,
  Float: Float$1,
  DateTime: DateTime$1,
  Decimal: Decimal$1,
  'enum': enumFilters
});

// Do not manually modify this file, it is automatically generated by the package at /prisma-utils in this repo.
const StringNullableFilter = apiWithoutContext.inputObject({
  name: 'StringNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: NestedStringNullableFilter
    })
  })
});
const NestedStringNullableFilter = apiWithoutContext.inputObject({
  name: 'NestedStringNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: NestedStringNullableFilter
    })
  })
});
const StringFilter = apiWithoutContext.inputObject({
  name: 'StringFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    not: apiWithoutContext.arg({
      type: NestedStringFilter
    })
  })
});
const NestedStringFilter = apiWithoutContext.inputObject({
  name: 'NestedStringFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.String))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    contains: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    startsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    endsWith: apiWithoutContext.arg({
      type: apiWithoutContext.String
    }),
    not: apiWithoutContext.arg({
      type: NestedStringFilter
    })
  })
});
const BoolNullableFilter = apiWithoutContext.inputObject({
  name: 'BooleanNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: BoolNullableFilter
    })
  })
});
const BoolFilter = apiWithoutContext.inputObject({
  name: 'BooleanFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Boolean
    }),
    not: apiWithoutContext.arg({
      type: BoolFilter
    })
  })
});
const IntNullableFilter = apiWithoutContext.inputObject({
  name: 'IntNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: IntNullableFilter
    })
  })
});
const IntFilter = apiWithoutContext.inputObject({
  name: 'IntFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Int))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Int
    }),
    not: apiWithoutContext.arg({
      type: IntFilter
    })
  })
});
const FloatNullableFilter = apiWithoutContext.inputObject({
  name: 'FloatNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: FloatNullableFilter
    })
  })
});
const FloatFilter = apiWithoutContext.inputObject({
  name: 'FloatFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(apiWithoutContext.Float))
    }),
    lt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    lte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gt: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    gte: apiWithoutContext.arg({
      type: apiWithoutContext.Float
    }),
    not: apiWithoutContext.arg({
      type: FloatFilter
    })
  })
});
const DateTimeNullableFilter = apiWithoutContext.inputObject({
  name: 'DateTimeNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: DateTimeNullableFilter
    })
  })
});
const DateTimeFilter = apiWithoutContext.inputObject({
  name: 'DateTimeFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.DateTime))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.DateTime
    }),
    not: apiWithoutContext.arg({
      type: DateTimeFilter
    })
  })
});
const DecimalNullableFilter = apiWithoutContext.inputObject({
  name: 'DecimalNullableFilter',
  fields: () => ({
    // can be null
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    // can be null
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    // can be null
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    // can be null
    not: apiWithoutContext.arg({
      type: DecimalNullableFilter
    })
  })
});
const DecimalFilter = apiWithoutContext.inputObject({
  name: 'DecimalFilter',
  fields: () => ({
    equals: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    in: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    notIn: apiWithoutContext.arg({
      type: apiWithoutContext.list(apiWithoutContext.nonNull(graphqlTsSchema.Decimal))
    }),
    lt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    lte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gt: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    gte: apiWithoutContext.arg({
      type: graphqlTsSchema.Decimal
    }),
    not: apiWithoutContext.arg({
      type: DecimalFilter
    })
  })
});
const String = {
  optional: StringNullableFilter,
  required: StringFilter
};
const Boolean = {
  optional: BoolNullableFilter,
  required: BoolFilter
};
const Int = {
  optional: IntNullableFilter,
  required: IntFilter
};
const Float = {
  optional: FloatNullableFilter,
  required: FloatFilter
};
const DateTime = {
  optional: DateTimeNullableFilter,
  required: DateTimeFilter
};
const Decimal = {
  optional: DecimalNullableFilter,
  required: DecimalFilter
};

var sqlite = /*#__PURE__*/Object.freeze({
  __proto__: null,
  String: String,
  Boolean: Boolean,
  Int: Int,
  Float: Float,
  DateTime: DateTime,
  Decimal: Decimal,
  'enum': enumFilters
});

exports.QueryMode = QueryMode;
exports.fieldType = fieldType;
exports.orderDirectionEnum = orderDirectionEnum;
exports.postgresql = postgresql;
exports.sqlite = sqlite;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/useInvalidFields-162d1b9c.cjs.dev.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/useInvalidFields-162d1b9c.cjs.dev.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "react");
var isDeepEqual = __webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
var getRootGraphQLFieldsFromFieldController = __webpack_require__(/*! ./getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var isDeepEqual__default = /*#__PURE__*/_interopDefault(isDeepEqual);

function deserializeValue(fields, itemGetter) {
  const value = {};
  Object.keys(fields).forEach(fieldKey => {
    const field = fields[fieldKey];
    const itemForField = {};
    const errors = new Set();

    for (const graphqlField of getRootGraphQLFieldsFromFieldController.getRootGraphQLFieldsFromFieldController(field.controller)) {
      const fieldGetter = itemGetter.get(graphqlField);

      if (fieldGetter.errors) {
        fieldGetter.errors.forEach(error => {
          errors.add(error);
        });
      }

      itemForField[graphqlField] = fieldGetter.data;
    }

    if (errors.size) {
      value[fieldKey] = {
        kind: 'error',
        errors: [...errors]
      };
    } else {
      value[fieldKey] = {
        kind: 'value',
        value: field.controller.deserialize(itemForField)
      };
    }
  });
  return value;
}
function serializeValueToObjByFieldKey(fields, value) {
  const obj = {};
  Object.keys(fields).map(fieldKey => {
    const val = value[fieldKey];

    if (val.kind === 'value') {
      obj[fieldKey] = fields[fieldKey].controller.serialize(val.value);
    }
  });
  return obj;
}

function useChangedFieldsAndDataForUpdate(fields, itemGetter, value) {
  const serializedValuesFromItem = React.useMemo(() => {
    const value = deserializeValue(fields, itemGetter);
    return serializeValueToObjByFieldKey(fields, value);
  }, [fields, itemGetter]);
  const serializedFieldValues = React.useMemo(() => {
    return serializeValueToObjByFieldKey(fields, value);
  }, [value, fields]);
  return React.useMemo(() => {
    let changedFields = new Set();
    Object.keys(serializedFieldValues).forEach(fieldKey => {
      let isEqual = isDeepEqual__default["default"](serializedFieldValues[fieldKey], serializedValuesFromItem[fieldKey]);

      if (!isEqual) {
        changedFields.add(fieldKey);
      }
    });
    const dataForUpdate = {};
    changedFields.forEach(fieldKey => {
      Object.assign(dataForUpdate, serializedFieldValues[fieldKey]);
    });
    return {
      changedFields: changedFields,
      dataForUpdate
    };
  }, [serializedFieldValues, serializedValuesFromItem]);
}

function useInvalidFields(fields, value) {
  return React.useMemo(() => {
    const invalidFields = new Set();
    Object.keys(value).forEach(fieldPath => {
      const val = value[fieldPath];

      if (val.kind === 'value') {
        const validateFn = fields[fieldPath].controller.validate;

        if (validateFn) {
          const result = validateFn(val.value);

          if (result === false) {
            invalidFields.add(fieldPath);
          }
        }
      }
    });
    return invalidFields;
  }, [fields, value]);
}

exports.deserializeValue = deserializeValue;
exports.serializeValueToObjByFieldKey = serializeValueToObjByFieldKey;
exports.useChangedFieldsAndDataForUpdate = useChangedFieldsAndDataForUpdate;
exports.useInvalidFields = useInvalidFields;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/dist/utils-eff1fd30.cjs.dev.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/dist/utils-eff1fd30.cjs.dev.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "react");

function useFormattedInput(config, {
  value,
  onChange,
  onBlur,
  onFocus
}) {
  // typeof value === 'string' implies the unparsed form
  // typeof value !== 'string' implies the parsed form
  if (typeof value === 'string' && typeof config.parse(value) !== 'string') {
    throw new Error(`Valid values must be passed in as a parsed value, not a raw value. The value you passed was \`${JSON.stringify(value)}\`, you should pass \`${JSON.stringify(config.parse(value))}\` instead`);
  }

  let [internalValueState, setInternalValueState] = React.useState(() => typeof value === 'string' ? value : config.format(value));
  const [isFocused, setIsFocused] = React.useState(false);

  if (typeof value === 'string' && value !== internalValueState) {
    setInternalValueState(value);
  } // If the value is not a string, we know it's in the parsed form


  if (typeof value !== 'string') {
    const formatted = config.format(value); // When the input is blurred, we want to show always show the formatted
    // version so if we're not focussed and the formatted version is different
    // to the current version, we need to update it.

    if (!isFocused && formatted !== internalValueState) {
      setInternalValueState(formatted);
    }

    const parsedInternal = config.parse(internalValueState); // We updating the internal value here because the
    // external value has changed.

    if (typeof parsedInternal !== 'string' && config.format(parsedInternal) !== formatted) {
      setInternalValueState(formatted);
    }
  }

  return {
    value: internalValueState,

    onChange(event) {
      const value = event.target.value;
      const parsed = config.parse(value);
      onChange(parsed);
      setInternalValueState(value);
    },

    onFocus(event) {
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
      setIsFocused(true);
    },

    onBlur(event) {
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
      setIsFocused(false); // this isn't strictly necessary since we already do this in render
      // this just saves another rerender after setIsFocused(false)

      if (typeof value !== 'string') {
        setInternalValueState(config.format(value));
      }
    }

  };
}

exports.useFormattedInput = useFormattedInput;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.dev.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.dev.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! react */ "react");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

/** @jsxRuntime classic */
const Field = ({
  field,
  value,
  onChange,
  autoFocus
}) => {
  const {
    fields: fields$1,
    typography
  } = core.useTheme();
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.Checkbox, {
    autoFocus: autoFocus,
    disabled: onChange === undefined,
    onChange: event => {
      onChange === null || onChange === void 0 ? void 0 : onChange(event.target.checked);
    },
    checked: value
  }, core.jsx("span", {
    css: {
      fontWeight: typography.fontWeight.semibold,
      color: fields$1.labelColor
    }
  }, field.label)));
};
const Cell = ({
  item,
  field
}) => {
  const value = !!item[field.path];
  return core.jsx(CellContainer.CellContainer, null, core.jsx(fields.Checkbox, {
    disabled: true,
    checked: value,
    size: "small"
  }, core.jsx("span", {
    css: {}
  }, value ? 'True' : 'False')));
};
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), item[field.path] + '');
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    defaultValue: config.fieldMeta.defaultValue,

    deserialize(item) {
      const value = item[config.path];
      return typeof value === 'boolean' ? value : false;
    },

    serialize(value) {
      return {
        [config.path]: value
      };
    },

    filter: {
      Filter() {
        return null;
      },

      graphql({
        type
      }) {
        return {
          [config.path]: {
            equals: type === 'is'
          }
        };
      },

      Label({
        label
      }) {
        return label.toLowerCase();
      },

      types: {
        is: {
          label: 'is',
          initialValue: true
        },
        not: {
          label: 'is not',
          initialValue: true
        }
      }
    }
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-checkbox-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/image/utils/dist/keystone-next-keystone-fields-types-image-utils.cjs.dev.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/image/utils/dist/keystone-next-keystone-fields-types-image-utils.cjs.dev.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const IMAGEREGEX = /^(local|keystone-cloud):image:([^\\\/:\n]+)\.(gif|jpg|png|webp)$/;
const getImageRef = (mode, id, extension) => `${mode}:image:${id}.${extension}`;
const SUPPORTED_IMAGE_EXTENSIONS = ['jpg', 'png', 'webp', 'gif'];
const parseImageRef = ref => {
  const match = ref.match(IMAGEREGEX);

  if (match) {
    const [, mode, id, ext] = match;
    return {
      mode: mode,
      id,
      extension: ext
    };
  }

  return undefined;
};

exports.SUPPORTED_IMAGE_EXTENSIONS = SUPPORTED_IMAGE_EXTENSIONS;
exports.getImageRef = getImageRef;
exports.parseImageRef = parseImageRef;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.dev.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.dev.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var copy = __webpack_require__(/*! copy-to-clipboard */ "copy-to-clipboard");
var bytes = __webpack_require__(/*! bytes */ "bytes");
var React = __webpack_require__(/*! react */ "react");
var toast = __webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
var pill = __webpack_require__(/*! @keystone-ui/pill */ "@keystone-ui/pill");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var fields_types_image_utils_dist_keystoneNextKeystoneFieldsTypesImageUtils = __webpack_require__(/*! ../../utils/dist/keystone-next-keystone-fields-types-image-utils.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/image/utils/dist/keystone-next-keystone-fields-types-image-utils.cjs.dev.js");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var copy__default = /*#__PURE__*/_interopDefault(copy);
var bytes__default = /*#__PURE__*/_interopDefault(bytes);

/** @jsxRuntime classic */

function useObjectURL(fileData) {
  let [objectURL, setObjectURL] = React.useState(undefined);
  React.useEffect(() => {
    if (fileData) {
      let url = URL.createObjectURL(fileData);
      setObjectURL(url);
      return () => {
        URL.revokeObjectURL(url);
      };
    }
  }, [fileData]);
  return objectURL;
}

const RefView = ({
  field,
  onChange,
  onCancel,
  error
}) => {
  return core.jsx(React.Fragment, null, core.jsx(core.VisuallyHidden, {
    htmlFor: `${field.path}--ref-input`,
    as: "label"
  }, 'Paste the image ref here'), core.jsx(core.Stack, {
    gap: "small",
    across: true,
    css: {
      width: '100%',
      justifyContent: 'space-between',
      'div:first-of-type': {
        flex: '2'
      }
    }
  }, core.jsx(fields.TextInput, {
    id: `${field.path}--ref-input`,
    autoFocus: true,
    placeholder: "Paste the image ref here",
    onChange: event => {
      onChange(event.target.value);
    },
    css: {
      width: '100%'
    }
  }), core.jsx(button.Button, {
    tone: "passive",
    onClick: onCancel
  }, "Cancel"), error ? core.jsx(pill.Pill, {
    weight: "light",
    tone: "negative"
  }, error) : null));
};

function Field({
  autoFocus,
  field,
  value,
  forceValidation,
  onChange
}) {
  const inputRef = React.useRef(null);
  const errorMessage = createErrorMessage(value, forceValidation);

  const onUploadChange = ({
    currentTarget: {
      validity,
      files
    }
  }) => {
    const file = files === null || files === void 0 ? void 0 : files[0];
    if (!file) return; // bail if the user cancels from the file browser

    onChange === null || onChange === void 0 ? void 0 : onChange({
      kind: 'upload',
      data: {
        file,
        validity
      },
      previous: value
    });
  }; // Generate a random input key when the value changes, to ensure the file input is unmounted and
  // remounted (this is the only way to reset its value and ensure onChange will fire again if
  // the user selects the same file again)
  // eslint-disable-next-line react-hooks/exhaustive-deps


  const inputKey = React.useMemo(() => Math.random(), [value]);
  return core.jsx(fields.FieldContainer, {
    as: "fieldset"
  }, core.jsx(fields.FieldLabel, {
    as: "legend"
  }, field.label), value.kind === 'ref' ? core.jsx(RefView, {
    field: field,
    onChange: ref => {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        kind: 'ref',
        data: {
          ref
        },
        previous: value.previous
      });
    },
    error: forceValidation && errorMessage ? errorMessage : undefined,
    onCancel: () => {
      onChange === null || onChange === void 0 ? void 0 : onChange(value.previous);
    }
  }) : core.jsx(ImgView, {
    errorMessage: errorMessage,
    value: value,
    onChange: onChange,
    field: field,
    inputRef: inputRef
  }), core.jsx("input", {
    css: {
      display: 'none'
    },
    autoComplete: "off",
    autoFocus: autoFocus,
    ref: inputRef,
    key: inputKey,
    name: field.path,
    onChange: onUploadChange,
    type: "file",
    disabled: onChange === undefined
  }));
}

function ImgView({
  errorMessage,
  value,
  onChange,
  field,
  inputRef
}) {
  const {
    addToast
  } = toast.useToasts();
  const imagePathFromUpload = useObjectURL(errorMessage === undefined && value.kind === 'upload' ? value.data.file : undefined);

  const onSuccess = () => {
    addToast({
      title: 'Copied image ref to clipboard',
      tone: 'positive'
    });
  };

  const onFailure = () => {
    addToast({
      title: 'Failed to copy image ref to clipboard',
      tone: 'negative'
    });
  };

  const copyRef = () => {
    if (value.kind !== 'from-server') {
      return;
    }

    if (navigator) {
      // use the new navigator.clipboard API if it exists
      navigator.clipboard.writeText(value === null || value === void 0 ? void 0 : value.data.ref).then(onSuccess, onFailure);
      return;
    } else {
      // Fallback to a library that leverages document.execCommand
      // for browser versions that dont' support the navigator object.
      // As document.execCommand
      try {
        copy__default["default"](value === null || value === void 0 ? void 0 : value.data.ref);
      } catch (e) {
        addToast({
          title: 'Faild to oopy to clipboard',
          tone: 'negative'
        });
      }

      return;
    }
  };

  return value.kind === 'from-server' || value.kind === 'upload' ? core.jsx(core.Stack, {
    gap: "small",
    across: true,
    align: "center"
  }, errorMessage === undefined ? value.kind === 'from-server' ? core.jsx(ImageWrapper, null, core.jsx("img", {
    css: {
      width: '100%'
    },
    src: value.data.src,
    alt: field.path
  })) : core.jsx(ImageWrapper, null, core.jsx("img", {
    css: {
      height: 'auto',
      maxWidth: '100%'
    },
    src: imagePathFromUpload,
    alt: field.path
  })) : null, onChange && core.jsx(core.Stack, {
    gap: "small"
  }, value.kind === 'from-server' && core.jsx(core.Stack, {
    padding: "xxsmall",
    gap: "xxsmall"
  }, core.jsx(core.Stack, {
    across: true,
    align: "center",
    gap: "small"
  }, core.jsx(core.Text, {
    size: "small"
  }, core.jsx("a", {
    href: value.data.src,
    target: "_blank"
  }, `${value.data.id}.${value.data.extension}`)), core.jsx(button.Button, {
    size: "small",
    tone: "passive",
    onClick: copyRef
  }, "Copy Ref")), core.jsx(core.Text, {
    size: "xsmall"
  }, `${value.data.width} x ${value.data.height} (${bytes__default["default"](value.data.filesize)})`)), core.jsx(core.Stack, {
    across: true,
    gap: "small",
    align: "center"
  }, core.jsx(button.Button, {
    size: "small",
    onClick: () => {
      var _inputRef$current;

      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.click();
    }
  }, "Change"), value.kind !== 'upload' ? core.jsx(button.Button, {
    size: "small",
    tone: "passive",
    onClick: () => {
      onChange({
        kind: 'ref',
        data: {
          ref: ''
        },
        previous: value
      });
    }
  }, "Paste Ref") : null, value.kind === 'from-server' && core.jsx(button.Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      onChange({
        kind: 'remove',
        previous: value
      });
    }
  }, "Remove"), value.kind === 'upload' && core.jsx(button.Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      onChange(value.previous);
    }
  }, "Cancel"), errorMessage ? core.jsx(pill.Pill, {
    tone: "negative",
    weight: "light"
  }, errorMessage) : value.kind === 'upload' && core.jsx(pill.Pill, {
    weight: "light",
    tone: "positive"
  }, "Save to upload this image")))) : core.jsx(core.Stack, {
    gap: "small"
  }, core.jsx(core.Stack, {
    css: {
      alignItems: 'center'
    },
    gap: "small",
    across: true
  }, core.jsx(button.Button, {
    size: "small",
    disabled: onChange === undefined,
    onClick: () => {
      var _inputRef$current2;

      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.click();
    },
    tone: "positive"
  }, "Upload Image"), core.jsx(button.Button, {
    size: "small",
    tone: "passive",
    disabled: onChange === undefined,
    onClick: () => {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        kind: 'ref',
        data: {
          ref: ''
        },
        previous: value
      });
    }
  }, "Paste Ref"), value.kind === 'remove' && value.previous && core.jsx(button.Button, {
    size: "small",
    tone: "negative",
    onClick: () => {
      if (value.previous !== undefined) {
        onChange === null || onChange === void 0 ? void 0 : onChange(value === null || value === void 0 ? void 0 : value.previous);
      }
    }
  }, "Undo removal"), value.kind === 'remove' && // NOTE -- UX decision is to not display this, I think it would only be relevant
  // for deleting uploaded images (and we don't support that yet)
  // <Pill weight="light" tone="warning">
  //   Save to remove this image
  // </Pill>
  null));
}

function validateRef({
  ref
}) {
  if (!fields_types_image_utils_dist_keystoneNextKeystoneFieldsTypesImageUtils.parseImageRef(ref)) {
    return 'Invalid ref';
  }
}

function createErrorMessage(value, forceValidation) {
  if (value.kind === 'upload') {
    return validateImage(value.data);
  } else if (value.kind === 'ref') {
    return forceValidation ? validateRef(value.data) : undefined;
  }
}

function validateImage({
  file,
  validity
}) {
  if (!validity.valid) {
    return 'Something went wrong, please reload and try again.';
  } // check if the file is actually an image


  if (!file.type.includes('image')) {
    return 'Only image files are allowed. Please try again.';
  }
} // ==============================
// Styled Components
// ==============================

const ImageWrapper = ({
  children
}) => {
  const theme = core.useTheme();
  return core.jsx("div", {
    css: {
      backgroundColor: 'white',
      borderRadius: theme.radii.medium,
      border: `1px solid ${theme.colors.border}`,
      flexShrink: 0,
      lineHeight: 0,
      padding: 4,
      position: 'relative',
      textAlign: 'center',
      width: '130px' // 120px image + chrome

    }
  }, children);
};

/** @jsxRuntime classic */
const Cell = ({
  item,
  field
}) => {
  const data = item[field.path];
  if (!data) return null;
  return core.jsx("div", {
    css: {
      alignItems: 'center',
      display: 'flex',
      height: 24,
      lineHeight: 0,
      width: 24
    }
  }, core.jsx("img", {
    alt: data.filename,
    css: {
      maxHeight: '100%',
      maxWidth: '100%'
    },
    src: data.src
  }));
};
const CardValue = ({
  item,
  field
}) => {
  const data = item[field.path];
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), data && core.jsx(ImageWrapper, null, core.jsx("img", {
    css: {
      width: '100%'
    },
    alt: data.filename,
    src: data.src
  })));
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: `${config.path} {
        src
        id
        ref
        extension
        width
        height
        filesize
      }`,
    defaultValue: {
      kind: 'empty'
    },

    deserialize(item) {
      const value = item[config.path];
      if (!value) return {
        kind: 'empty'
      };
      return {
        kind: 'from-server',
        data: {
          src: value.src,
          id: value.id,
          extension: value.extension,
          ref: value.ref,
          width: value.width,
          height: value.height,
          filesize: value.filesize
        }
      };
    },

    validate(value) {
      if (value.kind === 'ref') {
        return validateRef(value.data) === undefined;
      }

      return value.kind !== 'upload' || validateImage(value.data) === undefined;
    },

    serialize(value) {
      if (value.kind === 'upload') {
        return {
          [config.path]: {
            upload: value.data.file
          }
        };
      }

      if (value.kind === 'ref') {
        return {
          [config.path]: {
            ref: value.data.ref
          }
        };
      }

      if (value.kind === 'remove') {
        return {
          [config.path]: null
        };
      }

      return {};
    }

  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-image-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.dev.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.dev.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
var CellLink = __webpack_require__(/*! ../../../../../dist/CellLink-dc41c877.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! react */ "react");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! ../../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

/** @jsxRuntime classic */
const Field = ({
  field,
  forceValidation,
  value,
  onChange,
  autoFocus
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label, onChange ? core.jsx(core.Stack, null, core.jsx(fields.TextArea, {
    css: {
      fontFamily: 'monospace'
    },
    autoFocus: autoFocus,
    onChange: event => onChange(event.target.value),
    value: value
  }), forceValidation && core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, 'Invalid JSON')) : value));
};
const Cell = ({
  item,
  field,
  linkTo
}) => {
  let value = item[field.path] + '';
  return linkTo ? core.jsx(CellLink.CellLink, linkTo, value) : core.jsx(CellContainer.CellContainer, null, value);
};
Cell.supportsLinkTo = true;
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), item[field.path]);
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    defaultValue: config.fieldMeta.defaultValue === null ? '' : JSON.stringify(config.fieldMeta.defaultValue, null, 2),
    validate: value => {
      if (!value) return true;

      try {
        JSON.parse(value);
        return true;
      } catch (e) {
        return false;
      }
    },
    deserialize: data => {
      const value = data[config.path];
      if (!value) return '';
      return JSON.stringify(value, null, 2);
    },
    serialize: value => {
      let parsedValue;

      if (!value) {
        return {
          [config.path]: null
        };
      }

      try {
        parsedValue = JSON.parse(value);
      } catch (e) {}

      return {
        [config.path]: parsedValue
      };
    }
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-json-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.dev.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.dev.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var React = __webpack_require__(/*! react */ "react");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var EyeIcon = __webpack_require__(/*! @keystone-ui/icons/icons/EyeIcon */ "@keystone-ui/icons/icons/EyeIcon");
var EyeOffIcon = __webpack_require__(/*! @keystone-ui/icons/icons/EyeOffIcon */ "@keystone-ui/icons/icons/EyeOffIcon");
var XIcon = __webpack_require__(/*! @keystone-ui/icons/icons/XIcon */ "@keystone-ui/icons/icons/XIcon");
var segmentedControl = __webpack_require__(/*! @keystone-ui/segmented-control */ "@keystone-ui/segmented-control");
var dumbPasswords = __webpack_require__(/*! dumb-passwords */ "dumb-passwords");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var dumbPasswords__default = /*#__PURE__*/_interopDefault(dumbPasswords);

function validate(value, validation, fieldLabel) {
  if (value.kind === 'initial' && (value.isSet === null || value.isSet === true)) {
    return undefined;
  }

  if (value.kind === 'initial' && validation !== null && validation !== void 0 && validation.isRequired) {
    return `${fieldLabel} is required`;
  }

  if (value.kind === 'editing' && value.confirm !== value.value) {
    return `The passwords do not match`;
  }

  if (value.kind === 'editing') {
    const val = value.value;

    if (val.length < validation.length.min) {
      if (validation.length.min === 1) {
        return `${fieldLabel} must not be empty`;
      }

      return `${fieldLabel} must be at least ${validation.length.min} characters long`;
    }

    if (validation.length.max !== null && val.length > validation.length.max) {
      return `${fieldLabel} must be no longer than ${validation.length.min} characters`;
    }

    if (validation.match && !validation.match.regex.test(val)) {
      return validation.match.explanation;
    }

    if (validation.rejectCommon && dumbPasswords__default["default"].check(val)) {
      return `${fieldLabel} is too common and is not allowed`;
    }
  }

  return undefined;
}

function isSetText(isSet) {
  return isSet == null ? 'Access Denied' : isSet ? 'Is set' : 'Is not set';
}

const Field = ({
  field,
  value,
  onChange,
  forceValidation,
  autoFocus
}) => {
  const [showInputValue, setShowInputValue] = React.useState(false);
  const [touchedFirstInput, setTouchedFirstInput] = React.useState(false);
  const [touchedSecondInput, setTouchedSecondInput] = React.useState(false);
  const shouldShowValidation = forceValidation || touchedFirstInput && touchedSecondInput;
  const validationMessage = shouldShowValidation ? validate(value, field.validation, field.label) : undefined;
  const validation = validationMessage && core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, validationMessage);
  const inputType = showInputValue ? 'text' : 'password';
  return core.jsx(fields.FieldContainer, {
    as: "fieldset"
  }, core.jsx(fields.FieldLabel, {
    as: "legend"
  }, field.label), onChange === undefined ? isSetText(value.isSet) : value.kind === 'initial' ? core.jsx(React.Fragment, null, core.jsx(button.Button, {
    autoFocus: autoFocus,
    onClick: () => {
      onChange({
        kind: 'editing',
        confirm: '',
        value: '',
        isSet: value.isSet
      });
    }
  }, value.isSet ? 'Change Password' : 'Set Password'), validation) : core.jsx(core.Stack, {
    gap: "small"
  }, core.jsx("div", {
    css: {
      display: 'flex'
    }
  }, core.jsx(core.VisuallyHidden, {
    as: "label",
    htmlFor: `${field.path}-new-password`
  }, "New Password"), core.jsx(fields.TextInput, {
    id: `${field.path}-new-password`,
    autoFocus: true,
    invalid: validationMessage !== undefined,
    type: inputType,
    value: value.value,
    placeholder: "New Password",
    onChange: event => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: event.target.value
      }));
    },
    onBlur: () => {
      setTouchedFirstInput(true);
    }
  }), core.jsx(Spacer, null), core.jsx(core.VisuallyHidden, {
    as: "label",
    htmlFor: `${field.path}-confirm-password`
  }, "Confirm Password"), core.jsx(fields.TextInput, {
    id: `${field.path}-confirm-password`,
    invalid: validationMessage !== undefined,
    type: inputType,
    value: value.confirm,
    placeholder: "Confirm Password",
    onChange: event => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        confirm: event.target.value
      }));
    },
    onBlur: () => {
      setTouchedSecondInput(true);
    }
  }), core.jsx(Spacer, null), core.jsx(button.Button, {
    onClick: () => {
      setShowInputValue(!showInputValue);
    }
  }, core.jsx(core.VisuallyHidden, null, showInputValue ? 'Hide Text' : 'Show Text'), showInputValue ? core.jsx(EyeOffIcon.EyeOffIcon, null) : core.jsx(EyeIcon.EyeIcon, null)), core.jsx(Spacer, null), core.jsx(button.Button, {
    onClick: () => {
      onChange({
        kind: 'initial',
        isSet: value.isSet
      });
    }
  }, core.jsx(core.VisuallyHidden, null, "Cancel"), core.jsx(XIcon.XIcon, null))), validation));
};
const Cell = ({
  item,
  field
}) => {
  var _item$field$path;

  return core.jsx(CellContainer.CellContainer, null, isSetText((_item$field$path = item[field.path]) === null || _item$field$path === void 0 ? void 0 : _item$field$path.isSet));
};
const CardValue = ({
  item,
  field
}) => {
  var _item$field$path2;

  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), isSetText((_item$field$path2 = item[field.path]) === null || _item$field$path2 === void 0 ? void 0 : _item$field$path2.isSet));
};
const controller = config => {
  const validation = _objectSpread(_objectSpread({}, config.fieldMeta.validation), {}, {
    match: config.fieldMeta.validation.match === null ? null : {
      regex: new RegExp(config.fieldMeta.validation.match.regex.source, config.fieldMeta.validation.match.regex.flags),
      explanation: config.fieldMeta.validation.match.explanation
    }
  });

  return {
    path: config.path,
    label: config.label,
    graphqlSelection: `${config.path} {isSet}`,
    validation,
    defaultValue: {
      kind: 'initial',
      isSet: false
    },
    validate: state => validate(state, validation, config.label) === undefined,
    deserialize: data => {
      var _data$config$path$isS, _data$config$path;

      return {
        kind: 'initial',
        isSet: (_data$config$path$isS = (_data$config$path = data[config.path]) === null || _data$config$path === void 0 ? void 0 : _data$config$path.isSet) !== null && _data$config$path$isS !== void 0 ? _data$config$path$isS : null
      };
    },
    serialize: value => {
      if (value.kind === 'initial') return {};
      return {
        [config.path]: value.value
      };
    },
    filter: config.fieldMeta.isNullable === false ? undefined : {
      Filter(props) {
        return core.jsx(segmentedControl.SegmentedControl, {
          selectedIndex: Number(props.value),
          onChange: value => {
            props.onChange(!!value);
          },
          segments: ['Is Not Set', 'Is Set']
        });
      },

      graphql: ({
        value
      }) => {
        return {
          [config.path]: {
            isSet: value
          }
        };
      },

      Label({
        value
      }) {
        return value ? 'is set' : 'is not set';
      },

      types: {
        is_set: {
          label: 'Is Set',
          initialValue: true
        }
      }
    }
  };
};

const Spacer = () => {
  const {
    spacing
  } = core.useTheme();
  return core.jsx("div", {
    css: {
      width: spacing.small,
      flexShrink: 0
    }
  });
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-password-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect/dist/keystone-next-keystone-fields-types-relationship-views-RelationshipSelect.cjs.dev.js":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect/dist/keystone-next-keystone-fields-types-relationship-views-RelationshipSelect.cjs.dev.js ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
var _toPropertyKey = __webpack_require__(/*! @babel/runtime/helpers/toPropertyKey */ "../../node_modules/@babel/runtime/helpers/toPropertyKey.js");
__webpack_require__(/*! intersection-observer */ "intersection-observer");
var React = __webpack_require__(/*! react */ "react");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var uuid = __webpack_require__(/*! uuid */ "uuid");
var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");

const _excluded = ["children"];

function useIntersectionObserver(cb, ref) {
  React.useEffect(() => {
    let observer = new IntersectionObserver(cb, {});
    let node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  });
}

const idValidators = {
  uuid: uuid.validate,

  cuid(value) {
    return value.startsWith('c');
  },

  autoincrement(value) {
    return /^\d+$/.test(value);
  }

};

function useFilter(search, list) {
  return React.useMemo(() => {
    let conditions = [];

    if (search.length) {
      const idFieldKind = list.fields.id.controller.idFieldKind;
      const trimmedSearch = search.trim();
      const isValidId = idValidators[idFieldKind](trimmedSearch);

      if (isValidId) {
        conditions.push({
          id: trimmedSearch
        });
      }

      for (const field of Object.values(list.fields)) {
        if (field.search !== null) {
          conditions.push({
            [`${field.path}_contains${field.search === 'insensitive' ? '_i' : ''}`]: trimmedSearch
          });
        }
      }
    }

    return {
      OR: conditions
    };
  }, [search, list]);
}

const initialItemsToLoad = 10;
const subsequentItemsToLoad = 50;
const idField = '____id____';
const labelField = '____label____';
const LoadingIndicatorContext = /*#__PURE__*/React.createContext({
  count: 0,
  ref: () => {}
});
const RelationshipSelect = ({
  autoFocus,
  controlShouldRenderValue,
  isDisabled,
  isLoading,
  list,
  placeholder,
  portalMenu,
  state,
  extraSelection = ''
}) => {
  var _data$items;

  const [search, setSearch] = React.useState(''); // note it's important that this is in state rather than a ref
  // because we want a re-render if the element changes
  // so that we can register the intersection observer
  // on the right element

  const [loadingIndicatorElement, setLoadingIndicatorElement] = React.useState(null);
  const QUERY = client.gql`
    query RelationshipSelect($where: ${list.gqlNames.whereInputName}!, $take: Int!, $skip: Int!) {
      items: ${list.gqlNames.listQueryName}(where: $where, take: $take, skip: $skip) {
        ${idField}: id
        ${labelField}: ${list.labelField}
        ${extraSelection}
      }
      count: ${list.gqlNames.listQueryCountName}(where: $where)
    }
  `;
  const where = useFilter(search, list);
  const {
    data,
    error,
    loading,
    fetchMore
  } = client.useQuery(QUERY, {
    fetchPolicy: 'network-only',
    variables: {
      where,
      take: initialItemsToLoad,
      skip: 0
    }
  });
  const count = (data === null || data === void 0 ? void 0 : data.count) || 0;
  const options = (data === null || data === void 0 ? void 0 : (_data$items = data.items) === null || _data$items === void 0 ? void 0 : _data$items.map(_ref => {
    let {
      [idField]: value,
      [labelField]: label
    } = _ref,
        data = _objectWithoutProperties(_ref, [idField, labelField].map(_toPropertyKey));

    return {
      value,
      label: label || value,
      data
    };
  })) || [];
  const loadingIndicatorContextVal = React.useMemo(() => ({
    count,
    ref: setLoadingIndicatorElement
  }), [count]);
  useIntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!loading && isIntersecting && options.length < count) {
      const QUERY = client.gql`
              query RelationshipSelectMore($where: ${list.gqlNames.whereInputName}!, $take: Int!, $skip: Int!) {
                items: ${list.gqlNames.listQueryName}(where: $where, take: $take, skip: $skip) {
                  ${labelField}: ${list.labelField}
                  ${idField}: id
                  ${extraSelection}
                }
              }
            `;
      fetchMore({
        query: QUERY,
        variables: {
          where,
          take: subsequentItemsToLoad,
          skip: data.items.length
        },
        updateQuery: (prev, {
          fetchMoreResult
        }) => {
          if (!fetchMoreResult) return prev;
          return _objectSpread(_objectSpread({}, prev), {}, {
            items: [...prev.items, ...fetchMoreResult.items]
          });
        }
      });
    }
  }, {
    current: loadingIndicatorElement
  }); // TODO: better error UI
  // TODO: Handle permission errors
  // (ie; user has permission to read this relationship field, but
  // not the related list, or some items on the list)

  if (error) {
    return core.jsx("span", null, "Error");
  }

  if (state.kind === 'one') {
    return core.jsx(LoadingIndicatorContext.Provider, {
      value: loadingIndicatorContextVal
    }, core.jsx(fields.Select // this is necessary because react-select passes a second argument to onInputChange
    // and useState setters log a warning if a second argument is passed
    , {
      onInputChange: val => setSearch(val),
      isLoading: loading || isLoading,
      autoFocus: autoFocus,
      components: relationshipSelectComponents,
      portalMenu: portalMenu,
      value: state.value ? {
        value: state.value.id,
        label: state.value.label,
        // @ts-ignore
        data: state.value.data
      } : null,
      options: options,
      onChange: value => {
        state.onChange(value ? {
          id: value.value,
          label: value.label,
          data: value.data
        } : null);
      },
      placeholder: placeholder,
      controlShouldRenderValue: controlShouldRenderValue,
      isClearable: controlShouldRenderValue,
      isDisabled: isDisabled
    }));
  }

  return core.jsx(LoadingIndicatorContext.Provider, {
    value: loadingIndicatorContextVal
  }, core.jsx(fields.MultiSelect // this is necessary because react-select passes a second argument to onInputChange
  // and useState setters log a warning if a second argument is passed
  , {
    onInputChange: val => setSearch(val),
    isLoading: loading || isLoading,
    autoFocus: autoFocus,
    components: relationshipSelectComponents,
    portalMenu: portalMenu,
    value: state.value.map(value => ({
      value: value.id,
      label: value.label,
      data: value.data
    })),
    options: options,
    onChange: value => {
      state.onChange(value.map(x => ({
        id: x.value,
        label: x.label,
        data: x.data
      })));
    },
    placeholder: placeholder,
    controlShouldRenderValue: controlShouldRenderValue,
    isClearable: controlShouldRenderValue,
    isDisabled: isDisabled
  }));
};
const relationshipSelectComponents = {
  MenuList: _ref2 => {
    let {
      children
    } = _ref2,
        props = _objectWithoutProperties(_ref2, _excluded);

    const {
      count,
      ref
    } = React.useContext(LoadingIndicatorContext);
    return core.jsx(fields.selectComponents.MenuList, props, children, core.jsx("div", {
      css: {
        textAlign: 'center'
      },
      ref: ref
    }, props.options.length < count && core.jsx("span", {
      css: {
        padding: 8
      }
    }, "Loading...")));
  }
};

exports.RelationshipSelect = RelationshipSelect;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.dev.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.dev.js ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var React = __webpack_require__(/*! react */ "react");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var modals = __webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
var adminUi_router_dist_keystoneNextKeystoneAdminUiRouter = __webpack_require__(/*! ../../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
var adminUi_context_dist_keystoneNextKeystoneAdminUiContext = __webpack_require__(/*! ../../../../../admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/context/dist/keystone-next-keystone-admin-ui-context.cjs.dev.js");
var client = __webpack_require__(/*! @apollo/client */ "@apollo/client");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
var _objectWithoutProperties = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
var CreateItemDrawer = __webpack_require__(/*! ../../../../../dist/CreateItemDrawer-fa4e2213.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CreateItemDrawer-fa4e2213.cjs.dev.js");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
var tooltip = __webpack_require__(/*! @keystone-ui/tooltip */ "@keystone-ui/tooltip");
var loading = __webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
var dataGetter = __webpack_require__(/*! ../../../../../dist/dataGetter-9fbe2f8e.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/dataGetter-9fbe2f8e.cjs.dev.js");
var getRootGraphQLFieldsFromFieldController = __webpack_require__(/*! ../../../../../dist/getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/getRootGraphQLFieldsFromFieldController-47699a0d.cjs.dev.js");
var isDeepEqual = __webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
var fields_types_relationship_views_RelationshipSelect_dist_keystoneNextKeystoneFieldsTypesRelationshipViewsRelationshipSelect = __webpack_require__(/*! ../RelationshipSelect/dist/keystone-next-keystone-fields-types-relationship-views-RelationshipSelect.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect/dist/keystone-next-keystone-fields-types-relationship-views-RelationshipSelect.cjs.dev.js");
var toast = __webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
var Fields = __webpack_require__(/*! ../../../../../dist/Fields-4afb38f0.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/Fields-4afb38f0.cjs.dev.js");
var useInvalidFields = __webpack_require__(/*! ../../../../../dist/useInvalidFields-162d1b9c.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/useInvalidFields-162d1b9c.cjs.dev.js");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
var GraphQLErrorNotice = __webpack_require__(/*! ../../../../../dist/GraphQLErrorNotice-76ff96dd.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/GraphQLErrorNotice-76ff96dd.cjs.dev.js");
__webpack_require__(/*! ../../../../../dist/core-c8ecce23.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/core-c8ecce23.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");
__webpack_require__(/*! @emotion/weak-memoize */ "@emotion/weak-memoize");
__webpack_require__(/*! @babel/runtime/helpers/toPropertyKey */ "../../node_modules/@babel/runtime/helpers/toPropertyKey.js");
__webpack_require__(/*! intersection-observer */ "intersection-observer");
__webpack_require__(/*! uuid */ "uuid");

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var isDeepEqual__default = /*#__PURE__*/_interopDefault(isDeepEqual);

function useItemState({
  selectedFields,
  localList,
  id,
  field
}) {
  const {
    data,
    error,
    loading
  } = client.useQuery(client.gql`query($id: ID!) {
  item: ${localList.gqlNames.itemQueryName}(where: {id: $id}) {
    id
    relationship: ${field.path} {
      ${selectedFields}
    }
  }
}`, {
    variables: {
      id
    },
    errorPolicy: 'all'
  });
  const {
    itemsArrFromData,
    relationshipGetter
  } = React.useMemo(() => {
    const dataGetter$1 = dataGetter.makeDataGetter(data, error === null || error === void 0 ? void 0 : error.graphQLErrors);
    const relationshipGetter = dataGetter$1.get('item').get('relationship');
    const isMany = Array.isArray(relationshipGetter.data);
    const itemsArrFromData = (isMany ? relationshipGetter.data.map((_, i) => relationshipGetter.get(i)) : [relationshipGetter]).filter(x => {
      var _x$data;

      return ((_x$data = x.data) === null || _x$data === void 0 ? void 0 : _x$data.id) != null;
    });
    return {
      relationshipGetter,
      itemsArrFromData
    };
  }, [data, error]);
  let [{
    items,
    itemsArrFromData: itemsArrFromDataState
  }, setItemsState] = React.useState({
    itemsArrFromData: [],
    items: {}
  });

  if (itemsArrFromDataState !== itemsArrFromData) {
    let newItems = {};
    itemsArrFromData.forEach(item => {
      var _items$item$data$id, _item$errors, _initialItemInState$e;

      const initialItemInState = (_items$item$data$id = items[item.data.id]) === null || _items$item$data$id === void 0 ? void 0 : _items$item$data$id.fromInitialQuery;

      if ((items[item.data.id] && initialItemInState || !items[item.data.id]) && (!initialItemInState || item.data !== initialItemInState.data || ((_item$errors = item.errors) === null || _item$errors === void 0 ? void 0 : _item$errors.length) !== ((_initialItemInState$e = initialItemInState.errors) === null || _initialItemInState$e === void 0 ? void 0 : _initialItemInState$e.length) || (item.errors || []).some((err, i) => {
        var _initialItemInState$e2;

        return err !== ((_initialItemInState$e2 = initialItemInState.errors) === null || _initialItemInState$e2 === void 0 ? void 0 : _initialItemInState$e2[i]);
      }))) {
        newItems[item.data.id] = {
          current: item,
          fromInitialQuery: item
        };
      } else {
        newItems[item.data.id] = items[item.data.id];
      }
    });
    items = newItems;
    setItemsState({
      items: newItems,
      itemsArrFromData
    });
  }

  return {
    items: React.useMemo(() => {
      const itemsToReturn = {};
      Object.keys(items).forEach(id => {
        itemsToReturn[id] = items[id].current;
      });
      return itemsToReturn;
    }, [items]),
    setItems: React.useCallback(items => {
      setItemsState(state => {
        let itemsForState = {};
        Object.keys(items).forEach(id => {
          var _state$items$id;

          if (items[id] === ((_state$items$id = state.items[id]) === null || _state$items$id === void 0 ? void 0 : _state$items$id.current)) {
            itemsForState[id] = state.items[id];
          } else {
            var _state$items$id2;

            itemsForState[id] = {
              current: items[id],
              fromInitialQuery: (_state$items$id2 = state.items[id]) === null || _state$items$id2 === void 0 ? void 0 : _state$items$id2.fromInitialQuery
            };
          }
        });
        return {
          itemsArrFromData: state.itemsArrFromData,
          items: itemsForState
        };
      });
    }, [setItemsState]),
    state: (() => {
      if (loading) {
        return {
          kind: 'loading'
        };
      }

      if (error !== null && error !== void 0 && error.networkError) {
        return {
          kind: 'error',
          message: error.networkError.message
        };
      }

      if (field.many && !relationshipGetter.data) {
        var _relationshipGetter$e;

        return {
          kind: 'error',
          message: ((_relationshipGetter$e = relationshipGetter.errors) === null || _relationshipGetter$e === void 0 ? void 0 : _relationshipGetter$e[0].message) || ''
        };
      }

      return {
        kind: 'loaded'
      };
    })()
  };
}
function useFieldsObj(list, fields) {
  return React.useMemo(() => {
    const editFields = {};
    fields === null || fields === void 0 ? void 0 : fields.forEach(fieldPath => {
      editFields[fieldPath] = list.fields[fieldPath];
    });
    return editFields;
  }, [fields, list.fields]);
}

function InlineEdit({
  fields,
  list,
  selectedFields,
  itemGetter,
  onCancel,
  onSave
}) {
  var _itemGetter$errors;

  const fieldsObj = useFieldsObj(list, fields);
  const [update, {
    loading,
    error
  }] = client.useMutation(client.gql`mutation ($data: ${list.gqlNames.updateInputName}!, $id: ID!) {
          item: ${list.gqlNames.updateMutationName}(where: { id: $id }, data: $data) {
            ${selectedFields}
          }
        }`, {
    errorPolicy: 'all'
  });
  const [state, setValue] = React.useState(() => {
    const value = useInvalidFields.deserializeValue(fieldsObj, itemGetter);
    return {
      value,
      item: itemGetter.data
    };
  });

  if (state.item !== itemGetter.data && (_itemGetter$errors = itemGetter.errors) !== null && _itemGetter$errors !== void 0 && _itemGetter$errors.every(x => {
    var _x$path;

    return ((_x$path = x.path) === null || _x$path === void 0 ? void 0 : _x$path.length) !== 1;
  })) {
    const value = useInvalidFields.deserializeValue(fieldsObj, itemGetter);
    setValue({
      value,
      item: itemGetter.data
    });
  }

  const {
    changedFields,
    dataForUpdate
  } = useInvalidFields.useChangedFieldsAndDataForUpdate(fieldsObj, itemGetter, state.value);
  const invalidFields = useInvalidFields.useInvalidFields(fieldsObj, state.value);
  const [forceValidation, setForceValidation] = React.useState(false);
  const toasts = toast.useToasts();
  const saveButtonProps = {
    isLoading: loading,
    weight: 'bold',
    size: 'small',
    tone: 'active',
    onClick: () => {
      const newForceValidation = invalidFields.size !== 0;
      setForceValidation(newForceValidation);
      if (newForceValidation) return;
      update({
        variables: {
          data: dataForUpdate,
          id: itemGetter.get('id').data
        }
      }).then(({
        data,
        errors
      }) => {
        // we're checking for path.length === 1 because errors with a path larger than 1 will be field level errors
        // which are handled seperately and do not indicate a failure to update the item
        const error = errors === null || errors === void 0 ? void 0 : errors.find(x => {
          var _x$path2;

          return ((_x$path2 = x.path) === null || _x$path2 === void 0 ? void 0 : _x$path2.length) === 1;
        });

        if (error) {
          toasts.addToast({
            title: 'Failed to update item',
            tone: 'negative',
            message: error.message
          });
        } else {
          toasts.addToast({
            title: data.item[list.labelField] || data.item.id,
            tone: 'positive',
            message: 'Saved successfully'
          });
          onSave(dataGetter.makeDataGetter(data, errors).get('item'));
        }
      }).catch(err => {
        toasts.addToast({
          title: 'Failed to update item',
          tone: 'negative',
          message: err.message
        });
      });
    },
    children: 'Save'
  };
  return core.jsx(core.Stack, {
    gap: "xlarge"
  }, error && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: error === null || error === void 0 ? void 0 : error.networkError // we're checking for path.length === 1 because errors with a path larger than 1 will be field level errors
    // which are handled seperately and do not indicate a failure to update the item
    ,
    errors: error === null || error === void 0 ? void 0 : error.graphQLErrors.filter(x => {
      var _x$path3;

      return ((_x$path3 = x.path) === null || _x$path3 === void 0 ? void 0 : _x$path3.length) === 1;
    })
  }), core.jsx(Fields.Fields, {
    fieldModes: null,
    fields: fieldsObj,
    forceValidation: forceValidation,
    invalidFields: invalidFields,
    onChange: React.useCallback(value => {
      setValue(state => ({
        item: state.item,
        value: value(state.value)
      }));
    }, [setValue]),
    value: state.value
  }), core.jsx(core.Stack, {
    across: true,
    gap: "small"
  }, changedFields.size ? core.jsx(button.Button, saveButtonProps) : core.jsx(tooltip.Tooltip, {
    content: "No fields have been modified so you cannot save changes"
  }, props => core.jsx(button.Button, _extends({}, props, saveButtonProps, {
    // making onClick undefined instead of making the button disabled so the button can be focussed so keyboard users can see the tooltip
    onClick: undefined
  }))), core.jsx(button.Button, {
    size: "small",
    weight: "none",
    onClick: onCancel
  }, "Cancel")));
}

/** @jsxRuntime classic */
function InlineCreate({
  list,
  onCancel,
  onCreate,
  fields: fieldPaths,
  selectedFields
}) {
  const toasts = toast.useToasts();
  const fields = useFieldsObj(list, fieldPaths);
  const [createItem, {
    loading,
    error
  }] = client.useMutation(client.gql`mutation($data: ${list.gqlNames.createInputName}!) {
      item: ${list.gqlNames.createMutationName}(data: $data) {
        ${selectedFields}
    }
  }`);
  const [value, setValue] = React.useState(() => {
    const value = {};
    Object.keys(fields).forEach(fieldPath => {
      value[fieldPath] = {
        kind: 'value',
        value: fields[fieldPath].controller.defaultValue
      };
    });
    return value;
  });
  const invalidFields = useInvalidFields.useInvalidFields(fields, value);
  const [forceValidation, setForceValidation] = React.useState(false);

  const onCreateClick = () => {
    const newForceValidation = invalidFields.size !== 0;
    setForceValidation(newForceValidation);
    if (newForceValidation) return;
    const data = {};
    const allSerializedValues = useInvalidFields.serializeValueToObjByFieldKey(fields, value);
    Object.keys(allSerializedValues).forEach(fieldPath => {
      const {
        controller
      } = fields[fieldPath];
      const serialized = allSerializedValues[fieldPath];

      if (!isDeepEqual__default["default"](serialized, controller.serialize(controller.defaultValue))) {
        Object.assign(data, serialized);
      }
    });
    createItem({
      variables: {
        data
      }
    }).then(({
      data,
      errors
    }) => {
      // we're checking for path.length === 1 because errors with a path larger than 1 will be field level errors
      // which are handled seperately and do not indicate a failure to update the item
      const error = errors === null || errors === void 0 ? void 0 : errors.find(x => {
        var _x$path;

        return ((_x$path = x.path) === null || _x$path === void 0 ? void 0 : _x$path.length) === 1;
      });

      if (error) {
        toasts.addToast({
          title: 'Failed to create item',
          tone: 'negative',
          message: error.message
        });
      } else {
        toasts.addToast({
          title: data.item[list.labelField] || data.item.id,
          tone: 'positive',
          message: 'Saved successfully'
        });
        onCreate(dataGetter.makeDataGetter(data, errors).get('item'));
      }
    }).catch(err => {
      toasts.addToast({
        title: 'Failed to update item',
        tone: 'negative',
        message: err.message
      });
    });
  };

  return core.jsx(core.Stack, {
    gap: "xlarge"
  }, error && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: error === null || error === void 0 ? void 0 : error.networkError,
    errors: error === null || error === void 0 ? void 0 : error.graphQLErrors
  }), core.jsx(Fields.Fields, {
    fieldModes: null,
    fields: fields,
    forceValidation: forceValidation,
    invalidFields: invalidFields,
    onChange: setValue,
    value: value
  }), core.jsx(core.Stack, {
    gap: "small",
    across: true
  }, core.jsx(button.Button, {
    isLoading: loading,
    size: "small",
    tone: "positive",
    weight: "bold",
    onClick: onCreateClick
  }, "Create ", list.singular), core.jsx(button.Button, {
    size: "small",
    weight: "none",
    onClick: onCancel
  }, "Cancel")));
}

const _excluded = ["mode"];
const CardContainer = core.forwardRefWithAs((_ref, ref) => {
  let {
    mode = 'view'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    tones
  } = core.useTheme();
  const tone = tones[mode === 'edit' ? 'active' : mode === 'create' ? 'positive' : 'passive'];
  return core.jsx(core.Box, _extends({
    ref: ref,
    paddingLeft: "xlarge",
    css: {
      position: 'relative',
      ':before': {
        content: '" "',
        backgroundColor: tone.border,
        borderRadius: 4,
        width: 4,
        position: 'absolute',
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 1
      }
    }
  }, props));
});
function Cards({
  localList,
  field,
  foreignList,
  id,
  value,
  onChange,
  forceValidation
}) {
  var _field$display$inline;

  let selectedFields = [...new Set([...field.display.cardFields, ...(((_field$display$inline = field.display.inlineEdit) === null || _field$display$inline === void 0 ? void 0 : _field$display$inline.fields) || [])])].map(fieldPath => {
    return foreignList.fields[fieldPath].controller.graphqlSelection;
  }).join('\n');

  if (!field.display.cardFields.includes('id')) {
    selectedFields += '\nid';
  }

  if (!field.display.cardFields.includes(foreignList.labelField) && foreignList.labelField !== 'id') {
    selectedFields += `\n${foreignList.labelField}`;
  }

  const {
    items,
    setItems,
    state: itemsState
  } = useItemState({
    selectedFields,
    localList,
    id,
    field
  });
  const client$1 = client.useApolloClient();
  const [isLoadingLazyItems, setIsLoadingLazyItems] = React.useState(false);
  const [showConnectItems, setShowConnectItems] = React.useState(false);
  const [hideConnectItemsLabel, setHideConnectItemsLabel] = React.useState('Cancel');
  const editRef = React.useRef(null);
  const isMountedRef = React.useRef(false);
  React.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  });
  React.useEffect(() => {
    if (value.itemsBeingEdited) {
      var _editRef$current;

      editRef === null || editRef === void 0 ? void 0 : (_editRef$current = editRef.current) === null || _editRef$current === void 0 ? void 0 : _editRef$current.focus();
    }
  }, [value]);

  if (itemsState.kind === 'loading') {
    return core.jsx("div", null, core.jsx(loading.LoadingDots, {
      label: `Loading items for ${field.label} field`
    }));
  }

  if (itemsState.kind === 'error') {
    return core.jsx("span", {
      css: {
        color: 'red'
      }
    }, itemsState.message);
  }

  return core.jsx(core.Stack, {
    gap: "xlarge"
  }, core.jsx(core.Stack, {
    as: "ul",
    gap: "xlarge",
    css: {
      padding: 0,
      marginBottom: 0,
      li: {
        listStyle: 'none'
      }
    }
  }, [...value.currentIds].map((id, index) => {
    const itemGetter = items[id];
    const isEditMode = !!(onChange !== undefined) && value.itemsBeingEdited.has(id);
    return core.jsx(CardContainer, {
      role: "status",
      mode: isEditMode ? 'edit' : 'view'
    }, core.jsx(core.VisuallyHidden, {
      as: "h2"
    }, `${field.label} ${index + 1} ${isEditMode ? 'edit' : 'view'} mode`), isEditMode ? core.jsx(InlineEdit, {
      list: foreignList,
      fields: field.display.inlineEdit.fields,
      onSave: newItemGetter => {
        setItems(_objectSpread(_objectSpread({}, items), {}, {
          [id]: newItemGetter
        }));
        const itemsBeingEdited = new Set(value.itemsBeingEdited);
        itemsBeingEdited.delete(id);
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          itemsBeingEdited
        }));
      },
      selectedFields: selectedFields,
      itemGetter: itemGetter,
      onCancel: () => {
        const itemsBeingEdited = new Set(value.itemsBeingEdited);
        itemsBeingEdited.delete(id);
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          itemsBeingEdited
        }));
      }
    }) : core.jsx(React.Fragment, null, core.jsx(core.Stack, {
      gap: "xlarge"
    }, field.display.cardFields.map(fieldPath => {
      const field = foreignList.fields[fieldPath];
      const itemForField = {};

      for (const graphqlField of getRootGraphQLFieldsFromFieldController.getRootGraphQLFieldsFromFieldController(field.controller)) {
        const fieldGetter = itemGetter.get(graphqlField);

        if (fieldGetter.errors) {
          const errorMessage = fieldGetter.errors[0].message;
          return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), errorMessage);
        }

        itemForField[graphqlField] = fieldGetter.data;
      }

      return core.jsx(field.views.CardValue, {
        key: fieldPath,
        field: field.controller,
        item: itemForField
      });
    })), core.jsx(core.Stack, {
      across: true,
      gap: "small",
      marginTop: "xlarge"
    }, field.display.inlineEdit && onChange !== undefined && core.jsx(button.Button, {
      size: "small",
      disabled: onChange === undefined,
      onClick: () => {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          itemsBeingEdited: new Set([...value.itemsBeingEdited, id])
        }));
      },
      tone: "active"
    }, "Edit"), field.display.removeMode === 'disconnect' && onChange !== undefined && core.jsx(tooltip.Tooltip, {
      content: "This item will not be deleted. It will only be removed from this field."
    }, props => core.jsx(button.Button, _extends({
      size: "small",
      disabled: onChange === undefined,
      onClick: () => {
        const currentIds = new Set(value.currentIds);
        currentIds.delete(id);
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          currentIds
        }));
      }
    }, props, {
      tone: "negative"
    }), "Remove")), field.display.linkToItem && core.jsx(button.Button, {
      size: "small",
      weight: "link",
      tone: "active",
      css: {
        textDecoration: 'none'
      },
      as: adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link,
      href: `/${foreignList.path}/${id}`
    }, "View ", foreignList.singular, " details"))));
  })), onChange === undefined ? null : field.display.inlineConnect && showConnectItems ? core.jsx(CardContainer, {
    mode: "edit"
  }, core.jsx(core.Stack, {
    gap: "small",
    marginY: "medium",
    across: true,
    css: {
      width: '100%',
      justifyContent: 'space-between',
      'div:first-of-type': {
        flex: '2'
      }
    }
  }, core.jsx(fields_types_relationship_views_RelationshipSelect_dist_keystoneNextKeystoneFieldsTypesRelationshipViewsRelationshipSelect.RelationshipSelect, {
    autoFocus: true,
    controlShouldRenderValue: isLoadingLazyItems,
    isDisabled: onChange === undefined,
    list: foreignList,
    isLoading: isLoadingLazyItems,
    placeholder: `Select a ${foreignList.singular}`,
    portalMenu: true,
    state: {
      kind: 'many',

      async onChange(options) {
        // TODO: maybe use the extraSelection prop on RelationshipSelect here
        const itemsToFetchAndConnect = [];
        options.forEach(item => {
          if (!value.currentIds.has(item.id)) {
            itemsToFetchAndConnect.push(item.id);
          }
        });

        if (itemsToFetchAndConnect.length) {
          try {
            const {
              data,
              errors
            } = await client$1.query({
              query: client.gql`query ($ids: [ID!]!) {
                      items: ${foreignList.gqlNames.listQueryName}(where: { id: { in: $ids }}) {
                        ${selectedFields}
                      }
                    }`,
              variables: {
                ids: itemsToFetchAndConnect
              }
            });

            if (isMountedRef.current) {
              const dataGetters = dataGetter.makeDataGetter(data, errors);
              const itemsDataGetter = dataGetters.get('items');

              let newItems = _objectSpread({}, items);

              let newCurrentIds = field.many ? new Set(value.currentIds) : new Set();

              if (Array.isArray(itemsDataGetter.data)) {
                itemsDataGetter.data.forEach((item, i) => {
                  if ((item === null || item === void 0 ? void 0 : item.id) != null) {
                    newCurrentIds.add(item.id);
                    newItems[item.id] = itemsDataGetter.get(i);
                  }
                });
              }

              if (newCurrentIds.size) {
                setItems(newItems);
                onChange(_objectSpread(_objectSpread({}, value), {}, {
                  currentIds: newCurrentIds
                }));
                setHideConnectItemsLabel('Done');
              }
            }
          } finally {
            if (isMountedRef.current) {
              setIsLoadingLazyItems(false);
            }
          }
        }
      },

      value: (() => {
        let options = [];
        Object.keys(items).forEach(id => {
          if (value.currentIds.has(id)) {
            options.push({
              id,
              label: id
            });
          }
        });
        return options;
      })()
    }
  }), core.jsx(button.Button, {
    onClick: () => setShowConnectItems(false)
  }, hideConnectItemsLabel))) : value.itemBeingCreated ? core.jsx(CardContainer, {
    mode: "create"
  }, core.jsx(InlineCreate, {
    selectedFields: selectedFields,
    fields: field.display.inlineCreate.fields,
    list: foreignList,
    onCancel: () => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        itemBeingCreated: false
      }));
    },
    onCreate: itemGetter => {
      const id = itemGetter.data.id;
      setItems(_objectSpread(_objectSpread({}, items), {}, {
        [id]: itemGetter
      }));
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        itemBeingCreated: false,
        currentIds: field.many ? new Set([...value.currentIds, id]) : new Set([id])
      }));
    }
  })) : field.display.inlineCreate || field.display.inlineConnect ? core.jsx(CardContainer, {
    mode: "create"
  }, core.jsx(core.Stack, {
    gap: "small",
    marginTop: "medium",
    across: true
  }, field.display.inlineCreate && core.jsx(button.Button, {
    size: "small",
    disabled: onChange === undefined,
    tone: "positive",
    onClick: () => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        itemBeingCreated: true
      }));
    }
  }, "Create ", foreignList.singular), field.display.inlineConnect && core.jsx(button.Button, {
    size: "small",
    weight: "none",
    tone: "passive",
    onClick: () => {
      setShowConnectItems(true);
      setHideConnectItemsLabel('Cancel');
    }
  }, "Link existing ", foreignList.singular))) : null, forceValidation && core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, "You must finish creating and editing any related ", foreignList.label.toLowerCase(), " before saving the ", localList.singular.toLowerCase()));
}

function LinkToRelatedItems({
  itemId,
  isDoubleSided,
  value,
  list
}) {
  var _value$value;

  function constructQuery({
    isDoubleSided,
    itemId,
    value
  }) {
    if (isDoubleSided && itemId) {
      return `!assignedTo_matches="${itemId}"`;
    }

    return `!id_in="${(value === null || value === void 0 ? void 0 : value.value).slice(0, 100).map(({
      id
    }) => id).join(',')}"`;
  }

  const commonProps = {
    size: 'small',
    tone: 'active',
    weight: 'link'
  };

  if (value.kind === 'many') {
    const query = constructQuery({
      isDoubleSided,
      value,
      itemId
    });
    return core.jsx(button.Button, _extends({}, commonProps, {
      as: adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link,
      href: `/${list.path}?${query}`
    }), "View related ", list.plural);
  }

  return core.jsx(button.Button, _extends({}, commonProps, {
    as: adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link,
    href: `/${list.path}/${(_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.id}`
  }), "View ", list.singular, " details");
}

const RelationshipLinkButton = ({
  href,
  children
}) => core.jsx(button.Button, {
  css: {
    padding: 0,
    height: 'auto'
  },
  weight: "link",
  tone: "active",
  as: adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link,
  href: href
}, children);

const RelationshipDisplay = ({
  list,
  value
}) => {
  if (value.kind === 'many') {
    if (value.value.length) {
      return core.jsx(core.Inline, {
        gap: "small"
      }, value.value.map(i => core.jsx(RelationshipLinkButton, {
        href: `/${list.path}/${i.id}`
      }, i.label)));
    } else {
      return core.jsx("div", null, "(No ", list.plural, ")");
    }
  } else {
    if (value.value) {
      return core.jsx(RelationshipLinkButton, {
        href: `/${list.path}/${value.value.id}`
      }, value.value.label);
    } else {
      return core.jsx("div", null, "(No ", list.singular, ")");
    }
  }
};

const Field = ({
  field,
  autoFocus,
  value,
  onChange,
  forceValidation
}) => {
  const keystone = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useKeystone();
  const foreignList = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(field.refListKey);
  const localList = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(field.listKey);
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(false);

  if (value.kind === 'cards-view') {
    return core.jsx(fields.FieldContainer, {
      as: "fieldset"
    }, core.jsx(fields.FieldLegend, null, field.label), core.jsx(Cards, {
      forceValidation: forceValidation,
      field: field,
      id: value.id,
      value: value,
      onChange: onChange,
      foreignList: foreignList,
      localList: localList
    }));
  }

  if (value.kind === 'count') {
    return core.jsx(core.Stack, {
      as: "fieldset",
      gap: "medium"
    }, core.jsx(fields.FieldLegend, null, field.label), core.jsx("div", null, value.count === 1 ? `There is 1 ${foreignList.singular} ` : `There are ${value.count} ${foreignList.plural} `, "linked to this ", localList.singular));
  }

  return core.jsx(fields.FieldContainer, {
    as: "fieldset"
  }, core.jsx(fields.FieldLabel, {
    as: "legend"
  }, field.label), onChange ? core.jsx(React.Fragment, null, core.jsx(core.Stack, {
    gap: "medium"
  }, core.jsx(fields_types_relationship_views_RelationshipSelect_dist_keystoneNextKeystoneFieldsTypesRelationshipViewsRelationshipSelect.RelationshipSelect, {
    controlShouldRenderValue: true,
    autoFocus: autoFocus,
    isDisabled: onChange === undefined,
    list: foreignList,
    portalMenu: true,
    state: value.kind === 'many' ? {
      kind: 'many',
      value: value.value,

      onChange(newItems) {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          value: newItems
        }));
      }

    } : {
      kind: 'one',
      value: value.value,

      onChange(newVal) {
        if (value.kind === 'one') {
          onChange(_objectSpread(_objectSpread({}, value), {}, {
            value: newVal
          }));
        }
      }

    }
  }), core.jsx(core.Stack, {
    across: true,
    gap: "small"
  }, !field.hideCreate && core.jsx(button.Button, {
    size: "small",
    disabled: isDrawerOpen,
    onClick: () => {
      setIsDrawerOpen(true);
    }
  }, "Create related ", foreignList.singular), keystone.authenticatedItem.state === 'authenticated' && keystone.authenticatedItem.listKey === field.refListKey && core.jsx(button.Button, {
    size: "small",
    isDisabled: onChange === undefined,
    onClick: () => {
      if (keystone.authenticatedItem.state === 'authenticated') {
        const val = {
          label: keystone.authenticatedItem.label,
          id: keystone.authenticatedItem.id
        };

        if (value.kind === 'many') {
          onChange(_objectSpread(_objectSpread({}, value), {}, {
            value: [...value.value, val]
          }));
        } else {
          onChange(_objectSpread(_objectSpread({}, value), {}, {
            value: val
          }));
        }
      }
    }
  }, value.kind === 'many' ? 'Add ' : 'Set as ', keystone.authenticatedItem.label), !!(value.kind === 'many' ? value.value.length : value.kind === 'one' && value.value) && core.jsx(LinkToRelatedItems, {
    itemId: value.id,
    isDoubleSided: !!field.refFieldKey,
    list: foreignList,
    value: value
  }))), core.jsx(modals.DrawerController, {
    isOpen: isDrawerOpen
  }, core.jsx(CreateItemDrawer.CreateItemDrawer, {
    listKey: foreignList.key,
    onClose: () => {
      setIsDrawerOpen(false);
    },
    onCreate: val => {
      setIsDrawerOpen(false);

      if (value.kind === 'many') {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          value: [...value.value, val]
        }));
      } else if (value.kind === 'one') {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          value: val
        }));
      }
    }
  }))) : core.jsx(RelationshipDisplay, {
    value: value,
    list: foreignList
  }));
};
const Cell = ({
  field,
  item
}) => {
  const list = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(field.refListKey);
  const {
    colors
  } = core.useTheme();

  if (field.display.mode === 'count') {
    var _item$;

    const count = (_item$ = item[`${field.path}Count`]) !== null && _item$ !== void 0 ? _item$ : 0;
    return core.jsx(CellContainer.CellContainer, null, count, " ", count === 1 ? list.singular : list.plural);
  }

  const data = item[field.path];
  const items = (Array.isArray(data) ? data : [data]).filter(item => item);
  const displayItems = items.length < 5 ? items : items.slice(0, 3);
  const overflow = items.length < 5 ? 0 : items.length - 3;
  const styles = {
    color: colors.foreground,
    textDecoration: 'none',
    ':hover': {
      textDecoration: 'underline'
    }
  };
  return core.jsx(CellContainer.CellContainer, null, displayItems.map((item, index) => core.jsx(React.Fragment, {
    key: item.id
  }, !!index ? ', ' : '', core.jsx(adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link, {
    href: `/${list.path}/[id]`,
    as: `/${list.path}/${item.id}`,
    css: styles
  }, item.label || item.id))), overflow ? `, and ${overflow} more` : null);
};
const CardValue = ({
  field,
  item
}) => {
  const list = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(field.refListKey);
  const data = item[field.path];
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), (Array.isArray(data) ? data : [data]).filter(item => item).map((item, index) => core.jsx(React.Fragment, {
    key: item.id
  }, !!index ? ', ' : '', core.jsx(adminUi_router_dist_keystoneNextKeystoneAdminUiRouter.Link, {
    href: `/${list.path}/[id]`,
    as: `/${list.path}/${item.id}`
  }, item.label || item.id))));
};
const controller = config => {
  return {
    refFieldKey: config.fieldMeta.refFieldKey,
    many: config.fieldMeta.many,
    listKey: config.listKey,
    path: config.path,
    label: config.label,
    display: config.fieldMeta.displayMode === 'cards' ? {
      mode: 'cards',
      cardFields: config.fieldMeta.cardFields,
      inlineCreate: config.fieldMeta.inlineCreate,
      inlineEdit: config.fieldMeta.inlineEdit,
      linkToItem: config.fieldMeta.linkToItem,
      removeMode: config.fieldMeta.removeMode,
      inlineConnect: config.fieldMeta.inlineConnect
    } : config.fieldMeta.displayMode === 'count' ? {
      mode: 'count'
    } : {
      mode: 'select',
      refLabelField: config.fieldMeta.refLabelField
    },
    refListKey: config.fieldMeta.refListKey,
    graphqlSelection: config.fieldMeta.displayMode === 'cards' ? `${config.path} {
            id
            label: ${config.fieldMeta.refLabelField}
          }` : config.fieldMeta.displayMode === 'count' ? `${config.path}Count` : `${config.path} {
              id
              label: ${config.fieldMeta.refLabelField}
            }`,
    hideCreate: config.fieldMeta.hideCreate,
    defaultValue: config.fieldMeta.many ? {
      id: null,
      kind: 'many',
      initialValue: [],
      value: []
    } : {
      id: null,
      kind: 'one',
      value: null,
      initialValue: null
    },
    deserialize: data => {
      if (config.fieldMeta.displayMode === 'count') {
        var _data$;

        return {
          id: data.id,
          kind: 'count',
          count: (_data$ = data[`${config.path}Count`]) !== null && _data$ !== void 0 ? _data$ : 0
        };
      }

      if (config.fieldMeta.displayMode === 'cards') {
        const initialIds = new Set((Array.isArray(data[config.path]) ? data[config.path] : data[config.path] ? [data[config.path]] : []).map(x => x.id));
        return {
          kind: 'cards-view',
          id: data.id,
          itemsBeingEdited: new Set(),
          itemBeingCreated: false,
          initialIds,
          currentIds: initialIds
        };
      }

      if (config.fieldMeta.many) {
        let value = (data[config.path] || []).map(x => ({
          id: x.id,
          label: x.label || x.id
        }));
        return {
          kind: 'many',
          id: data.id,
          initialValue: value,
          value
        };
      }

      let value = data[config.path];

      if (value) {
        value = {
          id: value.id,
          label: value.label || value.id
        };
      }

      return {
        kind: 'one',
        id: data.id,
        value,
        initialValue: value
      };
    },
    filter: {
      Filter: ({
        onChange,
        value
      }) => {
        const foreignList = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(config.fieldMeta.refListKey);
        const {
          filterValues,
          loading
        } = useRelationshipFilterValues({
          value,
          list: foreignList
        });
        const state = {
          kind: 'many',
          value: filterValues,

          onChange(newItems) {
            onChange(newItems.map(item => item.id).join(','));
          }

        };
        return core.jsx(fields_types_relationship_views_RelationshipSelect_dist_keystoneNextKeystoneFieldsTypesRelationshipViewsRelationshipSelect.RelationshipSelect, {
          controlShouldRenderValue: true,
          list: foreignList,
          isLoading: loading,
          isDisabled: onChange === undefined,
          state: state
        });
      },
      graphql: ({
        value
      }) => {
        const foreignIds = getForeignIds(value);

        if (config.fieldMeta.many) {
          return {
            [config.path]: {
              some: {
                id: {
                  in: foreignIds
                }
              }
            }
          };
        }

        return {
          [config.path]: {
            id: {
              in: foreignIds
            }
          }
        };
      },

      Label({
        value
      }) {
        const foreignList = adminUi_context_dist_keystoneNextKeystoneAdminUiContext.useList(config.fieldMeta.refListKey);
        const {
          filterValues
        } = useRelationshipFilterValues({
          value,
          list: foreignList
        });

        if (!filterValues.length) {
          return `has no value`;
        }

        if (filterValues.length > 1) {
          const values = filterValues.map(i => i.label).join(', ');
          return `is in [${values}]`;
        }

        const optionLabel = filterValues[0].label;
        return `is ${optionLabel}`;
      },

      types: {
        matches: {
          label: 'Matches',
          initialValue: ''
        }
      }
    },

    validate(value) {
      return value.kind !== 'cards-view' || value.itemsBeingEdited.size === 0 && !value.itemBeingCreated;
    },

    serialize: state => {
      if (state.kind === 'many') {
        const newAllIds = new Set(state.value.map(x => x.id));
        const initialIds = new Set(state.initialValue.map(x => x.id));
        let disconnect = state.initialValue.filter(x => !newAllIds.has(x.id)).map(x => ({
          id: x.id
        }));
        let connect = state.value.filter(x => !initialIds.has(x.id)).map(x => ({
          id: x.id
        }));

        if (disconnect.length || connect.length) {
          let output = {};

          if (disconnect.length) {
            output.disconnect = disconnect;
          }

          if (connect.length) {
            output.connect = connect;
          }

          return {
            [config.path]: output
          };
        }
      } else if (state.kind === 'one') {
        var _state$initialValue;

        if (state.initialValue && !state.value) {
          return {
            [config.path]: {
              disconnect: true
            }
          };
        } else if (state.value && state.value.id !== ((_state$initialValue = state.initialValue) === null || _state$initialValue === void 0 ? void 0 : _state$initialValue.id)) {
          return {
            [config.path]: {
              connect: {
                id: state.value.id
              }
            }
          };
        }
      } else if (state.kind === 'cards-view') {
        let disconnect = [...state.initialIds].filter(id => !state.currentIds.has(id)).map(id => ({
          id
        }));
        let connect = [...state.currentIds].filter(id => !state.initialIds.has(id)).map(id => ({
          id
        }));

        if (config.fieldMeta.many) {
          if (disconnect.length || connect.length) {
            return {
              [config.path]: {
                connect: connect.length ? connect : undefined,
                disconnect: disconnect.length ? disconnect : undefined
              }
            };
          }
        } else if (connect.length) {
          return {
            [config.path]: {
              connect: connect[0]
            }
          };
        } else if (disconnect.length) {
          return {
            [config.path]: {
              disconnect: true
            }
          };
        }
      }

      return {};
    }
  };
};

function useRelationshipFilterValues({
  value,
  list
}) {
  var _data$items;

  const foreignIds = getForeignIds(value);
  const where = {
    id: {
      in: foreignIds
    }
  };
  const query = client.gql`
    query FOREIGNLIST_QUERY($where: ${list.gqlNames.whereInputName}!) {
      items: ${list.gqlNames.listQueryName}(where: $where) {
        id 
        ${list.labelField}
      }
    }
  `;
  const {
    data,
    loading
  } = client.useQuery(query, {
    variables: {
      where
    }
  });
  return {
    filterValues: (data === null || data === void 0 ? void 0 : (_data$items = data.items) === null || _data$items === void 0 ? void 0 : _data$items.map(item => {
      return {
        id: item.id,
        label: item[list.labelField] || item.id
      };
    })) || foreignIds.map(f => ({
      label: f,
      id: f
    })),
    loading: loading
  };
}

function getForeignIds(value) {
  if (typeof value === 'string' && value.length > 0) {
    return value.split(',');
  }

  return [];
}

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-relationship-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.dev.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.dev.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var React = __webpack_require__(/*! react */ "react");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var segmentedControl = __webpack_require__(/*! @keystone-ui/segmented-control */ "@keystone-ui/segmented-control");
var button = __webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
var CellLink = __webpack_require__(/*! ../../../../../dist/CellLink-dc41c877.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! ../../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

const Field = ({
  field,
  value,
  onChange,
  autoFocus,
  forceValidation
}) => {
  const [hasChanged, setHasChanged] = React.useState(false);
  const validationMessage = (hasChanged || forceValidation) && !validate(value, field.isRequired) ? core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, field.label, " is required") : null;
  return core.jsx(fields.FieldContainer, {
    as: field.displayMode === 'select' ? 'div' : 'fieldset'
  }, field.displayMode === 'select' ? core.jsx(React.Fragment, null, core.jsx(fields.FieldLabel, {
    htmlFor: field.path
  }, field.label), core.jsx(fields.Select, {
    id: field.path,
    isClearable: true,
    autoFocus: autoFocus,
    options: field.options,
    isDisabled: onChange === undefined,
    onChange: newVal => {
      onChange === null || onChange === void 0 ? void 0 : onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: newVal
      }));
      setHasChanged(true);
    },
    value: value.value,
    portalMenu: true
  }), validationMessage) : core.jsx(React.Fragment, null, core.jsx(fields.FieldLabel, {
    as: "legend"
  }, field.label), core.jsx(core.Stack, {
    across: true,
    gap: "small",
    align: "center"
  }, core.jsx(segmentedControl.SegmentedControl, {
    segments: field.options.map(x => x.label),
    selectedIndex: value.value ? field.options.findIndex(x => x.value === value.value.value) : undefined,
    onChange: index => {
      onChange === null || onChange === void 0 ? void 0 : onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: field.options[index]
      }));
      setHasChanged(true);
    }
  }), value.value !== null && onChange !== undefined && core.jsx(button.Button, {
    onClick: () => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: null
      }));
      setHasChanged(true);
    }
  }, "Clear")), validationMessage));
};
const Cell = ({
  item,
  field,
  linkTo
}) => {
  var _field$options$find;

  let value = item[field.path] + '';
  const label = (_field$options$find = field.options.find(x => x.value === value)) === null || _field$options$find === void 0 ? void 0 : _field$options$find.label;
  return linkTo ? core.jsx(CellLink.CellLink, linkTo, label) : core.jsx(CellContainer.CellContainer, null, label);
};
Cell.supportsLinkTo = true;
const CardValue = ({
  item,
  field
}) => {
  var _field$options$find2;

  let value = item[field.path] + '';
  const label = (_field$options$find2 = field.options.find(x => x.value === value)) === null || _field$options$find2 === void 0 ? void 0 : _field$options$find2.label;
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), label);
};

function validate(value, isRequired) {
  if (isRequired) {
    // if you got null initially on the update screen, we want to allow saving
    // since the user probably doesn't have read access control
    if (value.kind === 'update' && value.initial === null) {
      return true;
    }

    return value.value !== null;
  }

  return true;
}

const controller = config => {
  var _config$fieldMeta$def, _optionsWithStringVal;

  const optionsWithStringValues = config.fieldMeta.options.map(x => ({
    label: x.label,
    value: x.value.toString()
  })); // Transform from string value to type appropriate value

  const t = v => v === null ? null : config.fieldMeta.type === 'integer' ? parseInt(v) : v;

  const stringifiedDefault = (_config$fieldMeta$def = config.fieldMeta.defaultValue) === null || _config$fieldMeta$def === void 0 ? void 0 : _config$fieldMeta$def.toString();
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    defaultValue: {
      kind: 'create',
      value: (_optionsWithStringVal = optionsWithStringValues.find(x => x.value === stringifiedDefault)) !== null && _optionsWithStringVal !== void 0 ? _optionsWithStringVal : null
    },
    type: config.fieldMeta.type,
    displayMode: config.fieldMeta.displayMode,
    isRequired: config.fieldMeta.isRequired,
    options: optionsWithStringValues,
    deserialize: data => {
      for (const option of config.fieldMeta.options) {
        if (option.value === data[config.path]) {
          const stringifiedOption = {
            label: option.label,
            value: option.value.toString()
          };
          return {
            kind: 'update',
            initial: stringifiedOption,
            value: stringifiedOption
          };
        }
      }

      return {
        kind: 'update',
        initial: null,
        value: null
      };
    },
    serialize: value => {
      var _value$value$value, _value$value;

      return {
        [config.path]: t((_value$value$value = (_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.value) !== null && _value$value$value !== void 0 ? _value$value$value : null)
      };
    },
    validate: value => validate(value, config.fieldMeta.isRequired),
    filter: {
      Filter(props) {
        return core.jsx(fields.MultiSelect, {
          onChange: props.onChange,
          options: optionsWithStringValues,
          value: props.value,
          autoFocus: true
        });
      },

      graphql: ({
        type,
        value: options
      }) => ({
        [config.path]: {
          [type === 'not_matches' ? 'notIn' : 'in']: options.map(x => t(x.value))
        }
      }),

      Label({
        type,
        value
      }) {
        if (!value.length) {
          return type === 'not_matches' ? `is set` : `has no value`;
        }

        if (value.length > 1) {
          const values = value.map(i => i.label).join(', ');
          return type === 'not_matches' ? `is not in [${values}]` : `is in [${values}]`;
        }

        const optionLabel = value[0].label;
        return type === 'not_matches' ? `is not ${optionLabel}` : `is ${optionLabel}`;
      },

      types: {
        matches: {
          label: 'Matches',
          initialValue: []
        },
        not_matches: {
          label: 'Does not match',
          initialValue: []
        }
      }
    }
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-select-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.dev.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.dev.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var React = __webpack_require__(/*! react */ "react");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
var CellLink = __webpack_require__(/*! ../../../../../dist/CellLink-dc41c877.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
__webpack_require__(/*! ../../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

const Field = ({
  field,
  value,
  onChange,
  autoFocus,
  forceValidation
}) => {
  const {
    typography,
    fields: fields$1
  } = core.useTheme();
  const [shouldShowErrors, setShouldShowErrors] = React.useState(false);
  const validationMessages = validate(value, field.validation, field.label);
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), onChange ? core.jsx(core.Stack, {
    gap: "small"
  }, field.displayMode === 'textarea' ? core.jsx(fields.TextArea, {
    id: field.path,
    autoFocus: autoFocus,
    onChange: event => onChange(_objectSpread(_objectSpread({}, value), {}, {
      inner: {
        kind: 'value',
        value: event.target.value
      }
    })),
    value: value.inner.kind === 'null' ? '' : value.inner.value,
    disabled: value.inner.kind === 'null',
    onBlur: () => {
      setShouldShowErrors(true);
    }
  }) : core.jsx(fields.TextInput, {
    id: field.path,
    autoFocus: autoFocus,
    onChange: event => onChange(_objectSpread(_objectSpread({}, value), {}, {
      inner: {
        kind: 'value',
        value: event.target.value
      }
    })),
    value: value.inner.kind === 'null' ? '' : value.inner.value,
    disabled: value.inner.kind === 'null',
    onBlur: () => {
      setShouldShowErrors(true);
    }
  }), field.isNullable && core.jsx(fields.Checkbox, {
    autoFocus: autoFocus,
    disabled: onChange === undefined,
    onChange: () => {
      if (value.inner.kind === 'value') {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          inner: {
            kind: 'null',
            prev: value.inner.value
          }
        }));
      } else {
        onChange(_objectSpread(_objectSpread({}, value), {}, {
          inner: {
            kind: 'value',
            value: value.inner.prev
          }
        }));
      }
    },
    checked: value.inner.kind === 'null'
  }, core.jsx("span", {
    css: {
      fontWeight: typography.fontWeight.semibold,
      color: fields$1.labelColor
    }
  }, "Set field as null")), !!validationMessages.length && (shouldShowErrors || forceValidation) && validationMessages.map((message, i) => core.jsx("span", {
    key: i,
    css: {
      color: 'red'
    }
  }, message))) : value.inner.kind === 'null' ? null : value.inner.value);
};
const Cell = ({
  item,
  field,
  linkTo
}) => {
  let value = item[field.path] + '';
  return linkTo ? core.jsx(CellLink.CellLink, linkTo, value) : core.jsx(CellContainer.CellContainer, null, value);
};
Cell.supportsLinkTo = true;
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), item[field.path]);
};

function validate(value, validation, fieldLabel) {
  // if the value is the same as the initial for an update, we don't want to block saving
  // since we're not gonna send it anyway if it's the same
  // and going "fix this thing that is unrelated to the thing you're doing" is bad
  // and also bc it could be null bc of read access control
  if (value.kind === 'update' && (value.initial.kind === 'null' && value.inner.kind === 'null' || value.initial.kind === 'value' && value.inner.kind === 'value' && value.inner.value === value.initial.value)) {
    return [];
  }

  if (value.inner.kind === 'null') {
    if (validation.isRequired) {
      return [`${fieldLabel} is required`];
    }

    return [];
  }

  const val = value.inner.value;
  let messages = [];

  if (validation.length.min !== null && val.length < validation.length.min) {
    if (validation.length.min === 1) {
      messages.push(`${fieldLabel} must not be empty`);
    } else {
      messages.push(`${fieldLabel} must be at least ${validation.length.min} characters long`);
    }
  }

  if (validation.length.max !== null && val.length > validation.length.max) {
    messages.push(`${fieldLabel} must be no longer than ${validation.length.min} characters`);
  }

  if (validation.match && !validation.match.regex.test(val)) {
    messages.push(validation.match.explanation || `${fieldLabel} must match ${validation.match.regex}`);
  }

  return messages;
}

function deserializeTextValue(value) {
  if (value === null) {
    return {
      kind: 'null',
      prev: ''
    };
  }

  return {
    kind: 'value',
    value
  };
}

const controller = config => {
  const validation = {
    isRequired: config.fieldMeta.validation.isRequired,
    length: config.fieldMeta.validation.length,
    match: config.fieldMeta.validation.match ? {
      regex: new RegExp(config.fieldMeta.validation.match.regex.source, config.fieldMeta.validation.match.regex.flags),
      explanation: config.fieldMeta.validation.match.explanation
    } : null
  };
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    defaultValue: {
      kind: 'create',
      inner: deserializeTextValue(config.fieldMeta.defaultValue)
    },
    displayMode: config.fieldMeta.displayMode,
    isNullable: config.fieldMeta.isNullable,
    deserialize: data => {
      const inner = deserializeTextValue(data[config.path]);
      return {
        kind: 'update',
        inner,
        initial: inner
      };
    },
    serialize: value => ({
      [config.path]: value.inner.kind === 'null' ? null : value.inner.value
    }),
    validation,
    validate: val => validate(val, validation, config.label).length === 0,
    filter: {
      Filter(props) {
        return core.jsx(fields.TextInput, {
          onChange: event => {
            props.onChange(event.target.value);
          },
          value: props.value,
          autoFocus: props.autoFocus
        });
      },

      graphql: ({
        type,
        value
      }) => {
        const isNot = type.startsWith('not_');
        const key = type === 'is_i' || type === 'not_i' ? 'equals' : type.replace(/_i$/, '').replace('not_', '').replace(/_([a-z])/g, (_, char) => char.toUpperCase());
        const filter = {
          [key]: value
        };
        return {
          [config.path]: _objectSpread(_objectSpread({}, isNot ? {
            not: filter
          } : filter), {}, {
            mode: config.fieldMeta.shouldUseModeInsensitive ? 'insensitive' : undefined
          })
        };
      },

      Label({
        label,
        value
      }) {
        return `${label.toLowerCase()}: "${value}"`;
      },

      types: {
        contains_i: {
          label: 'Contains',
          initialValue: ''
        },
        not_contains_i: {
          label: 'Does not contain',
          initialValue: ''
        },
        is_i: {
          label: 'Is exactly',
          initialValue: ''
        },
        not_i: {
          label: 'Is not exactly',
          initialValue: ''
        },
        starts_with_i: {
          label: 'Starts with',
          initialValue: ''
        },
        not_starts_with_i: {
          label: 'Does not start with',
          initialValue: ''
        },
        ends_with_i: {
          label: 'Ends with',
          initialValue: ''
        },
        not_ends_with_i: {
          label: 'Does not end with',
          initialValue: ''
        }
      }
    }
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-text-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.dev.js");
}


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.dev.js":
/*!***************************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.dev.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ "../../node_modules/@babel/runtime/helpers/extends.js");
var _objectSpread = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ "../../node_modules/@babel/runtime/helpers/objectSpread2.js");
var React = __webpack_require__(/*! react */ "react");
var core = __webpack_require__(/*! @keystone-ui/core */ "@keystone-ui/core");
var fields = __webpack_require__(/*! @keystone-ui/fields */ "@keystone-ui/fields");
var CellContainer = __webpack_require__(/*! ../../../../../dist/CellContainer-453254b5.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellContainer-453254b5.cjs.dev.js");
var CellLink = __webpack_require__(/*! ../../../../../dist/CellLink-dc41c877.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/CellLink-dc41c877.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js");
__webpack_require__(/*! @keystone-ui/button */ "@keystone-ui/button");
__webpack_require__(/*! @keystone-ui/icons/icons/AlertTriangleIcon */ "@keystone-ui/icons/icons/AlertTriangleIcon");
__webpack_require__(/*! next/link */ "../../node_modules/next/link.js");
__webpack_require__(/*! @keystone-ui/toast */ "@keystone-ui/toast");
__webpack_require__(/*! @keystone-ui/loading */ "@keystone-ui/loading");
__webpack_require__(/*! @keystone-ui/modals */ "@keystone-ui/modals");
__webpack_require__(/*! apollo-upload-client */ "apollo-upload-client");
__webpack_require__(/*! @emotion/hash */ "@emotion/hash");
__webpack_require__(/*! ../../../../../dist/sqlite-af9e5148.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/sqlite-af9e5148.cjs.dev.js");
__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
__webpack_require__(/*! ../../../../../dist/graphql-ts-schema-fce7a6a8.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/graphql-ts-schema-fce7a6a8.cjs.dev.js");
__webpack_require__(/*! @apollo/client */ "@apollo/client");
__webpack_require__(/*! ../../../../../dist/admin-meta-graphql-9f9a9c11.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/admin-meta-graphql-9f9a9c11.cjs.dev.js");
__webpack_require__(/*! next/router */ "next/router");
__webpack_require__(/*! @keystone-ui/popover */ "@keystone-ui/popover");
__webpack_require__(/*! @keystone-ui/icons/icons/MoreHorizontalIcon */ "@keystone-ui/icons/icons/MoreHorizontalIcon");
__webpack_require__(/*! @keystone-ui/icons/icons/ChevronRightIcon */ "@keystone-ui/icons/icons/ChevronRightIcon");
__webpack_require__(/*! ../../../../../dist/SignoutButton-acdb1554.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/SignoutButton-acdb1554.cjs.dev.js");
__webpack_require__(/*! fast-deep-equal */ "fast-deep-equal");
__webpack_require__(/*! @keystone-ui/notice */ "@keystone-ui/notice");
var utils = __webpack_require__(/*! ../../../../../dist/utils-eff1fd30.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/dist/utils-eff1fd30.cjs.dev.js");
var dateFns = __webpack_require__(/*! date-fns */ "date-fns");
__webpack_require__(/*! ../../../../../admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/admin-ui/router/dist/keystone-next-keystone-admin-ui-router.cjs.dev.js");
__webpack_require__(/*! decimal.js */ "decimal.js");
__webpack_require__(/*! @graphql-tools/schema */ "@graphql-tools/schema");
__webpack_require__(/*! @graphql-ts/schema/api-without-context */ "@graphql-ts/schema/api-without-context");
__webpack_require__(/*! @graphql-ts/schema */ "@graphql-ts/schema");
__webpack_require__(/*! graphql-type-json */ "graphql-type-json");
__webpack_require__(/*! graphql-upload/public/GraphQLUpload.js */ "graphql-upload/public/GraphQLUpload.js");
__webpack_require__(/*! graphql */ "graphql");
__webpack_require__(/*! @graphql-ts/schema/api-with-context */ "@graphql-ts/schema/api-with-context");

const FULL_TIME_PATTERN = 'HH:mm:ss.SSS';

function formatFullTime(date) {
  return dateFns.format(date, FULL_TIME_PATTERN);
}

function formatTime(time) {
  const date = dateFns.parse(time, FULL_TIME_PATTERN, new Date());

  if (date.getMilliseconds() !== 0) {
    return dateFns.format(date, FULL_TIME_PATTERN);
  }

  if (date.getSeconds() !== 0) {
    return dateFns.format(date, 'HH:mm:ss');
  }

  return dateFns.format(date, 'HH:mm');
}
function parseTime(time) {
  for (const pattern of ['H:m:s.SSS', 'H:m:s', 'H:m', 'H']) {
    const parsed = dateFns.parse(time, pattern, new Date());

    if (dateFns.isValid(parsed)) {
      return dateFns.format(parsed, FULL_TIME_PATTERN);
    }
  }

  return undefined;
}
function constructTimestamp({
  dateValue,
  timeValue
}) {
  return new Date(`${dateValue}T${timeValue}`).toISOString();
}
function deconstructTimestamp(value) {
  return {
    dateValue: dateFns.formatISO(new Date(value), {
      representation: 'date'
    }),
    timeValue: {
      kind: 'parsed',
      value: formatFullTime(new Date(value))
    }
  };
}
function formatOutput(value) {
  if (!value) return '';
  const date = new Date(value);
  return date.toLocaleString();
}

const Field = ({
  field,
  value,
  onChange,
  forceValidation
}) => {
  var _value$value$dateValu, _field$fieldMeta$defa;

  const [touchedFirstInput, setTouchedFirstInput] = React.useState(false);
  const [touchedSecondInput, setTouchedSecondInput] = React.useState(false);
  const showValidation = touchedFirstInput && touchedSecondInput || forceValidation;
  const validationMessages = showValidation ? validate(value, field.fieldMeta, field.label) : undefined;
  const timeInputProps = utils.useFormattedInput({
    format({
      value
    }) {
      if (value === null) {
        return '';
      }

      return formatTime(value);
    },

    parse(value) {
      value = value.trim();

      if (value === '') {
        return {
          kind: 'parsed',
          value: null
        };
      }

      const parsed = parseTime(value);

      if (parsed !== undefined) {
        return {
          kind: 'parsed',
          value: parsed
        };
      }

      return value;
    }

  }, {
    value: value.value.timeValue,

    onChange(timeValue) {
      onChange === null || onChange === void 0 ? void 0 : onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: _objectSpread(_objectSpread({}, value.value), {}, {
          timeValue
        })
      }));
    },

    onBlur() {
      setTouchedSecondInput(true);
    }

  });
  return core.jsx(fields.FieldContainer, {
    as: "fieldset"
  }, core.jsx(core.Stack, null, core.jsx(fields.FieldLabel, {
    as: "legend"
  }, field.label), onChange ? core.jsx(core.Inline, {
    gap: "small"
  }, core.jsx(core.Stack, null, core.jsx(fields.DatePicker, {
    onUpdate: date => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: {
          dateValue: date,
          timeValue: typeof value.value.timeValue === 'object' && value.value.timeValue.value === null ? {
            kind: 'parsed',
            value: '00:00:00.000'
          } : value.value.timeValue
        }
      }));
    },
    onClear: () => {
      onChange(_objectSpread(_objectSpread({}, value), {}, {
        value: _objectSpread(_objectSpread({}, value.value), {}, {
          dateValue: null
        })
      }));
    },
    onBlur: () => setTouchedFirstInput(true),
    value: (_value$value$dateValu = value.value.dateValue) !== null && _value$value$dateValu !== void 0 ? _value$value$dateValu : ''
  }), (validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.date) && core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, validationMessages.date)), core.jsx(core.Stack, null, core.jsx(core.VisuallyHidden, {
    as: "label",
    htmlFor: `${field.path}--time-input`
  }, `${field.label} time field`), core.jsx(fields.TextInput, _extends({
    id: `${field.path}--time-input`
  }, timeInputProps, {
    disabled: onChange === undefined,
    placeholder: "00:00"
  })), (validationMessages === null || validationMessages === void 0 ? void 0 : validationMessages.time) && core.jsx(core.Text, {
    color: "red600",
    size: "small"
  }, validationMessages.time))) : value.value.dateValue !== null && typeof value.value.timeValue === 'object' && value.value.timeValue.value !== null && core.jsx(core.Text, null, formatOutput(constructTimestamp({
    dateValue: value.value.dateValue,
    timeValue: value.value.timeValue.value
  }))), (value.kind === 'create' && typeof field.fieldMeta.defaultValue !== 'string' && ((_field$fieldMeta$defa = field.fieldMeta.defaultValue) === null || _field$fieldMeta$defa === void 0 ? void 0 : _field$fieldMeta$defa.kind) === 'now' || field.fieldMeta.updatedAt) && core.jsx(core.Text, null, "When this item is saved, this field will be set to the current date and time")));
};

function validate(value, fieldMeta, label) {
  var _fieldMeta$defaultVal;

  const val = value.value;
  const hasDateValue = val.dateValue !== null;
  const hasTimeValue = typeof val.timeValue === 'string' || typeof val.timeValue.value === 'string';
  const isValueEmpty = !hasDateValue && !hasTimeValue; // if we recieve null initially on the item view and the current value is null,
  // we should always allow saving it because:
  // - the value might be null in the database and we don't want to prevent saving the whole item because of that
  // - we might have null because of an access control error

  if (value.kind === 'update' && value.initial === null && isValueEmpty) {
    return undefined;
  }

  if (value.kind === 'create' && isValueEmpty && (typeof fieldMeta.defaultValue === 'object' && ((_fieldMeta$defaultVal = fieldMeta.defaultValue) === null || _fieldMeta$defaultVal === void 0 ? void 0 : _fieldMeta$defaultVal.kind) === 'now' || fieldMeta.updatedAt)) {
    return undefined;
  }

  if (fieldMeta.isRequired && isValueEmpty) {
    return {
      date: `${label} is required`
    };
  }

  if (hasDateValue && !hasTimeValue) {
    return {
      time: `${label} requires a time to be provided`
    };
  }

  const timeError = typeof val.timeValue === 'string' ? `${label} requires a valid time in the format hh:mm` : undefined;

  if (hasTimeValue && !hasDateValue) {
    return {
      date: `${label} requires a date to be selected`,
      time: timeError
    };
  }

  if (timeError) {
    return {
      time: timeError
    };
  }

  return undefined;
}

const Cell = ({
  item,
  field,
  linkTo
}) => {
  let value = item[field.path];
  return linkTo ? core.jsx(CellLink.CellLink, linkTo, formatOutput(value)) : core.jsx(CellContainer.CellContainer, null, formatOutput(value));
};
Cell.supportsLinkTo = true;
const CardValue = ({
  item,
  field
}) => {
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, null, field.label), formatOutput(item[field.path]));
};
const controller = config => {
  return {
    path: config.path,
    label: config.label,
    graphqlSelection: config.path,
    fieldMeta: config.fieldMeta,
    defaultValue: {
      kind: 'create',
      value: typeof config.fieldMeta.defaultValue === 'string' ? deconstructTimestamp(config.fieldMeta.defaultValue) : {
        dateValue: null,
        timeValue: {
          kind: 'parsed',
          value: null
        }
      }
    },
    deserialize: data => {
      const value = data[config.path];
      return {
        kind: 'update',
        initial: data[config.path],
        value: value ? deconstructTimestamp(value) : {
          dateValue: null,
          timeValue: {
            kind: 'parsed',
            value: null
          }
        }
      };
    },
    serialize: ({
      value: {
        dateValue,
        timeValue
      }
    }) => {
      if (dateValue && typeof timeValue === 'object' && timeValue.value !== null) {
        let formattedDate = constructTimestamp({
          dateValue,
          timeValue: timeValue.value
        });
        return {
          [config.path]: formattedDate
        };
      }

      return {
        [config.path]: null
      };
    },
    validate: value => validate(value, config.fieldMeta, config.label) === undefined
  };
};

exports.CardValue = CardValue;
exports.Cell = Cell;
exports.Field = Field;
exports.controller = controller;


/***/ }),

/***/ "../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.js ***!
  \***********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./keystone-next-keystone-fields-types-timestamp-views.cjs.dev.js */ "../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.dev.js");
}


/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_pages_App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App */ "@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App");
/* harmony import */ var _keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_pages_App__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_pages_App__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_id_field_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view */ "../../node_modules/@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/id-field-view/dist/keystone-next-keystone-___internal-do-not-use-will-break-in-patch-admin-ui-id-field-view.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_id_field_view__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_id_field_view__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_text_views__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/text/views */ "../../node_modules/@keystone-next/keystone/fields/types/text/views/dist/keystone-next-keystone-fields-types-text-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_text_views__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_text_views__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_checkbox_views__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/checkbox/views */ "../../node_modules/@keystone-next/keystone/fields/types/checkbox/views/dist/keystone-next-keystone-fields-types-checkbox-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_checkbox_views__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_checkbox_views__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_password_views__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/password/views */ "../../node_modules/@keystone-next/keystone/fields/types/password/views/dist/keystone-next-keystone-fields-types-password-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_password_views__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_password_views__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_image_views__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/image/views */ "../../node_modules/@keystone-next/keystone/fields/types/image/views/dist/keystone-next-keystone-fields-types-image-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_image_views__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_image_views__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_timestamp_views__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/timestamp/views */ "../../node_modules/@keystone-next/keystone/fields/types/timestamp/views/dist/keystone-next-keystone-fields-types-timestamp-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_timestamp_views__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_timestamp_views__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_relationship_views__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/relationship/views */ "../../node_modules/@keystone-next/keystone/fields/types/relationship/views/dist/keystone-next-keystone-fields-types-relationship-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_relationship_views__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_relationship_views__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _node_modules_keystone_next_fields_document_views__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/fields-document/views */ "../../node_modules/@keystone-next/fields-document/views/dist/keystone-next-fields-document-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_fields_document_views__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_fields_document_views__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_json_views__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/json/views */ "../../node_modules/@keystone-next/keystone/fields/types/json/views/dist/keystone-next-keystone-fields-types-json-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_json_views__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_json_views__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_select_views__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../node_modules/@keystone-next/keystone/fields/types/select/views */ "../../node_modules/@keystone-next/keystone/fields/types/select/views/dist/keystone-next-keystone-fields-types-select-views.cjs.js");
/* harmony import */ var _node_modules_keystone_next_keystone_fields_types_select_views__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_node_modules_keystone_next_keystone_fields_types_select_views__WEBPACK_IMPORTED_MODULE_10__);











var adminConfig = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_pages_App__WEBPACK_IMPORTED_MODULE_0__.getApp)({
  lazyMetadataQuery: {
    "kind": "Document",
    "definitions": [{
      "kind": "OperationDefinition",
      "operation": "query",
      "selectionSet": {
        "kind": "SelectionSet",
        "selections": [{
          "kind": "Field",
          "name": {
            "kind": "Name",
            "value": "keystone",
            "loc": {
              "start": 22,
              "end": 30
            }
          },
          "arguments": [],
          "directives": [],
          "selectionSet": {
            "kind": "SelectionSet",
            "selections": [{
              "kind": "Field",
              "name": {
                "kind": "Name",
                "value": "adminMeta",
                "loc": {
                  "start": 39,
                  "end": 48
                }
              },
              "arguments": [],
              "directives": [],
              "selectionSet": {
                "kind": "SelectionSet",
                "selections": [{
                  "kind": "Field",
                  "name": {
                    "kind": "Name",
                    "value": "lists",
                    "loc": {
                      "start": 59,
                      "end": 64
                    }
                  },
                  "arguments": [],
                  "directives": [],
                  "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [{
                      "kind": "Field",
                      "name": {
                        "kind": "Name",
                        "value": "key",
                        "loc": {
                          "start": 77,
                          "end": 80
                        }
                      },
                      "arguments": [],
                      "directives": [],
                      "loc": {
                        "start": 77,
                        "end": 80
                      }
                    }, {
                      "kind": "Field",
                      "name": {
                        "kind": "Name",
                        "value": "isHidden",
                        "loc": {
                          "start": 91,
                          "end": 99
                        }
                      },
                      "arguments": [],
                      "directives": [],
                      "loc": {
                        "start": 91,
                        "end": 99
                      }
                    }, {
                      "kind": "Field",
                      "name": {
                        "kind": "Name",
                        "value": "fields",
                        "loc": {
                          "start": 110,
                          "end": 116
                        }
                      },
                      "arguments": [],
                      "directives": [],
                      "selectionSet": {
                        "kind": "SelectionSet",
                        "selections": [{
                          "kind": "Field",
                          "name": {
                            "kind": "Name",
                            "value": "path",
                            "loc": {
                              "start": 131,
                              "end": 135
                            }
                          },
                          "arguments": [],
                          "directives": [],
                          "loc": {
                            "start": 131,
                            "end": 135
                          }
                        }, {
                          "kind": "Field",
                          "name": {
                            "kind": "Name",
                            "value": "createView",
                            "loc": {
                              "start": 148,
                              "end": 158
                            }
                          },
                          "arguments": [],
                          "directives": [],
                          "selectionSet": {
                            "kind": "SelectionSet",
                            "selections": [{
                              "kind": "Field",
                              "name": {
                                "kind": "Name",
                                "value": "fieldMode",
                                "loc": {
                                  "start": 175,
                                  "end": 184
                                }
                              },
                              "arguments": [],
                              "directives": [],
                              "loc": {
                                "start": 175,
                                "end": 184
                              }
                            }],
                            "loc": {
                              "start": 159,
                              "end": 198
                            }
                          },
                          "loc": {
                            "start": 148,
                            "end": 198
                          }
                        }],
                        "loc": {
                          "start": 117,
                          "end": 210
                        }
                      },
                      "loc": {
                        "start": 110,
                        "end": 210
                      }
                    }],
                    "loc": {
                      "start": 65,
                      "end": 220
                    }
                  },
                  "loc": {
                    "start": 59,
                    "end": 220
                  }
                }],
                "loc": {
                  "start": 49,
                  "end": 228
                }
              },
              "loc": {
                "start": 39,
                "end": 228
              }
            }],
            "loc": {
              "start": 31,
              "end": 234
            }
          },
          "loc": {
            "start": 22,
            "end": 234
          }
        }, {
          "kind": "Field",
          "name": {
            "kind": "Name",
            "value": "authenticatedItem"
          },
          "selectionSet": {
            "kind": "SelectionSet",
            "selections": [{
              "kind": "InlineFragment",
              "typeCondition": {
                "kind": "NamedType",
                "name": {
                  "kind": "Name",
                  "value": "User"
                }
              },
              "selectionSet": {
                "kind": "SelectionSet",
                "selections": [{
                  "kind": "Field",
                  "name": {
                    "kind": "Name",
                    "value": "id"
                  }
                }, {
                  "kind": "Field",
                  "name": {
                    "kind": "Name",
                    "value": "name"
                  }
                }]
              }
            }]
          }
        }]
      }
    }]
  },
  fieldViews: [_node_modules_keystone_next_keystone_internal_do_not_use_will_break_in_patch_admin_ui_id_field_view__WEBPACK_IMPORTED_MODULE_1__, _node_modules_keystone_next_keystone_fields_types_text_views__WEBPACK_IMPORTED_MODULE_2__, _node_modules_keystone_next_keystone_fields_types_checkbox_views__WEBPACK_IMPORTED_MODULE_3__, _node_modules_keystone_next_keystone_fields_types_password_views__WEBPACK_IMPORTED_MODULE_4__, _node_modules_keystone_next_keystone_fields_types_image_views__WEBPACK_IMPORTED_MODULE_5__, _node_modules_keystone_next_keystone_fields_types_timestamp_views__WEBPACK_IMPORTED_MODULE_6__, _node_modules_keystone_next_keystone_fields_types_relationship_views__WEBPACK_IMPORTED_MODULE_7__, _node_modules_keystone_next_fields_document_views__WEBPACK_IMPORTED_MODULE_8__, _node_modules_keystone_next_keystone_fields_types_json_views__WEBPACK_IMPORTED_MODULE_9__, _node_modules_keystone_next_keystone_fields_types_select_views__WEBPACK_IMPORTED_MODULE_10__],
  adminMetaHash: "437q9b",
  adminConfig: adminConfig,
  apiPath: "/api/graphql"
}));

/***/ }),

/***/ "../../node_modules/next/dist/client/link.js":
/*!***************************************************!*\
  !*** ../../node_modules/next/dist/client/link.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "react"));

var _router = __webpack_require__(/*! ../shared/lib/router/router */ "../../node_modules/next/dist/shared/lib/router/router.js");

var _router1 = __webpack_require__(/*! ./router */ "../../node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "../../node_modules/next/dist/client/use-intersection.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const prefetched = {};

function prefetch(router, href, as, options) {
  if (true) return;
  if (!(0, _router).isLocalURL(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options).catch(err => {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  const curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  const {
    target
  } = event.currentTarget;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  const {
    nodeName
  } = e.currentTarget;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {
    // ignore click for browserâ€™s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null && as.indexOf('#') >= 0) {
    scroll = false;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow,
    locale,
    scroll
  });
}

function Link(props) {
  if (true) {
    function createPropError(args) {
      return new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + ( false ? 0 : ''));
    } // TypeScript trick for type-guarding:


    const requiredPropsGuard = {
      href: true
    };
    const requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(key => {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // TypeScript trick for type-guarding:

    const optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    const optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(key => {
      const valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    const hasWarned = _react.default.useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');
    }
  }

  const p = props.prefetch !== false;
  const router = (0, _router1).useRouter();

  const {
    href,
    as
  } = _react.default.useMemo(() => {
    const [resolvedHref, resolvedAs] = (0, _router).resolveHref(router, props.href, true);
    return {
      href: resolvedHref,
      as: props.as ? (0, _router).resolveHref(router, props.as) : resolvedAs || resolvedHref
    };
  }, [router, props.href, props.as]);

  let {
    children,
    replace,
    shallow,
    scroll,
    locale
  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react.default.createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  let child;

  if (true) {
    try {
      child = _react.default.Children.only(children);
    } catch (err) {
      throw new Error(`Multiple children were passed to <Link> with \`href\` of \`${props.href}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + ( false ? 0 : ''));
    }
  } else {}

  const childRef = child && typeof child === 'object' && child.ref;
  const [setIntersectionRef, isVisible] = (0, _useIntersection).useIntersection({
    rootMargin: '200px'
  });

  const setRef = _react.default.useCallback(el => {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  _react.default.useEffect(() => {
    const shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    const isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);

  const childProps = {
    ref: setRef,
    onClick: e => {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = e => {
    if (!(0, _router).isLocalURL(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    const curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale
    // so that locale links are still visitable in development/preview envs

    const localeDomain = router && router.isLocaleDomain && (0, _router).getDomainLocale(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router).addBasePath((0, _router).addLocale(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react.default.cloneElement(child, childProps);
}

var _default = Link;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/next/dist/client/normalize-trailing-slash.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}

const normalizePathTrailingSlash =  false ? 0 : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

/***/ }),

/***/ "../../node_modules/next/dist/client/request-idle-callback.js":
/*!********************************************************************!*\
  !*** ../../node_modules/next/dist/client/request-idle-callback.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.requestIdleCallback = exports.cancelIdleCallback = void 0;

const requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function (cb) {
  let start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function () {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

exports.requestIdleCallback = requestIdleCallback;

const cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function (id) {
  return clearTimeout(id);
};

exports.cancelIdleCallback = cancelIdleCallback;

/***/ }),

/***/ "../../node_modules/next/dist/client/route-loader.js":
/*!***********************************************************!*\
  !*** ../../node_modules/next/dist/client/route-loader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports.createRouteLoader = createRouteLoader;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ "../shared/lib/router/utils/get-asset-path-from-route"));

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "../../node_modules/next/dist/client/request-idle-callback.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


const MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  let entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  let resolver;
  const prom = new Promise(resolve => {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? generator().then(value => (resolver(value), value)) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (e) {
    return false;
  }
}

const canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise((res, rej) => {
    if (document.querySelector(`link[rel="prefetch"][href^="${href}"]`)) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = `prefetch`;
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

const ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise((resolve, reject) => {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`))); // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
} // We wait for pages to be built in dev before we start the route transition
// timeout to prevent an un-necessary hard navigation in development.


let devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.

function resolvePromiseWithTimeout(p, ms, err) {
  return new Promise((resolve, reject) => {
    let cancelled = false;
    p.then(r => {
      // Resolved, cancel the timeout
      cancelled = true;
      resolve(r);
    }).catch(reject); // We wrap these checks separately for better dead-code elimination in
    // production bundles.

    if (true) {
      (devBuildPromise || Promise.resolve()).then(() => {
        (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {
          if (!cancelled) {
            reject(err);
          }
        }, ms));
      });
    }

    if (false) {}
  });
}

function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  const onBuildManifest = new Promise(resolve => {
    // Mandatory because this is not concurrent safe:
    const cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = () => {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(manifest => {
    if (!(route in manifest)) {
      throw markAssetError(new Error(`Failed to lookup route: ${route}`));
    }

    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));
    return {
      scripts: allFiles.filter(v => v.endsWith('.js')),
      css: allFiles.filter(v => v.endsWith('.css'))
    };
  });
}

function createRouteLoader(assetPrefix) {
  const entrypoints = new Map();
  const loadedScripts = new Map();
  const styleSheets = new Map();
  const routes = new Map();

  function maybeExecuteScript(src) {
    let prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector(`script[src^="${src}"]`)) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    let prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(res => {
      if (!res.ok) {
        throw new Error(`Failed to load stylesheet: ${href}`);
      }

      return res.text().then(text => ({
        href: href,
        content: text
      }));
    }).catch(err => {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },

    onEntrypoint(route, execute) {
      Promise.resolve(execute).then(fn => fn()).then(exports => ({
        component: exports && exports.default || exports,
        exports: exports
      }), err => ({
        error: err
      })).then(input => {
        const old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },

    loadRoute(route, prefetch) {
      return withFuture(route, routes, () => {
        const routeFilesPromise = getFilesForRoute(assetPrefix, route).then(({
          scripts,
          css
        }) => {
          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);
        }).then(res => {
          return this.whenEntrypoint(route).then(entrypoint => ({
            entrypoint,
            styles: res[1]
          }));
        });

        if (true) {
          devBuildPromise = new Promise(resolve => {
            if (routeFilesPromise) {
              return routeFilesPromise.finally(() => {
                resolve();
              });
            }
          });
        }

        return resolvePromiseWithTimeout(routeFilesPromise, MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({
          entrypoint,
          styles
        }) => {
          const res = Object.assign({
            styles: styles
          }, entrypoint);
          return 'error' in entrypoint ? entrypoint : res;
        }).catch(err => {
          if (prefetch) {
            // we don't want to cache errors during prefetch
            throw err;
          }

          return {
            error: err
          };
        });
      });
    },

    prefetch(route) {
      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      let cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {
        (0, _requestIdleCallback).requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}));
      }).catch( // swallow prefetch errors
      () => {});
    }

  };
}

/***/ }),

/***/ "../../node_modules/next/dist/client/router.js":
/*!*****************************************************!*\
  !*** ../../node_modules/next/dist/client/router.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Router", ({
  enumerable: true,
  get: function () {
    return _router.default;
  }
}));
Object.defineProperty(exports, "withRouter", ({
  enumerable: true,
  get: function () {
    return _withRouter.default;
  }
}));
exports.useRouter = useRouter;
exports.createRouter = createRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "react"));

var _router = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/router */ "../../node_modules/next/dist/shared/lib/router/router.js"));

var _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ "../shared/lib/router-context");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "../../node_modules/next/dist/client/with-router.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const singletonRouter = {
  router: null,
  readyCallbacks: [],

  ready(cb) {
    if (this.router) return cb();

    if (false) {}
  }

}; // Create public properties and methods of the router in the singletonRouter

const urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain', 'domainLocales'];
const routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
const coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get() {
    return _router.default.events;
  }

});
urlPropertyFields.forEach(field => {
  // Here we need to use Object.defineProperty because we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get() {
      const router = getRouter();
      return router[field];
    }

  });
});
coreMethodFields.forEach(field => {
  singletonRouter[field] = (...args) => {
    const router = getRouter();
    return router[field](...args);
  };
});
routerEvents.forEach(event => {
  singletonRouter.ready(() => {
    _router.default.events.on(event, (...args) => {
      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;
      const _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField](...args);
        } catch (err) {
          console.error(`Error when running the Router event: ${eventField}`);
          console.error(`${err.message}\n${err.stack}`);
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    const message = 'No router instance found.\n' + 'You should only use "next/router" on the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
}

var _default = singletonRouter;
exports.default = _default;

function useRouter() {
  return _react.default.useContext(_routerContext.RouterContext);
}

function createRouter(...args) {
  singletonRouter.router = new _router.default(...args);
  singletonRouter.readyCallbacks.forEach(cb => cb());
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}

function makePublicRouterInstance(router) {
  const _router1 = router;
  const instance = {};

  for (const property of urlPropertyFields) {
    if (typeof _router1[property] === 'object') {
      instance[property] = Object.assign(Array.isArray(_router1[property]) ? [] : {}, _router1[property]) // makes sure query is not stateful
      ;
      continue;
    }

    instance[property] = _router1[property];
  } // Events is a static property on the router, the router doesn't have to be initialized to use it


  instance.events = _router.default.events;
  coreMethodFields.forEach(field => {
    instance[field] = (...args) => {
      return _router1[field](...args);
    };
  });
  return instance;
}

/***/ }),

/***/ "../../node_modules/next/dist/client/use-intersection.js":
/*!***************************************************************!*\
  !*** ../../node_modules/next/dist/client/use-intersection.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "react");

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "../../node_modules/next/dist/client/request-idle-callback.js");

const hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection({
  rootMargin,
  disabled
}) {
  const isDisabled = disabled || !hasIntersectionObserver;
  const unobserve = (0, _react).useRef();
  const [visible, setVisible] = (0, _react).useState(false);
  const setRef = (0, _react).useCallback(el => {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {
        rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react).useEffect(() => {
    if (!hasIntersectionObserver) {
      if (!visible) {
        const idleCallback = (0, _requestIdleCallback).requestIdleCallback(() => setVisible(true));
        return () => (0, _requestIdleCallback).cancelIdleCallback(idleCallback);
      }
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  const {
    id,
    observer,
    elements
  } = createObserver(options);
  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements.delete(element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers.delete(id);
    }
  };
}

const observers = new Map();

function createObserver(options) {
  const id = options.rootMargin || '';
  let instance = observers.get(id);

  if (instance) {
    return instance;
  }

  const elements = new Map();
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const callback = elements.get(entry.target);
      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id,
    observer,
    elements
  });
  return instance;
}

/***/ }),

/***/ "../../node_modules/next/dist/client/with-router.js":
/*!**********************************************************!*\
  !*** ../../node_modules/next/dist/client/with-router.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "react"));

var _router = __webpack_require__(/*! ./router */ "../../node_modules/next/dist/client/router.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({
      router: (0, _router).useRouter()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = `withRouter(${name})`;
  }

  return WithRouterWrapper;
}

/***/ }),

/***/ "../../node_modules/next/dist/shared/lib/router/router.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/router.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.default = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "../../node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "../../node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ "../../../server/denormalize-page-path");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "../i18n/normalize-locale-path");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "../mitt"));

var _utils = __webpack_require__(/*! ../utils */ "../shared/lib/utils");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./utils/is-dynamic");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./utils/parse-relative-url");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./utils/querystring");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "?ba11"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./utils/route-matcher");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./utils/route-regex");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

let detectDomainLocale;

if (false) {}

const basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash).normalizePathTrailingSlash(prefix) : `${prefix}${pathNoQueryHash(path) === '/' ? path.substring(1) : path}` : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) {} else {
    return false;
  }
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  const queryIndex = path.indexOf('?');
  const hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = `/${path}`;
  return path;
}

function isLocalURL(url) {
  // prevent a hydration mismatch on href for url with anchor refs
  if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    const locationOrigin = (0, _utils).getLocationOrigin();
    const resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  let interpolatedRoute = '';
  const dynamicRegex = (0, _routeRegex).getRouteRegex(route);
  const dynamicGroups = dynamicRegex.groups;
  const dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  const params = Object.keys(dynamicGroups);

  if (!params.every(param => {
    let value = dynamicMatches[param] || '';
    const {
      repeat,
      optional
    } = dynamicGroups[param]; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    let replaced = `[${repeat ? '...' : ''}${param}]`;

    if (optional) {
      replaced = `${!value ? '/' : ''}[${replaced}]`;
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = '' // did not satisfy all requirements
    ; // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  const filteredQuery = {};
  Object.keys(query).forEach(key => {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}

function resolveHref(router, href, resolveAs) {
  // we use a dummy base url for relative urls
  let base;
  let urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered
  // invalid and will never match a Next.js page/file

  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
  const urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;
  const urlParts = urlAsStringNoProto.split('?');

  if ((urlParts[0] || '').match(/(\/\/|\\)/)) {
    console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\ are not valid in the href`);
    const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);
    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;
  } // Return because it cannot be routed by the Next.js router


  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');
  } catch (_) {
    // fallback to / for invalid asPath values e.g. //
    base = new URL('/', 'http://n');
  }

  try {
    const finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);
    let interpolatedAs = '';

    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);
      const {
        result,
        params
      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);

      if (result) {
        interpolatedAs = (0, _utils).formatWithValidation({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  const origin = (0, _utils).getLocationOrigin();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  let [resolvedHref, resolvedAs] = resolveHref(router, url, true);
  const origin = (0, _utils).getLocationOrigin();
  const hrefHadOrigin = resolvedHref.startsWith(origin);
  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

function resolveDynamicRoute(pathname, pages) {
  const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));

  if (cleanPathname === '/404' || cleanPathname === '/_error') {
    return pathname;
  } // handle resolving href for dynamic routes


  if (!pages.includes(cleanPathname)) {
    // eslint-disable-next-line array-callback-return
    pages.some(page => {
      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {
        pathname = page;
        return true;
      }
    });
  }

  return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);
}

const manualScrollRestoration =  false && 0;
const SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` wonâ€™t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(res => {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(data => {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error(`Failed to load static props`);
        });
      }

      throw new Error(`Failed to load static props`);
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader).markAssetError(err);
    }

    throw err;
  });
}

class Router {
  constructor(pathname1, query1, as1, {
    initialProps,
    pageLoader,
    App,
    wrapApp,
    Component: Component1,
    err: err1,
    subscription,
    isFallback,
    locale,
    locales,
    defaultLocale,
    domainLocales,
    isPreview
  }) {
    // Static Data Cache
    this.sdc = {}; // In-flight Server Data Requests, for deduping

    this.sdr = {};
    this._idx = 0;

    this.onPopState = e => {
      const state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        const {
          pathname: pathname1,
          query: query1
        } = this;
        this.changeState('replaceState', (0, _utils).formatWithValidation({
          pathname: addBasePath(pathname1),
          query: query1
        }), (0, _utils).getURL());
        return;
      }

      if (!state.__N) {
        return;
      }

      let forcedScroll;
      const {
        url,
        as: as1,
        options,
        idx
      } = state;

      if (false) {}

      this._idx = idx;
      const {
        pathname: pathname1
      } = (0, _parseRelativeUrl).parseRelativeUrl(url); // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site

      if (this.isSsr && as1 === this.asPath && pathname1 === this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (this._bps && !this._bps(state)) {
        return;
      }

      this.change('replaceState', url, as1, Object.assign({}, options, {
        shallow: options.shallow && this._shallow,
        locale: options.locale || this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname1); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (pathname1 !== '/_error') {
      this.components[this.route] = {
        Component: Component1,
        initial: true,
        props: initialProps,
        err: err1,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: []
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = pathname1;
    this.query = query1; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? pathname1 : as1;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);
    this.isPreview = !!isPreview;
    this.isLocaleDomain = false;

    if (false) {}

    if (false) {}
  }

  reload() {
    window.location.reload();
  }
  /**
  * Go back in history
  */


  back() {
    window.history.back();
  }
  /**
  * Performs a `pushState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  push(url, as, options = {}) {
    if (false) {}

    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('pushState', url, as, options);
  }
  /**
  * Performs a `replaceState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  replace(url, as, options = {}) {
    ({
      url,
      as
    } = prepareUrlAs(this, url, as));
    return this.change('replaceState', url, as, options);
  }

  async change(method, url, as, options, forcedScroll) {
    if (!isLocalURL(url)) {
      window.location.href = url;
      return false;
    }

    const shouldResolveHref = url === as || options._h || options._shouldResolveHref; // for static pages with query params in the URL we delay
    // marking the router ready until after the query is updated

    if (options._h) {
      this.isReady = true;
    }

    const prevLocale = this.locale;

    if (false) { var ref; }

    if (!options._h) {
      this.isSsr = false;
    } // marking route changes as a navigation start entry


    if (_utils.ST) {
      performance.mark('routeChange');
    }

    const {
      shallow = false
    } = options;
    const routeProps = {
      shallow
    };

    if (this._inFlightRoute) {
      this.abortComponentLoad(this._inFlightRoute, routeProps);
    }

    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
    this._inFlightRoute = as;
    let localeChange = prevLocale !== this.locale; // If the url change is only related to a hash change
    // We should not proceed. We should only change the state.
    // WARNING: `_h` is an internal option for handing Next.js client-side
    // hydration. Your app should _never_ use this property. It may change at
    // any time without notice.

    if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {
      this.asPath = cleanedAs;
      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

      this.changeState(method, url, as, options);
      this.scrollToHash(cleanedAs);
      this.notify(this.components[this.route], null);
      Router.events.emit('hashChangeComplete', as, routeProps);
      return true;
    }

    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
    let {
      pathname: pathname1,
      query: query1
    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages
    // get their query parameters to allow ensuring they can be parsed properly
    // when rewritten to

    let pages, rewrites;

    try {
      pages = await this.pageLoader.getPageList();
      ({
        __rewrites: rewrites
      } = await (0, _routeLoader).getClientBuildManifest());
    } catch (err1) {
      // If we fail to resolve the page list or client-build manifest, we must
      // do a server-side transition:
      window.location.href = as;
      return false;
    } // If asked to change the current URL we should reload the current page
    // (not location.reload() but reload getInitialProps and other Next.js stuffs)
    // We also need to set the method = replaceState always
    // as this should not go into the history (That's how browsers work)
    // We should compare the new asPath to the current asPath, not the url


    if (!this.urlIsNew(cleanedAs) && !localeChange) {
      method = 'replaceState';
    } // we need to resolve the as value using rewrites for dynamic SSG
    // pages to allow building the data URL correctly


    let resolvedAs = as; // url and as should always be prefixed with basePath by this
    // point by either next/link or router.push/replace so strip the
    // basePath from the pathname to match the pages dir 1-to-1

    pathname1 = pathname1 ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname1)) : pathname1;

    if (shouldResolveHref && pathname1 !== '/_error') {
      options._shouldResolveHref = true;

      if (false) {} else {
        parsed.pathname = resolveDynamicRoute(pathname1, pages);

        if (parsed.pathname !== pathname1) {
          pathname1 = parsed.pathname;
          parsed.pathname = addBasePath(pathname1);
          url = (0, _utils).formatWithValidation(parsed);
        }
      }
    }

    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname1);

    if (!isLocalURL(as)) {
      if (true) {
        throw new Error(`Invalid href: "${url}" and as: "${as}", received relative href and external as` + `\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);
      }

      window.location.href = as;
      return false;
    }

    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

    if ((0, _isDynamic).isDynamicRoute(route)) {
      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);
      const asPathname = parsedAs.pathname;
      const routeRegex = (0, _routeRegex).getRouteRegex(route);
      const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);
      const shouldInterpolate = route === asPathname;
      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query1) : {};

      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
        const missingParams = Object.keys(routeRegex.groups).filter(param => !query1[param]);

        if (missingParams.length > 0) {
          if (true) {
            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \`as\` and \`href\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \`href\`'s \`query\``);
          }

          throw new Error((shouldInterpolate ? `The provided \`href\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \`as\` value (${asPathname}) is incompatible with the \`href\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);
        }
      } else if (shouldInterpolate) {
        as = (0, _utils).formatWithValidation(Object.assign({}, parsedAs, {
          pathname: interpolatedAs.result,
          query: omitParmsFromQuery(query1, interpolatedAs.params)
        }));
      } else {
        // Merge params into `query`, overwriting any specified in search
        Object.assign(query1, routeMatch);
      }
    }

    Router.events.emit('routeChangeStart', as, routeProps);

    try {
      var ref, ref1;
      let routeInfo = await this.getRouteInfo(route, pathname1, query1, as, resolvedAs, routeProps);
      let {
        error,
        props,
        __N_SSG,
        __N_SSP
      } = routeInfo; // handle redirect on client-transition

      if ((__N_SSG || __N_SSP) && props) {
        if (props.pageProps && props.pageProps.__N_REDIRECT) {
          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
          // client-navigation if it is falling back to hard navigation if
          // it's not

          if (destination.startsWith('/')) {
            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);
            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
            const {
              url: newUrl,
              as: newAs
            } = prepareUrlAs(this, destination, destination);
            return this.change(method, newUrl, newAs, options);
          }

          window.location.href = destination;
          return new Promise(() => {});
        }

        this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404

        if (props.notFound === SSG_DATA_NOT_FOUND) {
          let notFoundRoute;

          try {
            await this.fetchComponent('/404');
            notFoundRoute = '/404';
          } catch (_) {
            notFoundRoute = '/_error';
          }

          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query1, as, resolvedAs, {
            shallow: false
          });
        }
      }

      Router.events.emit('beforeHistoryChange', as, routeProps);
      this.changeState(method, url, as, options);

      if (true) {
        const appComp = this.components['/_app'].Component;
        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
      }

      if (options._h && pathname1 === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {
        // ensure statusCode is still correct for static 500 page
        // when updating query information
        props.pageProps.statusCode = 500;
      } // shallow routing is only allowed for same page URL changes.


      const isValidShallowRoute = options.shallow && this.route === route;

      var _scroll;

      const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;
      const resetScroll = shouldScroll ? {
        x: 0,
        y: 0
      } : null;
      await this.set(route, pathname1, query1, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(e => {
        if (e.cancelled) error = error || e;else throw e;
      });

      if (error) {
        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
        throw error;
      }

      if (false) {}

      Router.events.emit('routeChangeComplete', as, routeProps);
      return true;
    } catch (err1) {
      if (err1.cancelled) {
        return false;
      }

      throw err1;
    }
  }

  changeState(method, url, as, options = {}) {
    if (true) {
      if (typeof window.history === 'undefined') {
        console.error(`Warning: window.history is not available.`);
        return;
      }

      if (typeof window.history[method] === 'undefined') {
        console.error(`Warning: window.history.${method} is not available`);
        return;
      }
    }

    if (method !== 'pushState' || (0, _utils).getURL() !== as) {
      this._shallow = options.shallow;
      window.history[method]({
        url,
        as,
        options,
        __N: true,
        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      '', as);
    }
  }

  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
    if (err.cancelled) {
      // bubble up cancellation errors
      throw err;
    }

    if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {
      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
      //  1. Page doesn't exists
      //  2. Page does exist in a different zone
      //  3. Internal error while loading the page
      // So, doing a hard reload is the proper way to deal with this.

      window.location.href = as; // Changing the URL doesn't block executing the current code path.
      // So let's throw a cancellation error stop the routing logic.

      throw buildCancellationError();
    }

    try {
      let Component1;
      let styleSheets;
      let props;

      if (typeof Component1 === 'undefined' || typeof styleSheets === 'undefined') {
        ({
          page: Component1,
          styleSheets
        } = await this.fetchComponent('/_error'));
      }

      const routeInfo = {
        props,
        Component: Component1,
        styleSheets,
        err,
        error: err
      };

      if (!routeInfo.props) {
        try {
          routeInfo.props = await this.getInitialProps(Component1, {
            err,
            pathname,
            query
          });
        } catch (gipErr) {
          console.error('Error in error page `getInitialProps`: ', gipErr);
          routeInfo.props = {};
        }
      }

      return routeInfo;
    } catch (routeInfoErr) {
      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, routeProps, true);
    }
  }

  async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {
    try {
      const existingRouteInfo = this.components[route];

      if (routeProps.shallow && existingRouteInfo && this.route === route) {
        return existingRouteInfo;
      }

      const cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;
      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({
        Component: res.page,
        styleSheets: res.styleSheets,
        __N_SSG: res.mod.__N_SSG,
        __N_SSP: res.mod.__N_SSP
      }));
      const {
        Component: Component1,
        __N_SSG,
        __N_SSP
      } = routeInfo;

      if (true) {
        const {
          isValidElementType
        } = __webpack_require__(/*! react-is */ "../../node_modules/next/node_modules/react-is/index.js");

        if (!isValidElementType(Component1)) {
          throw new Error(`The default export is not a React Component in page: "${pathname}"`);
        }
      }

      let dataHref;

      if (__N_SSG || __N_SSP) {
        dataHref = this.pageLoader.getDataHref((0, _utils).formatWithValidation({
          pathname,
          query
        }), resolvedAs, __N_SSG, this.locale);
      }

      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component1, // we provide AppTree later so this needs to be `any`
      {
        pathname,
        query,
        asPath: as,
        locale: this.locale,
        locales: this.locales,
        defaultLocale: this.defaultLocale
      }));
      routeInfo.props = props;
      this.components[route] = routeInfo;
      return routeInfo;
    } catch (err2) {
      return this.handleRouteInfoError(err2, pathname, query, as, routeProps);
    }
  }

  set(route, pathname, query, as, data, resetScroll) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data, resetScroll);
  }
  /**
  * Callback to execute before replacing router state
  * @param cb callback to be executed
  */


  beforePopState(cb) {
    this._bps = cb;
  }

  onlyAHashChange(as) {
    if (!this.asPath) return false;
    const [oldUrlNoHash, oldHash] = this.asPath.split('#');
    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same

    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  }

  scrollToHash(as) {
    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value or `#top`
    // To mirror browsers

    if (hash === '' || hash === 'top') {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    const idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    const nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  }

  urlIsNew(asPath) {
    return this.asPath !== asPath;
  }
  /**
  * Prefetch page code, you may wait for the data during page rendering.
  * This feature only works in production!
  * @param url the href of prefetched page
  * @param asPath the as path of the prefetched page
  */


  async prefetch(url, asPath = url, options = {}) {
    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);
    let {
      pathname: pathname2
    } = parsed;

    if (false) {}

    const pages = await this.pageLoader.getPageList();
    let resolvedAs = asPath;

    if (false) {} else {
      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);

      if (parsed.pathname !== pathname2) {
        pathname2 = parsed.pathname;
        parsed.pathname = pathname2;
        url = (0, _utils).formatWithValidation(parsed);
      }
    }

    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname2); // Prefetch is not supported in development mode because it would trigger on-demand-entries

    if (true) {
      return;
    }

    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {
      return isSsg ? this._getStaticData(this.pageLoader.getDataHref(url, resolvedAs, true, typeof options.locale !== 'undefined' ? options.locale : this.locale)) : false;
    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);
  }

  async fetchComponent(route) {
    let cancelled = false;

    const cancel = this.clc = () => {
      cancelled = true;
    };

    const componentResult = await this.pageLoader.loadPage(route);

    if (cancelled) {
      const error = new Error(`Abort fetching component for route: "${route}"`);
      error.cancelled = true;
      throw error;
    }

    if (cancel === this.clc) {
      this.clc = null;
    }

    return componentResult;
  }

  _getData(fn) {
    let cancelled = false;

    const cancel = () => {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(data => {
      if (cancel === this.clc) {
        this.clc = null;
      }

      if (cancelled) {
        const err2 = new Error('Loading initial props cancelled');
        err2.cancelled = true;
        throw err2;
      }

      return data;
    });
  }

  _getStaticData(dataHref) {
    const {
      href: cacheKey
    } = new URL(dataHref, window.location.href);

    if (false) {}

    return fetchNextData(dataHref, this.isSsr).then(data => {
      this.sdc[cacheKey] = data;
      return data;
    });
  }

  _getServerData(dataHref) {
    const {
      href: resourceKey
    } = new URL(dataHref, window.location.href);

    if (this.sdr[resourceKey]) {
      return this.sdr[resourceKey];
    }

    return this.sdr[resourceKey] = fetchNextData(dataHref, this.isSsr).then(data => {
      delete this.sdr[resourceKey];
      return data;
    }).catch(err2 => {
      delete this.sdr[resourceKey];
      throw err2;
    });
  }

  getInitialProps(Component, ctx) {
    const {
      Component: App1
    } = this.components['/_app'];

    const AppTree = this._wrapApp(App1);

    ctx.AppTree = AppTree;
    return (0, _utils).loadGetInitialProps(App1, {
      AppTree,
      Component,
      router: this,
      ctx
    });
  }

  abortComponentLoad(as, routeProps) {
    if (this.clc) {
      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
      this.clc();
      this.clc = null;
    }
  }

  notify(data, resetScroll) {
    return this.sub(data, this.components['/_app'].Component, resetScroll);
  }

}

Router.events = (0, _mitt).default();
exports.default = Router;

/***/ }),

/***/ "../../node_modules/next/link.js":
/*!***************************************!*\
  !*** ../../node_modules/next/link.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./dist/client/link */ "../../node_modules/next/dist/client/link.js")


/***/ }),

/***/ "../../node_modules/next/node_modules/react-is/cjs/react-is.development.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/next/node_modules/react-is/cjs/react-is.development.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/next/node_modules/react-is/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/next/node_modules/react-is/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/next/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "@apollo/client":
/*!*********************************!*\
  !*** external "@apollo/client" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@apollo/client");

/***/ }),

/***/ "@braintree/sanitize-url":
/*!******************************************!*\
  !*** external "@braintree/sanitize-url" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@braintree/sanitize-url");

/***/ }),

/***/ "@emotion/hash":
/*!********************************!*\
  !*** external "@emotion/hash" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@emotion/hash");

/***/ }),

/***/ "@emotion/weak-memoize":
/*!****************************************!*\
  !*** external "@emotion/weak-memoize" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@emotion/weak-memoize");

/***/ }),

/***/ "@graphql-tools/schema":
/*!****************************************!*\
  !*** external "@graphql-tools/schema" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@graphql-tools/schema");

/***/ }),

/***/ "@graphql-ts/schema":
/*!*************************************!*\
  !*** external "@graphql-ts/schema" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@graphql-ts/schema");

/***/ }),

/***/ "@graphql-ts/schema/api-with-context":
/*!******************************************************!*\
  !*** external "@graphql-ts/schema/api-with-context" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@graphql-ts/schema/api-with-context");

/***/ }),

/***/ "@graphql-ts/schema/api-without-context":
/*!*********************************************************!*\
  !*** external "@graphql-ts/schema/api-without-context" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@graphql-ts/schema/api-without-context");

/***/ }),

/***/ "@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App":
/*!********************************************************************************************************!*\
  !*** external "@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App" ***!
  \********************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-next/keystone/___internal-do-not-use-will-break-in-patch/admin-ui/pages/App");

/***/ }),

/***/ "@keystone-next/keystone/admin-ui/context":
/*!***********************************************************!*\
  !*** external "@keystone-next/keystone/admin-ui/context" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-next/keystone/admin-ui/context");

/***/ }),

/***/ "@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect":
/*!*********************************************************************************************!*\
  !*** external "@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect" ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-next/keystone/fields/types/relationship/views/RelationshipSelect");

/***/ }),

/***/ "@keystone-ui/button":
/*!**************************************!*\
  !*** external "@keystone-ui/button" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/button");

/***/ }),

/***/ "@keystone-ui/core":
/*!************************************!*\
  !*** external "@keystone-ui/core" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/core");

/***/ }),

/***/ "@keystone-ui/fields":
/*!**************************************!*\
  !*** external "@keystone-ui/fields" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/fields");

/***/ }),

/***/ "@keystone-ui/icons/icons/AlertTriangleIcon":
/*!*************************************************************!*\
  !*** external "@keystone-ui/icons/icons/AlertTriangleIcon" ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/AlertTriangleIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/AlignCenterIcon":
/*!***********************************************************!*\
  !*** external "@keystone-ui/icons/icons/AlignCenterIcon" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/AlignCenterIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/AlignLeftIcon":
/*!*********************************************************!*\
  !*** external "@keystone-ui/icons/icons/AlignLeftIcon" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/AlignLeftIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/AlignRightIcon":
/*!**********************************************************!*\
  !*** external "@keystone-ui/icons/icons/AlignRightIcon" ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/AlignRightIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/BoldIcon":
/*!****************************************************!*\
  !*** external "@keystone-ui/icons/icons/BoldIcon" ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/BoldIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/ChevronDownIcon":
/*!***********************************************************!*\
  !*** external "@keystone-ui/icons/icons/ChevronDownIcon" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/ChevronDownIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/ChevronRightIcon":
/*!************************************************************!*\
  !*** external "@keystone-ui/icons/icons/ChevronRightIcon" ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/ChevronRightIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/CodeIcon":
/*!****************************************************!*\
  !*** external "@keystone-ui/icons/icons/CodeIcon" ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/CodeIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/ColumnsIcon":
/*!*******************************************************!*\
  !*** external "@keystone-ui/icons/icons/ColumnsIcon" ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/ColumnsIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/ExternalLinkIcon":
/*!************************************************************!*\
  !*** external "@keystone-ui/icons/icons/ExternalLinkIcon" ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/ExternalLinkIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/EyeIcon":
/*!***************************************************!*\
  !*** external "@keystone-ui/icons/icons/EyeIcon" ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/EyeIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/EyeOffIcon":
/*!******************************************************!*\
  !*** external "@keystone-ui/icons/icons/EyeOffIcon" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/EyeOffIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/ItalicIcon":
/*!******************************************************!*\
  !*** external "@keystone-ui/icons/icons/ItalicIcon" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/ItalicIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/LinkIcon":
/*!****************************************************!*\
  !*** external "@keystone-ui/icons/icons/LinkIcon" ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/LinkIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/Maximize2Icon":
/*!*********************************************************!*\
  !*** external "@keystone-ui/icons/icons/Maximize2Icon" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/Maximize2Icon");

/***/ }),

/***/ "@keystone-ui/icons/icons/Minimize2Icon":
/*!*********************************************************!*\
  !*** external "@keystone-ui/icons/icons/Minimize2Icon" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/Minimize2Icon");

/***/ }),

/***/ "@keystone-ui/icons/icons/MinusIcon":
/*!*****************************************************!*\
  !*** external "@keystone-ui/icons/icons/MinusIcon" ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/MinusIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/MoreHorizontalIcon":
/*!**************************************************************!*\
  !*** external "@keystone-ui/icons/icons/MoreHorizontalIcon" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/MoreHorizontalIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/PlusIcon":
/*!****************************************************!*\
  !*** external "@keystone-ui/icons/icons/PlusIcon" ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/PlusIcon");

/***/ }),

/***/ "@keystone-ui/icons/icons/Trash2Icon":
/*!******************************************************!*\
  !*** external "@keystone-ui/icons/icons/Trash2Icon" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/Trash2Icon");

/***/ }),

/***/ "@keystone-ui/icons/icons/XIcon":
/*!*************************************************!*\
  !*** external "@keystone-ui/icons/icons/XIcon" ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/icons/icons/XIcon");

/***/ }),

/***/ "@keystone-ui/loading":
/*!***************************************!*\
  !*** external "@keystone-ui/loading" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/loading");

/***/ }),

/***/ "@keystone-ui/modals":
/*!**************************************!*\
  !*** external "@keystone-ui/modals" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/modals");

/***/ }),

/***/ "@keystone-ui/notice":
/*!**************************************!*\
  !*** external "@keystone-ui/notice" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/notice");

/***/ }),

/***/ "@keystone-ui/pill":
/*!************************************!*\
  !*** external "@keystone-ui/pill" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/pill");

/***/ }),

/***/ "@keystone-ui/popover":
/*!***************************************!*\
  !*** external "@keystone-ui/popover" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/popover");

/***/ }),

/***/ "@keystone-ui/segmented-control":
/*!*************************************************!*\
  !*** external "@keystone-ui/segmented-control" ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/segmented-control");

/***/ }),

/***/ "@keystone-ui/toast":
/*!*************************************!*\
  !*** external "@keystone-ui/toast" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/toast");

/***/ }),

/***/ "@keystone-ui/tooltip":
/*!***************************************!*\
  !*** external "@keystone-ui/tooltip" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@keystone-ui/tooltip");

/***/ }),

/***/ "apollo-upload-client":
/*!***************************************!*\
  !*** external "apollo-upload-client" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("apollo-upload-client");

/***/ }),

/***/ "apply-ref":
/*!****************************!*\
  !*** external "apply-ref" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("apply-ref");

/***/ }),

/***/ "bytes":
/*!************************!*\
  !*** external "bytes" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("bytes");

/***/ }),

/***/ "copy-to-clipboard":
/*!************************************!*\
  !*** external "copy-to-clipboard" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("copy-to-clipboard");

/***/ }),

/***/ "date-fns":
/*!***************************!*\
  !*** external "date-fns" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("date-fns");

/***/ }),

/***/ "decimal.js":
/*!*****************************!*\
  !*** external "decimal.js" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("decimal.js");

/***/ }),

/***/ "dumb-passwords":
/*!*********************************!*\
  !*** external "dumb-passwords" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("dumb-passwords");

/***/ }),

/***/ "fast-deep-equal":
/*!**********************************!*\
  !*** external "fast-deep-equal" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("fast-deep-equal");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("graphql");

/***/ }),

/***/ "graphql-type-json":
/*!************************************!*\
  !*** external "graphql-type-json" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("graphql-type-json");

/***/ }),

/***/ "graphql-upload/public/GraphQLUpload.js":
/*!*********************************************************!*\
  !*** external "graphql-upload/public/GraphQLUpload.js" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("graphql-upload/public/GraphQLUpload.js");

/***/ }),

/***/ "intersection-observer":
/*!****************************************!*\
  !*** external "intersection-observer" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("intersection-observer");

/***/ }),

/***/ "is-hotkey":
/*!****************************!*\
  !*** external "is-hotkey" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("is-hotkey");

/***/ }),

/***/ "match-sorter":
/*!*******************************!*\
  !*** external "match-sorter" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("match-sorter");

/***/ }),

/***/ "mdast-util-definitions":
/*!*****************************************!*\
  !*** external "mdast-util-definitions" ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("mdast-util-definitions");

/***/ }),

/***/ "mdast-util-from-markdown":
/*!*******************************************!*\
  !*** external "mdast-util-from-markdown" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("mdast-util-from-markdown");

/***/ }),

/***/ "mdast-util-gfm-autolink-literal/from-markdown":
/*!****************************************************************!*\
  !*** external "mdast-util-gfm-autolink-literal/from-markdown" ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("mdast-util-gfm-autolink-literal/from-markdown");

/***/ }),

/***/ "mdast-util-gfm-strikethrough/from-markdown":
/*!*************************************************************!*\
  !*** external "mdast-util-gfm-strikethrough/from-markdown" ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("mdast-util-gfm-strikethrough/from-markdown");

/***/ }),

/***/ "micromark-extension-gfm-autolink-literal":
/*!***********************************************************!*\
  !*** external "micromark-extension-gfm-autolink-literal" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("micromark-extension-gfm-autolink-literal");

/***/ }),

/***/ "micromark-extension-gfm-strikethrough":
/*!********************************************************!*\
  !*** external "micromark-extension-gfm-strikethrough" ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("micromark-extension-gfm-strikethrough");

/***/ }),

/***/ "../../../server/denormalize-page-path":
/*!************************************************************!*\
  !*** external "next/dist/server/denormalize-page-path.js" ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/denormalize-page-path.js");

/***/ }),

/***/ "../i18n/normalize-locale-path":
/*!*********************************************************************!*\
  !*** external "next/dist/shared/lib/i18n/normalize-locale-path.js" ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/i18n/normalize-locale-path.js");

/***/ }),

/***/ "../mitt":
/*!***********************************************!*\
  !*** external "next/dist/shared/lib/mitt.js" ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/mitt.js");

/***/ }),

/***/ "../shared/lib/router-context":
/*!*********************************************************!*\
  !*** external "next/dist/shared/lib/router-context.js" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router-context.js");

/***/ }),

/***/ "../shared/lib/router/utils/get-asset-path-from-route":
/*!*********************************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/get-asset-path-from-route.js" ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/get-asset-path-from-route.js");

/***/ }),

/***/ "./utils/is-dynamic":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/is-dynamic.js" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-dynamic.js");

/***/ }),

/***/ "./utils/parse-relative-url":
/*!**************************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/parse-relative-url.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-relative-url.js");

/***/ }),

/***/ "./utils/querystring":
/*!*******************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/querystring.js" ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/querystring.js");

/***/ }),

/***/ "./utils/route-matcher":
/*!*********************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/route-matcher.js" ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/route-matcher.js");

/***/ }),

/***/ "./utils/route-regex":
/*!*******************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/route-regex.js" ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/route-regex.js");

/***/ }),

/***/ "../shared/lib/utils":
/*!************************************************!*\
  !*** external "next/dist/shared/lib/utils.js" ***!
  \************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils.js");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/router");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "scroll-into-view-if-needed":
/*!*********************************************!*\
  !*** external "scroll-into-view-if-needed" ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("scroll-into-view-if-needed");

/***/ }),

/***/ "slate":
/*!************************!*\
  !*** external "slate" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("slate");

/***/ }),

/***/ "slate-history":
/*!********************************!*\
  !*** external "slate-history" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("slate-history");

/***/ }),

/***/ "slate-react":
/*!******************************!*\
  !*** external "slate-react" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("slate-react");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),

/***/ "?ba11":
/*!******************************************!*\
  !*** ./utils/resolve-rewrites (ignored) ***!
  \******************************************/
/***/ (() => {

/* (ignored) */

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./pages/_app.js"));
module.exports = __webpack_exports__;

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QixHQUFHLHNJQUFzSSxHQUFHLGNBQWM7QUFDcE87QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUoseUVBQXlFLHVCQUF1QjtBQUNoRztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSwyREFBMkQsc0JBQXNCOztBQUVqRjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0JBQWdCLHlCQUF5Qjs7QUFFOUM7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsS0FBSztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEI7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxzSUFBc0k7QUFDekk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYyxXQUFXLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsZ0JBQWdC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QW9FO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksVUFBVTs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSxzRkFBc0YsdUJBQXVCO0FBQzdHO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELGVBQWUsSUFBSSxpSUFBaUk7QUFDNU07O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxlQUFlLElBQUksU0FBUztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Es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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7O0FBRUE7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNqT2E7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHNKQUF5RDtBQUMzRDs7Ozs7Ozs7Ozs7O0FDTkE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9maWVsZHMtZG9jdW1lbnQvZGlzdC9hcGktOTM0MzYwMjUuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2ZpZWxkcy1kb2N1bWVudC9kaXN0L2luZGV4LTliYTJlNWYyLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9maWVsZHMtZG9jdW1lbnQvZGlzdC90b29sYmFyLTI3MDBkOTdjLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9maWVsZHMtZG9jdW1lbnQvdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWZpZWxkcy1kb2N1bWVudC12aWV3cy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQvZmllbGRzLWRvY3VtZW50L3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1maWVsZHMtZG9jdW1lbnQtdmlld3MuY2pzLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoL2FkbWluLXVpL2lkLWZpZWxkLXZpZXcvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLV9fX2ludGVybmFsLWRvLW5vdC11c2Utd2lsbC1icmVhay1pbi1wYXRjaC1hZG1pbi11aS1pZC1maWVsZC12aWV3LmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9fX19pbnRlcm5hbC1kby1ub3QtdXNlLXdpbGwtYnJlYWstaW4tcGF0Y2gvYWRtaW4tdWkvaWQtZmllbGQtdmlldy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoLWFkbWluLXVpLWlkLWZpZWxkLXZpZXcuY2pzLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvYWRtaW4tdWkvY29udGV4dC9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtYWRtaW4tdWktY29udGV4dC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvYWRtaW4tdWkvcm91dGVyL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1hZG1pbi11aS1yb3V0ZXIuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2Rpc3QvQ2VsbENvbnRhaW5lci00NTMyNTRiNS5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9DZWxsTGluay1kYzQxYzg3Ny5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9DcmVhdGVJdGVtRHJhd2VyLWZhNGUyMjEzLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9kaXN0L0ZpZWxkcy00YWZiMzhmMC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9HcmFwaFFMRXJyb3JOb3RpY2UtNzZmZjk2ZGQuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2Rpc3QvU2lnbm91dEJ1dHRvbi1hY2RiMTU1NC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9hZG1pbi1tZXRhLWdyYXBocWwtOWY5YTljMTEuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2Rpc3QvY29yZS1jOGVjY2UyMy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9kYXRhR2V0dGVyLTlmYmUyZjhlLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9kaXN0L2dldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlci00NzY5OWEwZC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9ncmFwaHFsLXRzLXNjaGVtYS1mY2U3YTZhOC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC9zcWxpdGUtYWY5ZTUxNDguY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2Rpc3QvdXNlSW52YWxpZEZpZWxkcy0xNjJkMWI5Yy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZGlzdC91dGlscy1lZmYxZmQzMC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL2NoZWNrYm94L3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtY2hlY2tib3gtdmlld3MuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9jaGVja2JveC92aWV3cy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWNoZWNrYm94LXZpZXdzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9pbWFnZS91dGlscy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWltYWdlLXV0aWxzLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvaW1hZ2Uvdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy1pbWFnZS12aWV3cy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL2ltYWdlL3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtaW1hZ2Utdmlld3MuY2pzLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL2pzb24vdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy1qc29uLXZpZXdzLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvanNvbi92aWV3cy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWpzb24tdmlld3MuY2pzLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3Bhc3N3b3JkL3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtcGFzc3dvcmQtdmlld3MuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9wYXNzd29yZC92aWV3cy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXBhc3N3b3JkLXZpZXdzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9yZWxhdGlvbnNoaXAvdmlld3MvUmVsYXRpb25zaGlwU2VsZWN0L2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtcmVsYXRpb25zaGlwLXZpZXdzLVJlbGF0aW9uc2hpcFNlbGVjdC5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3JlbGF0aW9uc2hpcC92aWV3cy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXJlbGF0aW9uc2hpcC12aWV3cy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3JlbGF0aW9uc2hpcC92aWV3cy9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXJlbGF0aW9uc2hpcC12aWV3cy5janMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvc2VsZWN0L3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtc2VsZWN0LXZpZXdzLmNqcy5kZXYuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvc2VsZWN0L3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtc2VsZWN0LXZpZXdzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy90ZXh0L3ZpZXdzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtdGV4dC12aWV3cy5janMuZGV2LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3RleHQvdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy10ZXh0LXZpZXdzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy90aW1lc3RhbXAvdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy10aW1lc3RhbXAtdmlld3MuY2pzLmRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy90aW1lc3RhbXAvdmlld3MvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy10aW1lc3RhbXAtdmlld3MuY2pzLmpzIiwid2VicGFjazovLy8uL3BhZ2VzL19hcHAuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvd2l0aC1yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGFwb2xsby9jbGllbnRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAYnJhaW50cmVlL3Nhbml0aXplLXVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBlbW90aW9uL2hhc2hcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAZW1vdGlvbi93ZWFrLW1lbW9pemVcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAZ3JhcGhxbC10b29scy9zY2hlbWFcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAZ3JhcGhxbC10cy9zY2hlbWFcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGgtY29udGV4dFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLW5leHQva2V5c3RvbmUvX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoL2FkbWluLXVpL3BhZ2VzL0FwcFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS1uZXh0L2tleXN0b25lL2FkbWluLXVpL2NvbnRleHRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvcmVsYXRpb25zaGlwL3ZpZXdzL1JlbGF0aW9uc2hpcFNlbGVjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9idXR0b25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvY29yZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9maWVsZHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxlcnRUcmlhbmdsZUljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25DZW50ZXJJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsaWduTGVmdEljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25SaWdodEljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQm9sZEljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ2hldnJvbkRvd25JY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0NoZXZyb25SaWdodEljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ29kZUljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ29sdW1uc0ljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvRXh0ZXJuYWxMaW5rSWNvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9FeWVJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0V5ZU9mZkljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvSXRhbGljSWNvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9MaW5rSWNvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9NYXhpbWl6ZTJJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01pbmltaXplMkljb25cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTWludXNJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01vcmVIb3Jpem9udGFsSWNvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9QbHVzSWNvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9UcmFzaDJJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL1hJY29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL2xvYWRpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvbW9kYWxzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL25vdGljZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBrZXlzdG9uZS11aS9waWxsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGtleXN0b25lLXVpL3BvcG92ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvc2VnbWVudGVkLWNvbnRyb2xcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvdG9hc3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAa2V5c3RvbmUtdWkvdG9vbHRpcFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImFwb2xsby11cGxvYWQtY2xpZW50XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXBwbHktcmVmXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnl0ZXNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3B5LXRvLWNsaXBib2FyZFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImRhdGUtZm5zXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZGVjaW1hbC5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImR1bWItcGFzc3dvcmRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZmFzdC1kZWVwLWVxdWFsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ3JhcGhxbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImdyYXBocWwtdHlwZS1qc29uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ3JhcGhxbC11cGxvYWQvcHVibGljL0dyYXBoUUxVcGxvYWQuanNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJpbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJpcy1ob3RrZXlcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtYXRjaC1zb3J0ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtZGFzdC11dGlsLWRlZmluaXRpb25zXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbC9mcm9tLW1hcmtkb3duXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWRhc3QtdXRpbC1nZm0tc3RyaWtldGhyb3VnaC9mcm9tLW1hcmtkb3duXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2hcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3Qvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLmpzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbWl0dC5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LmpzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUuanNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwuanNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC5qc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3V0aWxzLmpzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV4dC9yb3V0ZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInNjcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic2xhdGVcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzbGF0ZS1oaXN0b3J5XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic2xhdGUtcmVhY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dWlkXCIiLCJ3ZWJwYWNrOi8vL2lnbm9yZWR8RDpcXFByb2plY3RcXFROU1MtTGFiLUhlYWRsZXNzQ01TXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNoYXJlZFxcbGliXFxyb3V0ZXJ8Li91dGlscy9yZXNvbHZlLXJld3JpdGVzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQyO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gcmVxdWlyZShcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuXG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b1ByaW1pdGl2ZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoXCIuL3RvUHJpbWl0aXZlLmpzXCIpO1xuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Qcm9wZXJ0eUtleTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzJDEgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvZmllbGRzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHNhbml0aXplVXJsID0gcmVxdWlyZSgnQGJyYWludHJlZS9zYW5pdGl6ZS11cmwnKTtcblxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PT0gc2FuaXRpemVVcmwuc2FuaXRpemVVcmwodXJsKTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIl07XG5jb25zdCBmaWVsZHMgPSB7XG4gIHRleHQoe1xuICAgIGxhYmVsLFxuICAgIGRlZmF1bHRWYWx1ZSA9ICcnXG4gIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgYXV0b0ZvY3VzXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMkMS5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzJDEuRmllbGRMYWJlbCwgbnVsbCwgbGFiZWwpLCBjb3JlLmpzeChmaWVsZHMkMS5UZXh0SW5wdXQsIHtcbiAgICAgICAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgb25DaGFuZ2U6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuXG4gICAgICBvcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWUsXG5cbiAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfSxcblxuICB1cmwoe1xuICAgIGxhYmVsLFxuICAgIGRlZmF1bHRWYWx1ZSA9ICcnXG4gIH0pIHtcbiAgICBjb25zdCB2YWxpZGF0ZSA9IHZhbHVlID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICh2YWx1ZSA9PT0gJycgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgYXV0b0ZvY3VzLFxuICAgICAgICBmb3JjZVZhbGlkYXRpb25cbiAgICAgIH0pIHtcbiAgICAgICAgY29uc3QgW2JsdXJyZWQsIHNldEJsdXJyZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCBzaG93VmFsaWRhdGlvbiA9IGZvcmNlVmFsaWRhdGlvbiB8fCBibHVycmVkICYmICF2YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMkMS5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzJDEuRmllbGRMYWJlbCwgbnVsbCwgbGFiZWwpLCBjb3JlLmpzeChmaWVsZHMkMS5UZXh0SW5wdXQsIHtcbiAgICAgICAgICBvbkJsdXI6ICgpID0+IHtcbiAgICAgICAgICAgIHNldEJsdXJyZWQodHJ1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgb25DaGFuZ2U6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgc2hvd1ZhbGlkYXRpb24gJiYgY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmVkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIFVSTFwiKSk7XG4gICAgICB9LFxuXG4gICAgICBvcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICB2YWxpZGF0ZVxuICAgIH07XG4gIH0sXG5cbiAgc2VsZWN0KHtcbiAgICBsYWJlbCxcbiAgICBvcHRpb25zLFxuICAgIGRlZmF1bHRWYWx1ZVxuICB9KSB7XG4gICAgY29uc3Qgb3B0aW9uVmFsdWVzU2V0ID0gbmV3IFNldChvcHRpb25zLm1hcCh4ID0+IHgudmFsdWUpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgYXV0b0ZvY3VzXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMkMS5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzJDEuRmllbGRMYWJlbCwgbnVsbCwgbGFiZWwpLCBjb3JlLmpzeChmaWVsZHMkMS5TZWxlY3QsIHtcbiAgICAgICAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5maW5kKG9wdGlvbiA9PiBvcHRpb24udmFsdWUgPT09IHZhbHVlKSB8fCBudWxsLFxuICAgICAgICAgIG9uQ2hhbmdlOiBvcHRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICBvbkNoYW5nZShvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuXG4gICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBvcHRpb25WYWx1ZXNTZXQuaGFzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgIH07XG4gIH0sXG5cbiAgbXVsdGlzZWxlY3Qoe1xuICAgIGxhYmVsLFxuICAgIG9wdGlvbnMsXG4gICAgZGVmYXVsdFZhbHVlXG4gIH0pIHtcbiAgICBjb25zdCB2YWx1ZXNUb09wdGlvbiA9IG5ldyBNYXAob3B0aW9ucy5tYXAoeCA9PiBbeC52YWx1ZSwgeF0pKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgYXV0b0ZvY3VzXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMkMS5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzJDEuRmllbGRMYWJlbCwgbnVsbCwgbGFiZWwpLCBjb3JlLmpzeChmaWVsZHMkMS5NdWx0aVNlbGVjdCwge1xuICAgICAgICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZS5tYXAoeCA9PiB2YWx1ZXNUb09wdGlvbi5nZXQoeCkpLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgb25DaGFuZ2U6IG9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2Uob3B0aW9ucy5tYXAoeCA9PiB4LnZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuXG4gICAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZXNUb09wdGlvbi5oYXModmFsdWUpKTtcbiAgICAgIH1cblxuICAgIH07XG4gIH0sXG5cbiAgY2hlY2tib3goe1xuICAgIGxhYmVsLFxuICAgIGRlZmF1bHRWYWx1ZSA9IGZhbHNlXG4gIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgYXV0b0ZvY3VzXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMkMS5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzJDEuQ2hlY2tib3gsIHtcbiAgICAgICAgICBjaGVja2VkOiB2YWx1ZSxcbiAgICAgICAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICAgICAgICBvbkNoYW5nZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbGFiZWwpKTtcbiAgICAgIH0sXG5cbiAgICAgIG9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZSxcblxuICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfSxcblxuICBlbXB0eSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2Zvcm0nLFxuXG4gICAgICBJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuXG4gICAgICBvcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcblxuICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9O1xuICB9LFxuXG4gIGNoaWxkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2NoaWxkJyxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMua2luZCA9PT0gJ2Jsb2NrJyA/IHtcbiAgICAgICAga2luZDogJ2Jsb2NrJyxcbiAgICAgICAgcGxhY2Vob2xkZXI6IG9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICAgIGRpdmlkZXJzOiBvcHRpb25zLmRpdmlkZXJzLFxuICAgICAgICBmb3JtYXR0aW5nOiBvcHRpb25zLmZvcm1hdHRpbmcgPT09ICdpbmhlcml0JyA/IHtcbiAgICAgICAgICBibG9ja1R5cGVzOiAnaW5oZXJpdCcsXG4gICAgICAgICAgaGVhZGluZ0xldmVsczogJ2luaGVyaXQnLFxuICAgICAgICAgIGlubGluZU1hcmtzOiAnaW5oZXJpdCcsXG4gICAgICAgICAgbGlzdFR5cGVzOiAnaW5oZXJpdCcsXG4gICAgICAgICAgYWxpZ25tZW50OiAnaW5oZXJpdCcsXG4gICAgICAgICAgc29mdEJyZWFrczogJ2luaGVyaXQnXG4gICAgICAgIH0gOiBvcHRpb25zLmZvcm1hdHRpbmcsXG4gICAgICAgIGxpbmtzOiBvcHRpb25zLmxpbmtzLFxuICAgICAgICByZWxhdGlvbnNoaXBzOiBvcHRpb25zLnJlbGF0aW9uc2hpcHNcbiAgICAgIH0gOiB7XG4gICAgICAgIGtpbmQ6ICdpbmxpbmUnLFxuICAgICAgICBwbGFjZWhvbGRlcjogb3B0aW9ucy5wbGFjZWhvbGRlcixcbiAgICAgICAgZm9ybWF0dGluZzogb3B0aW9ucy5mb3JtYXR0aW5nID09PSAnaW5oZXJpdCcgPyB7XG4gICAgICAgICAgaW5saW5lTWFya3M6ICdpbmhlcml0JyxcbiAgICAgICAgICBzb2Z0QnJlYWtzOiAnaW5oZXJpdCdcbiAgICAgICAgfSA6IG9wdGlvbnMuZm9ybWF0dGluZyxcbiAgICAgICAgbGlua3M6IG9wdGlvbnMubGlua3MsXG4gICAgICAgIHJlbGF0aW9uc2hpcHM6IG9wdGlvbnMucmVsYXRpb25zaGlwc1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgb2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIGNvbmRpdGlvbmFsKGRpc2NyaW1pbmFudCwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdjb25kaXRpb25hbCcsXG4gICAgICBkaXNjcmltaW5hbnQsXG4gICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgIH07XG4gIH0sXG5cbiAgcmVsYXRpb25zaGlwKHtcbiAgICByZWxhdGlvbnNoaXAsXG4gICAgbGFiZWxcbiAgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAncmVsYXRpb25zaGlwJyxcbiAgICAgIHJlbGF0aW9uc2hpcCxcbiAgICAgIGxhYmVsXG4gICAgfTtcbiAgfVxuXG59O1xuZnVuY3Rpb24gY29tcG9uZW50KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5jb25zdCBOb3RFZGl0YWJsZSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICByZXR1cm4gY29yZS5qc3goXCJzcGFuXCIsIF9leHRlbmRzKHtcbiAgICBjc3M6IHtcbiAgICAgIHVzZXJTZWxlY3Q6ICdub25lJ1xuICAgIH0sXG4gICAgY29udGVudEVkaXRhYmxlOiBmYWxzZVxuICB9LCBwcm9wcyksIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydHMuTm90RWRpdGFibGUgPSBOb3RFZGl0YWJsZTtcbmV4cG9ydHMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuZXhwb3J0cy5maWVsZHMgPSBmaWVsZHM7XG5leHBvcnRzLmlzVmFsaWRVUkwgPSBpc1ZhbGlkVVJMO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGlzSG90a2V5ID0gcmVxdWlyZSgnaXMtaG90a2V5Jyk7XG52YXIgc2xhdGUgPSByZXF1aXJlKCdzbGF0ZScpO1xudmFyIHNsYXRlUmVhY3QgPSByZXF1aXJlKCdzbGF0ZS1yZWFjdCcpO1xudmFyIHNsYXRlSGlzdG9yeSA9IHJlcXVpcmUoJ3NsYXRlLWhpc3RvcnknKTtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpO1xudmFyIHBvcG92ZXIgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvcG9wb3ZlcicpO1xudmFyIHRvb2x0aXAgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvdG9vbHRpcCcpO1xudmFyIExpbmtJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0xpbmtJY29uJyk7XG52YXIgVHJhc2gySWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9UcmFzaDJJY29uJyk7XG52YXIgRXh0ZXJuYWxMaW5rSWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9FeHRlcm5hbExpbmtJY29uJyk7XG52YXIgdG9vbGJhciA9IHJlcXVpcmUoJy4vdG9vbGJhci0yNzAwZDk3Yy5janMuZGV2LmpzJyk7XG52YXIgX29iamVjdFNwcmVhZCA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMicpO1xudmFyIGFwaSA9IHJlcXVpcmUoJy4vYXBpLTkzNDM2MDI1LmNqcy5kZXYuanMnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnQGtleXN0b25lLW5leHQva2V5c3RvbmUvYWRtaW4tdWkvY29udGV4dCcpO1xudmFyIFJlbGF0aW9uc2hpcFNlbGVjdCA9IHJlcXVpcmUoJ0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9yZWxhdGlvbnNoaXAvdmlld3MvUmVsYXRpb25zaGlwU2VsZWN0Jyk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xudmFyIGZpZWxkcyA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9maWVsZHMnKTtcbnZhciBidXR0b24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvYnV0dG9uJyk7XG52YXIgd2Vha01lbW9pemUgPSByZXF1aXJlKCdAZW1vdGlvbi93ZWFrLW1lbW9pemUnKTtcbnZhciBDb2x1bW5zSWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Db2x1bW5zSWNvbicpO1xudmFyIGFwcGx5UmVmID0gcmVxdWlyZSgnYXBwbHktcmVmJyk7XG52YXIgQm9sZEljb24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQm9sZEljb24nKTtcbnZhciBJdGFsaWNJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0l0YWxpY0ljb24nKTtcbnZhciBQbHVzSWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9QbHVzSWNvbicpO1xudmFyIENoZXZyb25Eb3duSWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uRG93bkljb24nKTtcbnZhciBNYXhpbWl6ZTJJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01heGltaXplMkljb24nKTtcbnZhciBNaW5pbWl6ZTJJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01pbmltaXplMkljb24nKTtcbnZhciBNb3JlSG9yaXpvbnRhbEljb24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTW9yZUhvcml6b250YWxJY29uJyk7XG52YXIgQ29kZUljb24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ29kZUljb24nKTtcbnZhciBBbGlnbkxlZnRJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsaWduTGVmdEljb24nKTtcbnZhciBBbGlnblJpZ2h0SWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9BbGlnblJpZ2h0SWNvbicpO1xudmFyIEFsaWduQ2VudGVySWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9BbGlnbkNlbnRlckljb24nKTtcbnZhciBNaW51c0ljb24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTWludXNJY29uJyk7XG52YXIgbWF0Y2hTb3J0ZXIgPSByZXF1aXJlKCdtYXRjaC1zb3J0ZXInKTtcbnZhciBzY3JvbGxJbnRvVmlldyA9IHJlcXVpcmUoJ3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkJyk7XG52YXIgbWRBU1RVdGlsRnJvbU1hcmtkb3duID0gcmVxdWlyZSgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJyk7XG52YXIgYXV0b0xpbmtMaXRlcmFsRnJvbU1hcmtkb3duRXh0ZW5zaW9uID0gcmVxdWlyZSgnbWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbC9mcm9tLW1hcmtkb3duJyk7XG52YXIgYXV0b0xpbmtMaXRlcmFsTWFya2Rvd25TeW50YXggPSByZXF1aXJlKCdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsJyk7XG52YXIgZ2ZtU3RyaWtldGhyb3VnaEZyb21NYXJrZG93bkV4dGVuc2lvbiA9IHJlcXVpcmUoJ21kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2gvZnJvbS1tYXJrZG93bicpO1xudmFyIGdmbVN0cmlrZXRocm91Z2hNYXJrZG93blN5bnRheCA9IHJlcXVpcmUoJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gnKTtcbnZhciBkZWZpbml0aW9ucyA9IHJlcXVpcmUoJ21kYXN0LXV0aWwtZGVmaW5pdGlvbnMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIGlzSG90a2V5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChpc0hvdGtleSk7XG52YXIgd2Vha01lbW9pemVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KHdlYWtNZW1vaXplKTtcbnZhciBzY3JvbGxJbnRvVmlld19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoc2Nyb2xsSW50b1ZpZXcpO1xudmFyIG1kQVNUVXRpbEZyb21NYXJrZG93bl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQobWRBU1RVdGlsRnJvbU1hcmtkb3duKTtcbnZhciBhdXRvTGlua0xpdGVyYWxGcm9tTWFya2Rvd25FeHRlbnNpb25fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGF1dG9MaW5rTGl0ZXJhbEZyb21NYXJrZG93bkV4dGVuc2lvbik7XG52YXIgYXV0b0xpbmtMaXRlcmFsTWFya2Rvd25TeW50YXhfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGF1dG9MaW5rTGl0ZXJhbE1hcmtkb3duU3ludGF4KTtcbnZhciBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duRXh0ZW5zaW9uX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duRXh0ZW5zaW9uKTtcbnZhciBnZm1TdHJpa2V0aHJvdWdoTWFya2Rvd25TeW50YXhfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGdmbVN0cmlrZXRocm91Z2hNYXJrZG93blN5bnRheCk7XG52YXIgZGVmaW5pdGlvbnNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGRlZmluaXRpb25zKTtcblxuY29uc3QgcGFyYWdyYXBoRWxlbWVudCA9ICgpID0+ICh7XG4gIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICBjaGlsZHJlbjogW3tcbiAgICB0ZXh0OiAnJ1xuICB9XVxufSk7XG5mdW5jdGlvbiB3aXRoUGFyYWdyYXBocyhlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIG5vcm1hbGl6ZU5vZGVcbiAgfSA9IGVkaXRvcjtcblxuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcblxuICAgIGlmIChzbGF0ZS5FZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIGxldCBsYXN0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKChsYXN0Tm9kZSA9PT0gbnVsbCB8fCBsYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdE5vZGUudHlwZSkgIT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBwYXJhZ3JhcGhFbGVtZW50KCksIHtcbiAgICAgICAgICBhdDogWy4uLnBhdGgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmNvbnN0IGFsbE1hcmtzID0gWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnc3RyaWtldGhyb3VnaCcsICdjb2RlJywgJ3N1cGVyc2NyaXB0JywgJ3N1YnNjcmlwdCcsICdrZXlib2FyZCddO1xuY29uc3QgaXNFbGVtZW50QWN0aXZlID0gKGVkaXRvciwgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IFttYXRjaF0gPSBzbGF0ZS5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG4gPT4gbi50eXBlID09PSBmb3JtYXRcbiAgfSk7XG4gIHJldHVybiAhIW1hdGNoO1xufTtcbmZ1bmN0aW9uIGNsZWFyRm9ybWF0dGluZyhlZGl0b3IpIHtcbiAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdoZWFkaW5nJyB8fCBub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJyB8fCBub2RlLnR5cGUgPT09ICdjb2RlJ1xuICB9KTtcbiAgc2xhdGUuVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgYWxsTWFya3MsIHtcbiAgICBtYXRjaDogc2xhdGUuVGV4dC5pc1RleHRcbiAgfSk7XG59XG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBwYXJlbnQsIHRvLCBzaG91bGRNb3ZlTm9kZSA9ICgpID0+IHRydWUpIHtcbiAgY29uc3QgcGFyZW50UGF0aCA9IHNsYXRlLlBhdGguaXNQYXRoKHBhcmVudCkgPyBwYXJlbnQgOiBwYXJlbnRbMV07XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBzbGF0ZS5QYXRoLmlzUGF0aChwYXJlbnQpID8gc2xhdGUuTm9kZS5nZXQoZWRpdG9yLCBwYXJlbnRQYXRoKSA6IHBhcmVudFswXTtcbiAgaWYgKCFzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIHBhcmVudE5vZGUpKSByZXR1cm47XG5cbiAgZm9yIChsZXQgaSA9IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoc2hvdWxkTW92ZU5vZGUocGFyZW50Tm9kZS5jaGlsZHJlbltpXSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpXTtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICB0b1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59IC8vIHRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gY2hhbmdlcyBoYXBwZW4sIHRoZXkgYXJlIGltbWVkaWF0ZWx5IHNob3duXG4vLyB0aGlzIHN0b3BzIHRoZSBwcm9ibGVtIG9mIGEgY3Vyc29yIHJlc2V0dGluZyB0byB0aGUgZW5kIHdoZW4gYSBjaGFuZ2UgaXMgbWFkZVxuLy8gYmVjYXVzZSB0aGUgY2hhbmdlcyBhcmUgYXBwbGllZCBhc3luY2hyb25vdXNseVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50V2l0aFNldE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBlbGVtZW50LFxuICAgIGVsZW1lbnRXaXRoQ2hhbmdlczogZWxlbWVudFxuICB9KTtcblxuICBpZiAoc3RhdGUuZWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBlbGVtZW50V2l0aENoYW5nZXM6IGVsZW1lbnRcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNldE5vZGVzID0gY2hhbmdlcyA9PiB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIGNoYW5nZXMsIHtcbiAgICAgIGF0OiBzbGF0ZVJlYWN0LlJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudClcbiAgICB9KTtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBlbGVtZW50LFxuICAgICAgZWxlbWVudFdpdGhDaGFuZ2VzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCBjaGFuZ2VzKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBbc3RhdGUuZWxlbWVudFdpdGhDaGFuZ2VzLCBzZXROb2Rlc107XG59XG5mdW5jdGlvbiB1c2VFdmVudENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGNhbGxiYWNrUmVmID0gUmVhY3QudXNlUmVmKGNhbGxiYWNrKTtcbiAgY29uc3QgY2IgPSBSZWFjdC51c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBjYWxsYmFja1JlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIGNiO1xufVxuY29uc3QgSVNfTUFDID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBtb2RpZmllcktleVRleHQgPSBJU19NQUMgPyAn4oyYJyA6ICdDdHJsJztcbmNvbnN0IEZvcmNlVmFsaWRhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuY29uc3QgRm9yY2VWYWxpZGF0aW9uUHJvdmlkZXIgPSBGb3JjZVZhbGlkYXRpb25Db250ZXh0LlByb3ZpZGVyO1xuZnVuY3Rpb24gdXNlRm9yY2VWYWxpZGF0aW9uKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChGb3JjZVZhbGlkYXRpb25Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIGluc2VydE5vZGVzQnV0UmVwbGFjZUlmU2VsZWN0aW9uSXNBdEVtcHR5UGFyYWdyYXBoT3JIZWFkaW5nKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIF9wYXRoUmVmRm9yRW1wdHlOb2RlQTtcblxuICBsZXQgcGF0aFJlZkZvckVtcHR5Tm9kZUF0Q3Vyc29yO1xuICBjb25zdCBlbnRyeSA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdoZWFkaW5nJyB8fCBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnXG4gIH0pO1xuXG4gIGlmIChlbnRyeSAmJiBzbGF0ZS5Ob2RlLnN0cmluZyhlbnRyeVswXSkgPT09ICcnKSB7XG4gICAgcGF0aFJlZkZvckVtcHR5Tm9kZUF0Q3Vyc29yID0gc2xhdGUuRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbnRyeVsxXSk7XG4gIH1cblxuICBzbGF0ZS5UcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpO1xuICBsZXQgcGF0aCA9IChfcGF0aFJlZkZvckVtcHR5Tm9kZUEgPSBwYXRoUmVmRm9yRW1wdHlOb2RlQXRDdXJzb3IpID09PSBudWxsIHx8IF9wYXRoUmVmRm9yRW1wdHlOb2RlQSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhdGhSZWZGb3JFbXB0eU5vZGVBLnVucmVmKCk7XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTsgLy8gZXZlbiB0aG91Z2ggdGhlIHNlbGVjdGlvbiBpcyBpbiB0aGUgcmlnaHQgcGxhY2UgYWZ0ZXIgdGhlIHJlbW92ZU5vZGVzXG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIHRoZSBlZGl0b3IgYmx1cnMgc28gd2UgbmVlZCB0byBmb2N1cyBpdCBhZ2FpblxuXG4gICAgc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBFZGl0b3IuYWZ0ZXIgZXhjZXB0IHRoYXQgaXQgaWdub3JlcyBwb2ludHMgdGhhdCBoYXZlIG5vIGNvbnRlbnRcbiAqIGxpa2UgdGhlIHBvaW50IGluIGEgdm9pZCB0ZXh0IG5vZGUsIGFuIGVtcHR5IHRleHQgbm9kZSBhbmQgdGhlIGxhc3QgcG9pbnQgaW4gYSB0ZXh0IG5vZGVcbiAqL1xuLy8gVE9ETzogdGhpcyB3b3VsZCBwcm9iYWJseSBicmVhayBpZiB5b3Ugd2VyZSB0cnlpbmcgdG8gZ2V0IHRoZSBsYXN0IHBvaW50IGluIHRoZSBlZGl0b3I/XG5cbmZ1bmN0aW9uIEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50KGVkaXRvciwgYXQsIHtcbiAgZGlzdGFuY2UgPSAxXG59ID0ge30pIHtcbiAgY29uc3QgYW5jaG9yID0gc2xhdGUuRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgY29uc3QgZm9jdXMgPSBzbGF0ZS5FZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICBjb25zdCByYW5nZSA9IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbiAgbGV0IGQgPSAwO1xuICBsZXQgdGFyZ2V0O1xuXG4gIGZvciAoY29uc3QgcCBvZiBzbGF0ZS5FZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiByYW5nZVxuICB9KSkge1xuICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gdGhpcyBpcyB0aGUgaW1wb3J0YW50IGNoYW5nZVxuXG5cbiAgICBjb25zdCBub2RlID0gc2xhdGUuTm9kZS5nZXQoZWRpdG9yLCBwLnBhdGgpO1xuXG4gICAgaWYgKG5vZGUudGV4dC5sZW5ndGggPT09IHAub2Zmc2V0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgdGFyZ2V0ID0gcDtcbiAgICB9XG5cbiAgICBkKys7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbm9kZVR5cGVNYXRjaGVyKC4uLmFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdHlwZSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIG5vZGUgPT4gbm9kZS50eXBlID09PSB0eXBlO1xuICB9XG5cbiAgY29uc3Qgc2V0ID0gbmV3IFNldChhcmdzKTtcbiAgcmV0dXJuIG5vZGUgPT4gdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZycgJiYgc2V0Lmhhcyhub2RlLnR5cGUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIGFzc2VydCcpO1xuICB9XG59XG5cbmNvbnN0IERvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcbmZ1bmN0aW9uIHVzZURvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChEb2N1bWVudEZpZWxkUmVsYXRpb25zaGlwc0NvbnRleHQpO1xufVxuY29uc3QgRG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHNQcm92aWRlciA9IERvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzQ29udGV4dC5Qcm92aWRlcjtcbmZ1bmN0aW9uIHdpdGhSZWxhdGlvbnNoaXAoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpc1ZvaWQsXG4gICAgaXNJbmxpbmVcbiAgfSA9IGVkaXRvcjtcblxuICBlZGl0b3IuaXNWb2lkID0gZWxlbWVudCA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gJ3JlbGF0aW9uc2hpcCcgfHwgaXNWb2lkKGVsZW1lbnQpO1xuICB9O1xuXG4gIGVkaXRvci5pc0lubGluZSA9IGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09ICdyZWxhdGlvbnNoaXAnIHx8IGlzSW5saW5lKGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59XG5mdW5jdGlvbiBSZWxhdGlvbnNoaXBCdXR0b24oe1xuICBvbkNsb3NlXG59KSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsXG4gICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgaXNEaXNhYmxlZFxuICAgIH1cbiAgfSA9IHVzZVRvb2xiYXJTdGF0ZSgpO1xuICBjb25zdCByZWxhdGlvbnNoaXBzID0gUmVhY3QudXNlQ29udGV4dChEb2N1bWVudEZpZWxkUmVsYXRpb25zaGlwc0NvbnRleHQpO1xuICByZXR1cm4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIE9iamVjdC5lbnRyaWVzKHJlbGF0aW9uc2hpcHMpLm1hcCgoW2tleSwgcmVsYXRpb25zaGlwXSkgPT4ge1xuICAgIGlmIChyZWxhdGlvbnNoaXAua2luZCA9PT0gJ3Byb3AnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIHR5cGU6ICdyZWxhdGlvbnNoaXAnLFxuICAgICAgICAgIHJlbGF0aW9uc2hpcDoga2V5LFxuICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgfSwgcmVsYXRpb25zaGlwLmxhYmVsKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gUmVsYXRpb25zaGlwRWxlbWVudCh7XG4gIGF0dHJpYnV0ZXMsXG4gIGNoaWxkcmVuLFxuICBlbGVtZW50XG59KSB7XG4gIGNvbnN0IGtleXN0b25lID0gY29udGV4dC51c2VLZXlzdG9uZSgpO1xuICBjb25zdCBlZGl0b3IgPSBzbGF0ZVJlYWN0LnVzZVNsYXRlU3RhdGljKCk7XG4gIGNvbnN0IHJlbGF0aW9uc2hpcHMgPSBSZWFjdC51c2VDb250ZXh0KERvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzQ29udGV4dCk7XG4gIGNvbnN0IHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcHNbZWxlbWVudC5yZWxhdGlvbnNoaXBdO1xuICByZXR1cm4gY29yZS5qc3goXCJzcGFuXCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY3NzOiB7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcbiAgICB9XG4gIH0pLCBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgY3NzOiB7XG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICB3aWR0aDogMjAwLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgIGZsZXg6IDFcbiAgICB9XG4gIH0sIHJlbGF0aW9uc2hpcCA/IGNvcmUuanN4KFJlbGF0aW9uc2hpcFNlbGVjdC5SZWxhdGlvbnNoaXBTZWxlY3QsIHtcbiAgICBjb250cm9sU2hvdWxkUmVuZGVyVmFsdWU6IHRydWUsXG4gICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgbGlzdDoga2V5c3RvbmUuYWRtaW5NZXRhLmxpc3RzW3JlbGF0aW9uc2hpcC5saXN0S2V5XSxcbiAgICBwb3J0YWxNZW51OiB0cnVlLFxuICAgIHN0YXRlOiB7XG4gICAgICBraW5kOiAnb25lJyxcbiAgICAgIHZhbHVlOiBlbGVtZW50LmRhdGEgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgICBpZDogZWxlbWVudC5kYXRhLmlkLFxuICAgICAgICBsYWJlbDogZWxlbWVudC5kYXRhLmxhYmVsIHx8IGVsZW1lbnQuZGF0YS5pZFxuICAgICAgfSxcblxuICAgICAgb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBkYXRhOiB2YWx1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHNsYXRlUmVhY3QuUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH1cbiAgfSkgOiAnSW52YWxpZCByZWxhdGlvbnNoaXAnKSwgY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGZsZXg6IDBcbiAgICB9XG4gIH0sIGNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSh0eXBlLCBjb21wb25lbnRCbG9jaywgcmVsYXRpb25zaGlwcykge1xuICBjb25zdCBwcm9wcyA9IGdldEluaXRpYWxQcm9wc1ZhbHVlKHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICB2YWx1ZTogY29tcG9uZW50QmxvY2sucHJvcHNcbiAgfSwgcmVsYXRpb25zaGlwcyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2NvbXBvbmVudC1ibG9jaycsXG4gICAgY29tcG9uZW50OiB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuOiBmaW5kQ2hpbGRQcm9wUGF0aHMocHJvcHMsIGNvbXBvbmVudEJsb2NrLnByb3BzKS5tYXAoeCA9PiAoe1xuICAgICAgdHlwZTogYGNvbXBvbmVudC0ke3gub3B0aW9ucy5raW5kfS1wcm9wYCxcbiAgICAgIHByb3BQYXRoOiB4LnBhdGgsXG4gICAgICBjaGlsZHJlbjogW3gub3B0aW9ucy5raW5kID09PSAnYmxvY2snID8ge1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfV1cbiAgICAgIH0gOiB7XG4gICAgICAgIHRleHQ6ICcnXG4gICAgICB9XVxuICAgIH0pKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFByb3BzVmFsdWUocHJvcCwgcmVsYXRpb25zaGlwcykge1xuICBzd2l0Y2ggKHByb3Aua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHByb3AuZGVmYXVsdFZhbHVlO1xuXG4gICAgY2FzZSAnY2hpbGQnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3JlbGF0aW9uc2hpcCc6XG4gICAgICByZXR1cm4gcmVsYXRpb25zaGlwc1twcm9wLnJlbGF0aW9uc2hpcF0ubWFueSA/IFtdIDogbnVsbDtcblxuICAgIGNhc2UgJ2NvbmRpdGlvbmFsJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gcHJvcC5kaXNjcmltaW5hbnQuZGVmYXVsdFZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc2NyaW1pbmFudDogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBnZXRJbml0aWFsUHJvcHNWYWx1ZShwcm9wLnZhbHVlc1tkZWZhdWx0VmFsdWVdLCByZWxhdGlvbnNoaXBzKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wLnZhbHVlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgb2JqW2tleV0gPSBnZXRJbml0aWFsUHJvcHNWYWx1ZShwcm9wLnZhbHVlW2tleV0sIHJlbGF0aW9uc2hpcHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgfVxuXG4gIGFzc2VydE5ldmVyKHByb3ApO1xufVxuXG5mdW5jdGlvbiBfZmluZENoaWxkUHJvcFBhdGhzKHZhbHVlLCBwcm9wLCBwYXRoKSB7XG4gIHN3aXRjaCAocHJvcC5raW5kKSB7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgY2FzZSAncmVsYXRpb25zaGlwJzpcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGNhc2UgJ2NoaWxkJzpcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBvcHRpb25zOiBwcm9wLm9wdGlvbnNcbiAgICAgIH1dO1xuXG4gICAgY2FzZSAnY29uZGl0aW9uYWwnOlxuICAgICAgcmV0dXJuIF9maW5kQ2hpbGRQcm9wUGF0aHModmFsdWUudmFsdWUsIHByb3AudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF0sIHBhdGguY29uY2F0KCd2YWx1ZScpKTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGxldCBwYXRocyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wLnZhbHVlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgcGF0aHMucHVzaCguLi5fZmluZENoaWxkUHJvcFBhdGhzKHZhbHVlW2tleV0sIHByb3AudmFsdWVba2V5XSwgcGF0aC5jb25jYXQoa2V5KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZFByb3BQYXRocyh2YWx1ZSwgcHJvcHMpIHtcbiAgbGV0IHByb3BQYXRocyA9IF9maW5kQ2hpbGRQcm9wUGF0aHModmFsdWUsIHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICB2YWx1ZTogcHJvcHNcbiAgfSwgW10pO1xuXG4gIGlmICghcHJvcFBhdGhzLmxlbmd0aCkge1xuICAgIHJldHVybiBbe1xuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBraW5kOiAnaW5saW5lJyxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICcnXG4gICAgICB9XG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gcHJvcFBhdGhzO1xufVxuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoYXJnKSB7XG4gIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdG8gbmV2ZXIgYmUgY2FsbGVkIGJ1dCByZWNlaXZlZDogJyArIEpTT04uc3RyaW5naWZ5KGFyZykpO1xufVxuZnVuY3Rpb24gZ2V0UHJvcHNGb3JDb25kaXRpb25hbENoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUsIHByb3AsIHJlbGF0aW9uc2hpcHMpIHtcbiAgaWYgKG5ld1ZhbHVlLmRpc2NyaW1pbmFudCAhPT0gb2xkVmFsdWUuZGlzY3JpbWluYW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc2NyaW1pbmFudDogbmV3VmFsdWUuZGlzY3JpbWluYW50LFxuICAgICAgdmFsdWU6IGdldEluaXRpYWxQcm9wc1ZhbHVlKHByb3AudmFsdWVzW25ld1ZhbHVlLmRpc2NyaW1pbmFudF0sIHJlbGF0aW9uc2hpcHMpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RmVhdHVyZXNGb3JDaGlsZEZpZWxkKGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGZvcm1hdHRpbmcsIF9vcHRpb25zJGZvcm1hdHRpbmczLCBfb3B0aW9ucyRmb3JtYXR0aW5nNCwgX29wdGlvbnMkZm9ybWF0dGluZzUsIF9vcHRpb25zJGZvcm1hdHRpbmc2LCBfb3B0aW9ucyRmb3JtYXR0aW5nNywgX29wdGlvbnMkZm9ybWF0dGluZzg7XG5cbiAgLy8gYW4gaW1wb3J0YW50IG5vdGUgZm9yIHRoaXM6IG5vcm1hbGl6YXRpb24gYmFzZWQgb24gZG9jdW1lbnQgZmVhdHVyZXNcbiAgLy8gaXMgZG9uZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQgZmVhdHVyZXMgcmV0dXJuZWQgaGVyZVxuICAvLyBhbmQgdGhlIGVkaXRvciBkb2N1bWVudCBmZWF0dXJlc1xuICAvLyBzbyB0aGUgcmVzdWx0IGZvciBhbnkgZ2l2ZW4gY2hpbGQgcHJvcCB3aWxsIGJlIHRoZSB0aGluZ3MgdGhhdCBhcmVcbiAgLy8gYWxsb3dlZCBieSBib3RoIHRoZXNlIGRvY3VtZW50IGZlYXR1cmVzXG4gIC8vIEFORCB0aGUgZWRpdG9yIGRvY3VtZW50IGZlYXR1cmVzXG4gIGNvbnN0IGlubGluZU1hcmtzRnJvbU9wdGlvbnMgPSAoX29wdGlvbnMkZm9ybWF0dGluZyA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZy5pbmxpbmVNYXJrcztcbiAgY29uc3QgaW5saW5lTWFya3MgPSBpbmxpbmVNYXJrc0Zyb21PcHRpb25zID09PSAnaW5oZXJpdCcgPyAnaW5oZXJpdCcgOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmlubGluZU1hcmtzKS5tYXAobWFyayA9PiB7XG4gICAgcmV0dXJuIFttYXJrLCAhIShpbmxpbmVNYXJrc0Zyb21PcHRpb25zIHx8IHt9KVttYXJrXV07XG4gIH0pKTtcblxuICBpZiAob3B0aW9ucy5raW5kID09PSAnaW5saW5lJykge1xuICAgIHZhciBfb3B0aW9ucyRmb3JtYXR0aW5nMjtcblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnaW5saW5lJyxcbiAgICAgIGlubGluZU1hcmtzLFxuICAgICAgZG9jdW1lbnRGZWF0dXJlczoge1xuICAgICAgICBsaW5rczogb3B0aW9ucy5saW5rcyA9PT0gJ2luaGVyaXQnLFxuICAgICAgICByZWxhdGlvbnNoaXBzOiBvcHRpb25zLnJlbGF0aW9uc2hpcHMgPT09ICdpbmhlcml0J1xuICAgICAgfSxcbiAgICAgIHNvZnRCcmVha3M6ICgoX29wdGlvbnMkZm9ybWF0dGluZzIgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nMi5zb2Z0QnJlYWtzKSA9PT0gJ2luaGVyaXQnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2luZDogJ2Jsb2NrJyxcbiAgICBpbmxpbmVNYXJrcyxcbiAgICBzb2Z0QnJlYWtzOiAoKF9vcHRpb25zJGZvcm1hdHRpbmczID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZzMuc29mdEJyZWFrcykgPT09ICdpbmhlcml0JyxcbiAgICBkb2N1bWVudEZlYXR1cmVzOiB7XG4gICAgICBsYXlvdXRzOiBbXSxcbiAgICAgIGRpdmlkZXJzOiBvcHRpb25zLmRpdmlkZXJzID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmRpdmlkZXJzIDogZmFsc2UsXG4gICAgICBmb3JtYXR0aW5nOiB7XG4gICAgICAgIGFsaWdubWVudDogKChfb3B0aW9ucyRmb3JtYXR0aW5nNCA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc0LmFsaWdubWVudCkgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5hbGlnbm1lbnQgOiB7XG4gICAgICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrVHlwZXM6ICgoX29wdGlvbnMkZm9ybWF0dGluZzUgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNS5ibG9ja1R5cGVzKSA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMgOiB7XG4gICAgICAgICAgYmxvY2txdW90ZTogZmFsc2UsXG4gICAgICAgICAgY29kZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGluZ0xldmVsczogKChfb3B0aW9ucyRmb3JtYXR0aW5nNiA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc2LmhlYWRpbmdMZXZlbHMpID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ0xldmVscyA6ICgoX29wdGlvbnMkZm9ybWF0dGluZzcgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNy5oZWFkaW5nTGV2ZWxzKSB8fCBbXSxcbiAgICAgICAgbGlzdFR5cGVzOiAoKF9vcHRpb25zJGZvcm1hdHRpbmc4ID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZzgubGlzdFR5cGVzKSA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmxpc3RUeXBlcyA6IHtcbiAgICAgICAgICBvcmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICB1bm9yZGVyZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5rczogb3B0aW9ucy5saW5rcyA9PT0gJ2luaGVyaXQnLFxuICAgICAgcmVsYXRpb25zaGlwczogb3B0aW9ucy5yZWxhdGlvbnNoaXBzID09PSAnaW5oZXJpdCdcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDaGlsZEZpZWxkQXRQcm9wUGF0aChba2V5LCAuLi5yZXN0T2ZQYXRoXSwgdmFsdWVzLCBwcm9wcykge1xuICBsZXQgcHJvcCA9IHByb3BzW2tleV07XG5cbiAgaWYgKCFwcm9wIHx8IHByb3Aua2luZCA9PT0gJ2Zvcm0nIHx8IHByb3Aua2luZCA9PT0gJ3JlbGF0aW9uc2hpcCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcC5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgY29uc3QgcHJvcFZhbCA9IHByb3AudmFsdWVzW3ZhbHVlc1trZXldLmRpc2NyaW1pbmFudF07XG4gICAgcmV0dXJuIGdldENoaWxkRmllbGRBdFByb3BQYXRoKHJlc3RPZlBhdGgsIHZhbHVlcywge1xuICAgICAgdmFsdWU6IHByb3BWYWxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9wLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkRmllbGRBdFByb3BQYXRoKHJlc3RPZlBhdGgsIHZhbHVlc1trZXldLCBwcm9wLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wO1xufVxuZnVuY3Rpb24gY2xpZW50U2lkZVZhbGlkYXRlUHJvcChwcm9wLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHByb3Aua2luZCkge1xuICAgIGNhc2UgJ2NoaWxkJzpcbiAgICBjYXNlICdyZWxhdGlvbnNoaXAnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHJvcC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICB7XG4gICAgICAgIGlmICghcHJvcC5kaXNjcmltaW5hbnQudmFsaWRhdGUodmFsdWUuZGlzY3JpbWluYW50KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGllbnRTaWRlVmFsaWRhdGVQcm9wKHByb3AudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF0sIHZhbHVlLnZhbHVlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgY2hpbGRQcm9wXSBvZiBPYmplY3QuZW50cmllcyhwcm9wLnZhbHVlKSkge1xuICAgICAgICAgIGlmICghY2xpZW50U2lkZVZhbGlkYXRlUHJvcChjaGlsZFByb3AsIHZhbHVlW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByZXZpZXdQcm9wcyhwcm9wLCB2YWx1ZSwgY2hpbGRyZW5CeVBhdGgsIHBhdGgsIHJlbGF0aW9uc2hpcHMsIG9uRm9ybVByb3BzQ2hhbmdlKSB7XG4gIHN3aXRjaCAocHJvcC5raW5kKSB7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcblxuICAgICAgICBvbkNoYW5nZShuZXdWYWx1ZSkge1xuICAgICAgICAgIG9uRm9ybVByb3BzQ2hhbmdlKG5ld1ZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb25zOiBwcm9wLm9wdGlvbnNcbiAgICAgIH07XG5cbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gY2hpbGRyZW5CeVBhdGhbSlNPTi5zdHJpbmdpZnkocGF0aCldO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcHJldmlld1Byb3BzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3AudmFsdWUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBwcmV2aWV3UHJvcHNba2V5XSA9IF9nZXRQcmV2aWV3UHJvcHMocHJvcC52YWx1ZVtrZXldLCB2YWx1ZVtrZXldLCBjaGlsZHJlbkJ5UGF0aCwgcGF0aC5jb25jYXQoa2V5KSwgcmVsYXRpb25zaGlwcywgbmV3VmFsID0+IHtcbiAgICAgICAgICAgIG9uRm9ybVByb3BzQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICAgICAgICBba2V5XTogbmV3VmFsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJldmlld1Byb3BzO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVsYXRpb25zaGlwJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZSxcblxuICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBvbkZvcm1Qcm9wc0NoYW5nZShuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzY3JpbWluYW50OiB2YWx1ZS5kaXNjcmltaW5hbnQsXG5cbiAgICAgICAgICBvbkNoYW5nZShuZXdEaXNjcmltaW5hbnQpIHtcbiAgICAgICAgICAgIG9uRm9ybVByb3BzQ2hhbmdlKGdldFByb3BzRm9yQ29uZGl0aW9uYWxDaGFuZ2Uoe1xuICAgICAgICAgICAgICBkaXNjcmltaW5hbnQ6IG5ld0Rpc2NyaW1pbmFudCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlXG4gICAgICAgICAgICB9LCB2YWx1ZSwgcHJvcCwgcmVsYXRpb25zaGlwcykpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvcHRpb25zOiBwcm9wLmRpc2NyaW1pbmFudC5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBfZ2V0UHJldmlld1Byb3BzKHByb3AudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF0sIHZhbHVlLnZhbHVlLCBjaGlsZHJlbkJ5UGF0aCwgcGF0aC5jb25jYXQoJ3ZhbHVlJyksIHJlbGF0aW9uc2hpcHMsIHZhbCA9PiB7XG4gICAgICAgICAgICBvbkZvcm1Qcm9wc0NoYW5nZSh7XG4gICAgICAgICAgICAgIGRpc2NyaW1pbmFudDogdmFsdWUuZGlzY3JpbWluYW50LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXZpZXdQcm9wcyhlbGVtZW50LCBjb21wb25lbnRCbG9jaywgY2hpbGRyZW5CeVBhdGgsIHJlbGF0aW9uc2hpcHMsIHNldE5vZGUpIHtcbiAgcmV0dXJuIF9nZXRQcmV2aWV3UHJvcHMoe1xuICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgIHZhbHVlOiBjb21wb25lbnRCbG9jay5wcm9wc1xuICB9LCBlbGVtZW50LnByb3BzLCBjaGlsZHJlbkJ5UGF0aCwgW10sIHJlbGF0aW9uc2hpcHMsIHByb3BzID0+IHtcbiAgICBzZXROb2RlKHtcbiAgICAgIHByb3BzXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyB0aGlzIGlzIGluIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0byB0aGUgb3RoZXIgZm9ybSBpbnB1dHMgYmVjYXVzZSBpdCB1c2VzIHVzZUtleXN0b25lXG4vLyBhbmQgd2Ugd2FudCB0byByZW5kZXIgdGhlIGVkaXRvciBvdXRzaWRlIG9mIHRoZSBBZG1pbiBVSSBvbiB0aGUgZG9jcyBzaXRlXG4vLyBhbmQgYSBjYWxsIHRvIHVzZUtleXN0b25lIHdpbGwgYnJlYWsgb24gdGhlIGRvY3Mgc2l0ZVxuZnVuY3Rpb24gUmVsYXRpb25zaGlwRm9ybUlucHV0KHtcbiAgcHJvcCxcbiAgcGF0aCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXNcbn0pIHtcbiAgY29uc3QgcmVsYXRpb25zaGlwcyA9IHVzZURvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzKCk7XG4gIGNvbnN0IGtleXN0b25lID0gY29udGV4dC51c2VLZXlzdG9uZSgpO1xuICBjb25zdCByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXBzW3Byb3AucmVsYXRpb25zaGlwXTtcbiAgY29uc3Qgc3RyaW5naWZpZWRQYXRoID0gSlNPTi5zdHJpbmdpZnkocGF0aCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoZmllbGRzLkZpZWxkQ29udGFpbmVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoZmllbGRzLkZpZWxkTGFiZWwsIG51bGwsIHByb3AubGFiZWwpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUmVsYXRpb25zaGlwU2VsZWN0LlJlbGF0aW9uc2hpcFNlbGVjdCwge1xuICAgIGF1dG9Gb2N1czogc3RyaW5naWZpZWRQYXRoID09PSBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXMsXG4gICAgY29udHJvbFNob3VsZFJlbmRlclZhbHVlOiB0cnVlLFxuICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgIGxpc3Q6IGtleXN0b25lLmFkbWluTWV0YS5saXN0c1tyZWxhdGlvbnNoaXAubGlzdEtleV0sXG4gICAgZXh0cmFTZWxlY3Rpb246IHJlbGF0aW9uc2hpcC5zZWxlY3Rpb24gfHwgJycsXG4gICAgcG9ydGFsTWVudTogdHJ1ZSxcbiAgICBzdGF0ZTogcmVsYXRpb25zaGlwLm1hbnkgPyB7XG4gICAgICBraW5kOiAnbWFueScsXG4gICAgICB2YWx1ZTogdmFsdWUubWFwKHggPT4gKHtcbiAgICAgICAgaWQ6IHguaWQsXG4gICAgICAgIGxhYmVsOiB4LmxhYmVsIHx8IHguaWQsXG4gICAgICAgIGRhdGE6IHguZGF0YVxuICAgICAgfSkpLFxuICAgICAgb25DaGFuZ2VcbiAgICB9IDoge1xuICAgICAga2luZDogJ29uZScsXG4gICAgICB2YWx1ZTogdmFsdWUgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgbGFiZWw6IHZhbHVlLmxhYmVsIHx8IHZhbHVlLmlkXG4gICAgICB9KSA6IG51bGwsXG4gICAgICBvbkNoYW5nZVxuICAgIH1cbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBGb3JtVmFsdWVDb250ZW50KHtcbiAgcHJvcCxcbiAgcGF0aCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXMsXG4gIGZvcmNlVmFsaWRhdGlvblxufSkge1xuICBjb25zdCByZWxhdGlvbnNoaXBzID0gdXNlRG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHMoKTtcbiAgaWYgKHByb3Aua2luZCA9PT0gJ2NoaWxkJykgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHByb3Aua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KGNvcmUuU3RhY2ssIHtcbiAgICAgIGdhcDogXCJ4bGFyZ2VcIlxuICAgIH0sIE9iamVjdC5lbnRyaWVzKHByb3AudmFsdWUpLm1hcCgoW2tleSwgcHJvcFZhbF0pID0+IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChGb3JtVmFsdWVDb250ZW50LCB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGZvcmNlVmFsaWRhdGlvbjogZm9yY2VWYWxpZGF0aW9uLFxuICAgICAgc3RyaW5naWZpZWRQcm9wUGF0aFRvQXV0b0ZvY3VzOiBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXMsXG4gICAgICBwYXRoOiBwYXRoLmNvbmNhdChrZXkpLFxuICAgICAgcHJvcDogcHJvcFZhbCxcbiAgICAgIHZhbHVlOiB2YWx1ZVtrZXldLFxuICAgICAgb25DaGFuZ2U6IHZhbCA9PiB7XG4gICAgICAgIG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pKSk7XG4gIH1cblxuICBpZiAocHJvcC5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChjb3JlLlN0YWNrLCB7XG4gICAgICBnYXA6IFwieGxhcmdlXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQocHJvcC5kaXNjcmltaW5hbnQuSW5wdXQsIHtcbiAgICAgIGF1dG9Gb2N1czogSlNPTi5zdHJpbmdpZnkocGF0aC5jb25jYXQoJ2Rpc2NyaW1pbmFudCcpKSA9PT0gc3RyaW5naWZpZWRQcm9wUGF0aFRvQXV0b0ZvY3VzLFxuICAgICAgdmFsdWU6IHZhbHVlLmRpc2NyaW1pbmFudCxcbiAgICAgIG9uQ2hhbmdlOiBkaXNjcmltaW5hbnQgPT4ge1xuICAgICAgICBvbkNoYW5nZShnZXRQcm9wc0ZvckNvbmRpdGlvbmFsQ2hhbmdlKHtcbiAgICAgICAgICBkaXNjcmltaW5hbnQsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlXG4gICAgICAgIH0sIHZhbHVlLCBwcm9wLCByZWxhdGlvbnNoaXBzKSk7XG4gICAgICB9LFxuICAgICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24gJiYgIXByb3AuZGlzY3JpbWluYW50LnZhbGlkYXRlKHZhbHVlKVxuICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRm9ybVZhbHVlQ29udGVudCwge1xuICAgICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24sXG4gICAgICBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXM6IHN0cmluZ2lmaWVkUHJvcFBhdGhUb0F1dG9Gb2N1cyxcbiAgICAgIHBhdGg6IHBhdGguY29uY2F0KCd2YWx1ZScpLFxuICAgICAgcHJvcDogcHJvcC52YWx1ZXNbdmFsdWUuZGlzY3JpbWluYW50XSxcbiAgICAgIHZhbHVlOiB2YWx1ZS52YWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiB2YWwgPT4ge1xuICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgZGlzY3JpbWluYW50OiB2YWx1ZS5kaXNjcmltaW5hbnQsXG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBpZiAocHJvcC5raW5kID09PSAncmVsYXRpb25zaGlwJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUmVsYXRpb25zaGlwRm9ybUlucHV0LCB7XG4gICAgICBwcm9wOiBwcm9wLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICAgIHN0cmluZ2lmaWVkUHJvcFBhdGhUb0F1dG9Gb2N1czogc3RyaW5naWZpZWRQcm9wUGF0aFRvQXV0b0ZvY3VzXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHByb3AuSW5wdXQsIHtcbiAgICBhdXRvRm9jdXM6IEpTT04uc3RyaW5naWZ5KHBhdGgpID09PSBzdHJpbmdpZmllZFByb3BQYXRoVG9BdXRvRm9jdXMsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBmb3JjZVZhbGlkYXRpb246IGZvcmNlVmFsaWRhdGlvbiAmJiAhcHJvcC52YWxpZGF0ZSh2YWx1ZSlcbiAgfSk7XG59IC8vIGNoaWxkIGFzIGluIHRoZSBwcm9wcyBhcmUgYSB0cmVlIGFuZCB5b3Ugd2FudCB0aGUgY2hpbGRyZW4gb2YgYSBwcm9wLCBub3QgYXMgaW4gdGhlIGtpbmQgPT09ICdpbmxpbmUnXG5cbmZ1bmN0aW9uIGdldENoaWxkUHJvcHMocHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb3Aua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNjcmltaW5hbnQ6IHByb3AuZGlzY3JpbWluYW50LFxuICAgICAgdmFsdWU6IHByb3AudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHByb3Aua2luZCA9PT0gJ2Zvcm0nIHx8IHByb3Aua2luZCA9PT0gJ2NoaWxkJyB8fCBwcm9wLmtpbmQgPT09ICdyZWxhdGlvbnNoaXAnKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IGVsc2UgaWYgKHByb3Aua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gcHJvcC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnROZXZlcihwcm9wKTsgLy8gVHlwZVNjcmlwdCBzaG91bGQgdW5kZXJzdGFuZCB0aGF0IHRoaXMgd2lsbCBuZXZlciBoYXBwZW4gYnV0IGZvciBzb21lIHJlYXNvbiBpdCBkb2Vzbid0XG5cbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlUHJvcFBhdGgocHJvcHMsIHBhdGgsIHZhbHVlKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb3BzKSkge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1trZXldO1xuICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoLmNvbmNhdChrZXkpO1xuXG4gICAgaWYgKHByb3Aua2luZCA9PT0gJ2Zvcm0nIHx8IHByb3Aua2luZCA9PT0gJ3JlbGF0aW9uc2hpcCcpIHtcbiAgICAgIHJldHVybiBuZXdQYXRoO1xuICAgIH1cblxuICAgIGxldCBjaGlsZHJlbiA9IGdldENoaWxkUHJvcHMocHJvcCwgdmFsdWVba2V5XSk7XG4gICAgY29uc3QgY2hpbGRGb2N1c2FibGUgPSBmaW5kRmlyc3RGb2N1c2FibGVQcm9wUGF0aChjaGlsZHJlbiwgbmV3UGF0aCwgdmFsdWVba2V5XSk7XG5cbiAgICBpZiAoY2hpbGRGb2N1c2FibGUpIHtcbiAgICAgIHJldHVybiBjaGlsZEZvY3VzYWJsZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gRm9ybVZhbHVlKHtcbiAgdmFsdWUsXG4gIG9uQ2xvc2UsXG4gIG9uQ2hhbmdlLFxuICBjb21wb25lbnRCbG9jayxcbiAgaXNWYWxpZFxufSkge1xuICBjb25zdCBbZm9yY2VWYWxpZGF0aW9uLCBzZXRGb3JjZVZhbGlkYXRpb25dID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBmb2N1c2FibGVQYXRoID0gSlNPTi5zdHJpbmdpZnkoZmluZEZpcnN0Rm9jdXNhYmxlUHJvcFBhdGgoY29tcG9uZW50QmxvY2sucHJvcHMsIFtdLCB2YWx1ZSkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwieGxhcmdlXCIsXG4gICAgY29udGVudEVkaXRhYmxlOiBmYWxzZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRm9ybVZhbHVlQ29udGVudCwge1xuICAgIGZvcmNlVmFsaWRhdGlvbjogZm9yY2VWYWxpZGF0aW9uLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBwYXRoOiBbXSxcbiAgICBwcm9wOiB7XG4gICAgICBraW5kOiAnb2JqZWN0JyxcbiAgICAgIHZhbHVlOiBjb21wb25lbnRCbG9jay5wcm9wc1xuICAgIH0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHN0cmluZ2lmaWVkUHJvcFBhdGhUb0F1dG9Gb2N1czogZm9jdXNhYmxlUGF0aFxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgdG9uZTogXCJhY3RpdmVcIixcbiAgICB3ZWlnaHQ6IFwiYm9sZFwiLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEZvcmNlVmFsaWRhdGlvbih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFwiRG9uZVwiKSk7XG59XG5cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGFyckEsIGFyckIpIHtcbiAgaWYgKGFyckEubGVuZ3RoICE9PSBhcnJCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyQS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJBW2ldICE9PSBhcnJCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRCYXNlZE9uSW5saW5lTWFya3NBbmRTb2Z0QnJlYWtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBpbmxpbmVNYXJrcywgc29mdEJyZWFrcykge1xuICBjb25zdCBtYXJrc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKHggPT4geCAhPT0gJ3RleHQnICYmIHggIT09ICdpbnNlcnRNZW51JyAmJiBpbmxpbmVNYXJrc1t4XSAhPT0gdHJ1ZSk7XG5cbiAgaWYgKG1hcmtzVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgbWFya3NUb1JlbW92ZSwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc29mdEJyZWFrcykge1xuICAgIGNvbnN0IGhhc1NvZnRCcmVha3MgPSBub2RlLnRleHQuaW5jbHVkZXMoJ1xcbicpO1xuXG4gICAgaWYgKGhhc1NvZnRCcmVha3MpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnROb2RlXSA9IHNsYXRlLkVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUudHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2Ygc2xhdGUuRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcG9zaXRpb24ucGF0aCkudGV4dFtwb3NpdGlvbi5vZmZzZXRdO1xuXG4gICAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzQW5kUmVsYXRpb25zaGlwcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgbGlua3MsIHJlbGF0aW9uc2hpcHNFbmFibGVkLCByZWxhdGlvbnNoaXBzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdsaW5rJyAmJiAhbGlua3MpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCBgICgke25vZGUuaHJlZn0pYCwge1xuICAgICAgYXQ6IHNsYXRlLkVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKVxuICAgIH0pO1xuICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3JlbGF0aW9uc2hpcCcgJiYgKCFyZWxhdGlvbnNoaXBzRW5hYmxlZCB8fCByZWxhdGlvbnNoaXBzW25vZGUucmVsYXRpb25zaGlwXSA9PT0gdW5kZWZpbmVkIHx8IHJlbGF0aW9uc2hpcHNbbm9kZS5yZWxhdGlvbnNoaXBdLmtpbmQgIT09ICdpbmxpbmUnKSkge1xuICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgY29uc3QgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwc1tub2RlLnJlbGF0aW9uc2hpcF07XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCBgJHtkYXRhLmxhYmVsIHx8IGRhdGEuaWQgfHwgJyd9ICgkeyhyZWxhdGlvbnNoaXAgPT09IG51bGwgfHwgcmVsYXRpb25zaGlwID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWxhdGlvbnNoaXAua2luZCkgPT09ICdpbmxpbmUnID8gcmVsYXRpb25zaGlwLmxhYmVsIDogbm9kZS5yZWxhdGlvbnNoaXB9OiR7ZGF0YS5pZCB8fCAnJ30pYCwge1xuICAgICAgICBhdDogc2xhdGUuRWRpdG9yLmJlZm9yZShlZGl0b3IsIHBhdGgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnRCYXNlZE9uRG9jdW1lbnRGZWF0dXJlcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwge1xuICBmb3JtYXR0aW5nLFxuICBkaXZpZGVycyxcbiAgbGF5b3V0cyxcbiAgbGlua3MsXG4gIHJlbGF0aW9uc2hpcHM6IHJlbGF0aW9uc2hpcHNFbmFibGVkXG59LCByZWxhdGlvbnNoaXBzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdoZWFkaW5nJyAmJiAoIWZvcm1hdHRpbmcuaGVhZGluZ0xldmVscy5sZW5ndGggfHwgIWZvcm1hdHRpbmcuaGVhZGluZ0xldmVscy5pbmNsdWRlcyhub2RlLmxldmVsKSkgfHwgbm9kZS50eXBlID09PSAnb3JkZXJlZC1saXN0JyAmJiAhZm9ybWF0dGluZy5saXN0VHlwZXMub3JkZXJlZCB8fCBub2RlLnR5cGUgPT09ICd1bm9yZGVyZWQtbGlzdCcgJiYgIWZvcm1hdHRpbmcubGlzdFR5cGVzLnVub3JkZXJlZCB8fCBub2RlLnR5cGUgPT09ICdjb2RlJyAmJiAhZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUgfHwgbm9kZS50eXBlID09PSAnYmxvY2txdW90ZScgJiYgIWZvcm1hdHRpbmcuYmxvY2tUeXBlcy5ibG9ja3F1b3RlIHx8IG5vZGUudHlwZSA9PT0gJ2xheW91dCcgJiYgKGxheW91dHMubGVuZ3RoID09PSAwIHx8ICFsYXlvdXRzLnNvbWUobGF5b3V0ID0+IGFyZUFycmF5c0VxdWFsKGxheW91dCwgbm9kZS5sYXlvdXQpKSkpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICgobm9kZS50eXBlID09PSAncGFyYWdyYXBoJyB8fCBub2RlLnR5cGUgPT09ICdoZWFkaW5nJykgJiYgKCFmb3JtYXR0aW5nLmFsaWdubWVudC5jZW50ZXIgJiYgbm9kZS50ZXh0QWxpZ24gPT09ICdjZW50ZXInIHx8ICFmb3JtYXR0aW5nLmFsaWdubWVudC5lbmQgJiYgbm9kZS50ZXh0QWxpZ24gPT09ICdlbmQnIHx8ICd0ZXh0QWxpZ24nIGluIG5vZGUgJiYgbm9kZS50ZXh0QWxpZ24gIT09ICdjZW50ZXInICYmIG5vZGUudGV4dEFsaWduICE9PSAnZW5kJykpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAndGV4dEFsaWduJywge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdkaXZpZGVyJyAmJiAhZGl2aWRlcnMpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVJbmxpbmVCYXNlZE9uTGlua3NBbmRSZWxhdGlvbnNoaXBzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBsaW5rcywgcmVsYXRpb25zaGlwc0VuYWJsZWQsIHJlbGF0aW9uc2hpcHMpO1xufVxuZnVuY3Rpb24gd2l0aERvY3VtZW50RmVhdHVyZXNOb3JtYWxpemF0aW9uKGRvY3VtZW50RmVhdHVyZXMsIHJlbGF0aW9uc2hpcHMsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuXG4gIGNvbnN0IGRvY3VtZW50RmVhdHVyZXNGb3JOb3JtYWxpemF0aW9uID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkb2N1bWVudEZlYXR1cmVzKSwge30sIHtcbiAgICByZWxhdGlvbnNoaXBzOiB0cnVlXG4gIH0pO1xuXG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgIGlmIChzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgbm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5pbmxpbmVNYXJrcywgZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLnNvZnRCcmVha3MpO1xuICAgIH0gZWxzZSBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZUVsZW1lbnRCYXNlZE9uRG9jdW1lbnRGZWF0dXJlcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgZG9jdW1lbnRGZWF0dXJlc0Zvck5vcm1hbGl6YXRpb24sIHJlbGF0aW9uc2hpcHMpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcblxuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RvckNvbXBvbmVudEJsb2NrKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2VzdG9yRW50cnkgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpICYmIG5vZGUudHlwZSAhPT0gJ3BhcmFncmFwaCdcbiAgICB9KTtcblxuICAgIGlmIChhbmNlc3RvckVudHJ5ICYmIChhbmNlc3RvckVudHJ5WzBdLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgfHwgYW5jZXN0b3JFbnRyeVswXS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzSW5zaWRlOiB0cnVlLFxuICAgICAgICBjb21wb25lbnRCbG9jazogc2xhdGUuRWRpdG9yLnBhcmVudChlZGl0b3IsIGFuY2VzdG9yRW50cnlbMV0pLFxuICAgICAgICBwcm9wOiBhbmNlc3RvckVudHJ5XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNJbnNpZGU6IGZhbHNlXG4gIH07XG59XG5cbmNvbnN0IGFscmVhZHlOb3JtYWxpemVkVGhpbmdzID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTm9kZVdpdGhpbkNvbXBvbmVudFByb3AoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGZpZWxkT3B0aW9ucywgcmVsYXRpb25zaGlwcykge1xuICBsZXQgYWxyZWFkeU5vcm1hbGl6ZWROb2RlcyA9IGFscmVhZHlOb3JtYWxpemVkVGhpbmdzLmdldChmaWVsZE9wdGlvbnMpO1xuXG4gIGlmICghYWxyZWFkeU5vcm1hbGl6ZWROb2Rlcykge1xuICAgIGFscmVhZHlOb3JtYWxpemVkTm9kZXMgPSBuZXcgV2Vha1NldCgpO1xuICAgIGFscmVhZHlOb3JtYWxpemVkVGhpbmdzLnNldChmaWVsZE9wdGlvbnMsIGFscmVhZHlOb3JtYWxpemVkTm9kZXMpO1xuICB9XG5cbiAgaWYgKGFscmVhZHlOb3JtYWxpemVkTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IGRpZE5vcm1hbGl6YXRpb24gPSBmYWxzZTtcblxuICBpZiAoZmllbGRPcHRpb25zLmlubGluZU1hcmtzICE9PSAnaW5oZXJpdCcgJiYgc2xhdGUuVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGZpZWxkT3B0aW9ucy5pbmxpbmVNYXJrcywgZmllbGRPcHRpb25zLnNvZnRCcmVha3MpO1xuICB9XG5cbiAgaWYgKHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgbGV0IGNoaWxkcmVuSGFzQ2hhbmdlZCA9IG5vZGUuY2hpbGRyZW4ubWFwKChub2RlLCBpKSA9PiBub3JtYWxpemVOb2RlV2l0aGluQ29tcG9uZW50UHJvcChbbm9kZSwgWy4uLnBhdGgsIGldXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMsIHJlbGF0aW9uc2hpcHMpKSAvLyAubWFwIHRoZW4gLnNvbWUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGV4aXQgZWFybHlcbiAgICAuc29tZSh4ID0+IHgpO1xuXG4gICAgaWYgKGZpZWxkT3B0aW9ucy5raW5kID09PSAnYmxvY2snKSB7XG4gICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMuZG9jdW1lbnRGZWF0dXJlcywgcmVsYXRpb25zaGlwcykgfHwgY2hpbGRyZW5IYXNDaGFuZ2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzQW5kUmVsYXRpb25zaGlwcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgZmllbGRPcHRpb25zLmRvY3VtZW50RmVhdHVyZXMubGlua3MsIGZpZWxkT3B0aW9ucy5kb2N1bWVudEZlYXR1cmVzLnJlbGF0aW9uc2hpcHMsIHJlbGF0aW9uc2hpcHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaWROb3JtYWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgIGFscmVhZHlOb3JtYWxpemVkTm9kZXMuYWRkKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGRpZE5vcm1hbGl6YXRpb247XG59XG5cbmZ1bmN0aW9uIHdpdGhDb21wb25lbnRCbG9ja3MoYmxvY2tDb21wb25lbnRzLCBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLCByZWxhdGlvbnNoaXBzLCBlZGl0b3IpIHtcbiAgLy8gbm90ZSB0aGF0IGNvbmZsaWN0cyBiZXR3ZWVuIHRoZSBlZGl0b3IgZG9jdW1lbnQgZmVhdHVyZXNcbiAgLy8gYW5kIHRoZSBjaGlsZCBmaWVsZCBkb2N1bWVudCBmZWF0dXJlcyBhcmUgZGVhbHQgd2l0aCBlbHNld2hlcmVcbiAgY29uc3QgbWVtb2l6ZWRHZXREb2N1bWVudEZlYXR1cmVzRm9yQ2hpbGRGaWVsZCA9IHdlYWtNZW1vaXplX19kZWZhdWx0W1wiZGVmYXVsdFwiXShvcHRpb25zID0+IHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgb3B0aW9ucyk7XG4gIH0pO1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBpbnNlcnRCcmVha1xuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudEJsb2NrID0gZ2V0QW5jZXN0b3JDb21wb25lbnRCbG9jayhlZGl0b3IpO1xuXG4gICAgICBpZiAoYW5jZXN0b3JDb21wb25lbnRCbG9jay5pc0luc2lkZSAmJiBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBzbGF0ZS5FZGl0b3IuaXNTdGFydChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLCBhbmNlc3RvckNvbXBvbmVudEJsb2NrLnByb3BbMV0pICYmIGFuY2VzdG9yQ29tcG9uZW50QmxvY2sucHJvcFsxXVthbmNlc3RvckNvbXBvbmVudEJsb2NrLnByb3BbMV0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYW5jZXN0b3JDb21wb25lbnRCbG9jay5jb21wb25lbnRCbG9ja1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9O1xuXG4gIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudEJsb2NrID0gZ2V0QW5jZXN0b3JDb21wb25lbnRCbG9jayhlZGl0b3IpO1xuXG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgYW5jZXN0b3JDb21wb25lbnRCbG9jay5pc0luc2lkZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcm9wOiBbY29tcG9uZW50UHJvcE5vZGUsIGNvbXBvbmVudFByb3BQYXRoXSxcbiAgICAgICAgY29tcG9uZW50QmxvY2s6IFtjb21wb25lbnRCbG9ja05vZGUsIGNvbXBvbmVudEJsb2NrUGF0aF1cbiAgICAgIH0gPSBhbmNlc3RvckNvbXBvbmVudEJsb2NrO1xuICAgICAgY29uc3QgaXNMYXN0UHJvcCA9IGNvbXBvbmVudFByb3BQYXRoW2NvbXBvbmVudFByb3BQYXRoLmxlbmd0aCAtIDFdID09PSBjb21wb25lbnRCbG9ja05vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKGNvbXBvbmVudFByb3BOb2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcpIHtcbiAgICAgICAgY29uc3QgW1twYXJhZ3JhcGhOb2RlLCBwYXJhZ3JhcGhQYXRoXV0gPSBzbGF0ZS5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFyYWdyYXBoID0gcGFyYWdyYXBoUGF0aFtwYXJhZ3JhcGhQYXRoLmxlbmd0aCAtIDFdID09PSBjb21wb25lbnRQcm9wTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuXG4gICAgICAgIGlmIChzbGF0ZS5Ob2RlLnN0cmluZyhwYXJhZ3JhcGhOb2RlKSA9PT0gJycgJiYgaXNMYXN0UGFyYWdyYXBoKSB7XG4gICAgICAgICAgaWYgKGlzTGFzdFByb3ApIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcGFyYWdyYXBoUGF0aCxcbiAgICAgICAgICAgICAgdG86IHNsYXRlLlBhdGgubmV4dChhbmNlc3RvckNvbXBvbmVudEJsb2NrLmNvbXBvbmVudEJsb2NrWzFdKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgZ29lcyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgYmxvY2ssIGlzIHRoYXQgcmlnaHQ/XG4gICAgICAgICAgICAvLyBzaG91bGQgd2UganVzdCBpbnNlcnRCcmVhayBhbHdheXMgaGVyZT9cbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcGFyYWdyYXBoUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnRQcm9wTm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykge1xuICAgICAgICBzbGF0ZS5FZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHNwbGl0Tm9kZVBhdGggPSBzbGF0ZS5QYXRoLm5leHQoY29tcG9uZW50UHJvcFBhdGgpO1xuXG4gICAgICAgICAgaWYgKGlzTGFzdFByb3ApIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogc3BsaXROb2RlUGF0aCxcbiAgICAgICAgICAgICAgdG86IHNsYXRlLlBhdGgubmV4dChjb21wb25lbnRCbG9ja1BhdGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW92ZUNoaWxkcmVuKGVkaXRvciwgc3BsaXROb2RlUGF0aCwgWy4uLnNsYXRlLlBhdGgubmV4dChzcGxpdE5vZGVQYXRoKSwgMF0pO1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHNwbGl0Tm9kZVBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnNlcnRCcmVhaygpO1xuICB9O1xuXG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuXG4gICAgaWYgKHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG5vZGUpIHx8IHNsYXRlLkVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcgJiYgIW5vZGUucHJvcFBhdGggJiYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICFzbGF0ZS5UZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBub2RlLmNoaWxkcmVuWzBdLnRleHQgIT09ICcnKSkge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gYmxvY2tDb21wb25lbnRzW25vZGUuY29tcG9uZW50XTtcblxuICAgICAgICBpZiAoY29tcG9uZW50QmxvY2spIHtcbiAgICAgICAgICBsZXQgbWlzc2luZ0tleXMgPSBuZXcgTWFwKGZpbmRDaGlsZFByb3BQYXRocyhub2RlLnByb3BzLCBjb21wb25lbnRCbG9jay5wcm9wcykubWFwKHggPT4gW0pTT04uc3RyaW5naWZ5KHgucGF0aCksIHgub3B0aW9ucy5raW5kXSkpO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgfHwgbm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJyk7XG4gICAgICAgICAgICBtaXNzaW5nS2V5cy5kZWxldGUoSlNPTi5zdHJpbmdpZnkobm9kZS5wcm9wUGF0aCkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG1pc3NpbmdLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbLi4ubWlzc2luZ0tleXNdLm1hcCgoW3Byb3AsIGtpbmRdKSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBgY29tcG9uZW50LSR7a2luZH0tcHJvcGAsXG4gICAgICAgICAgICAgIHByb3BQYXRoOiBwcm9wID8gSlNPTi5wYXJzZShwcm9wKSA6IHByb3AsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KSksIHtcbiAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBub2RlLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmb3VuZFByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGxldCBzdHJpbmdpZmllZElubGluZVByb3BQYXRocyA9IHt9O1xuICAgICAgICAgIGZpbmRDaGlsZFByb3BQYXRocyhub2RlLnByb3BzLCBibG9ja0NvbXBvbmVudHNbbm9kZS5jb21wb25lbnRdLnByb3BzKS5mb3JFYWNoKCh4LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgc3RyaW5naWZpZWRJbmxpbmVQcm9wUGF0aHNbSlNPTi5zdHJpbmdpZnkoeC5wYXRoKV0gPSB7XG4gICAgICAgICAgICAgIG9wdGlvbnM6IHgub3B0aW9ucyxcbiAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGROb2RlXSBvZiBub2RlLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKCAvLyBjaGlsZHJlbiB0aGF0IGFyZSBub3QgdGhlc2Ugd2lsbCBiZSBoYW5kbGVkIGJ5XG4gICAgICAgICAgICAvLyB0aGUgZ2VuZXJpYyBhbGxvd2VkQ2hpbGRyZW4gbm9ybWFsaXphdGlvblxuICAgICAgICAgICAgY2hpbGROb2RlLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnIHx8IGNoaWxkTm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IFsuLi5wYXRoLCBpbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkUHJvcFBhdGggPSBKU09OLnN0cmluZ2lmeShjaGlsZE5vZGUucHJvcFBhdGgpO1xuXG4gICAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZElubGluZVByb3BQYXRoc1tzdHJpbmdpZmllZFByb3BQYXRoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kUHJvcHMuaGFzKHN0cmluZ2lmaWVkUHJvcFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZFByb3BzLmFkZChzdHJpbmdpZmllZFByb3BQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wSW5mbyA9IHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzW3N0cmluZ2lmaWVkUHJvcFBhdGhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW5kZXggPSBwcm9wSW5mby5pbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZXhwZWN0ZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBbLi4ucGF0aCwgZXhwZWN0ZWRJbmRleF1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ2hpbGROb2RlVHlwZSA9IGBjb21wb25lbnQtJHtwcm9wSW5mby5vcHRpb25zLmtpbmR9LXByb3BgO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlICE9PSBleHBlY3RlZENoaWxkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV4cGVjdGVkQ2hpbGROb2RlVHlwZVxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEZlYXR1cmVzID0gbWVtb2l6ZWRHZXREb2N1bWVudEZlYXR1cmVzRm9yQ2hpbGRGaWVsZChwcm9wSW5mby5vcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVOb2RlV2l0aGluQ29tcG9uZW50UHJvcChbY2hpbGROb2RlLCBjaGlsZFBhdGhdLCBlZGl0b3IsIGRvY3VtZW50RmVhdHVyZXMsIHJlbGF0aW9uc2hpcHMpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuY29uc3QgQ29tcG9uZW50QmxvY2tDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXJUZXh0Rm9yUHJvcFBhdGgocHJvcFBhdGgsIGZpZWxkcywgZm9ybVByb3BzKSB7XG4gIGNvbnN0IHByb3AgPSBwcm9wUGF0aFswXTtcbiAgY29uc3QgZmllbGQgPSBmaWVsZHNbcHJvcF07XG5cbiAgaWYgKGZpZWxkLmtpbmQgPT09ICdyZWxhdGlvbnNoaXAnIHx8IGZpZWxkLmtpbmQgPT09ICdmb3JtJykge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwcm9wIGZpZWxkIHdoZW4gZmluZGluZyBwbGFjZWhvbGRlciB0ZXh0IGZvciBjaGlsZCBwcm9wJyk7XG4gIH1cblxuICBpZiAoZmllbGQua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZ2V0UGxhY2Vob2xkZXJUZXh0Rm9yUHJvcFBhdGgocHJvcFBhdGguc2xpY2UoMSksIGZpZWxkLnZhbHVlLCBmb3JtUHJvcHNbcHJvcF0pO1xuICB9XG5cbiAgaWYgKGZpZWxkLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICByZXR1cm4gZ2V0UGxhY2Vob2xkZXJUZXh0Rm9yUHJvcFBhdGgocHJvcFBhdGguc2xpY2UoMSksIHtcbiAgICAgIHZhbHVlOiBmaWVsZC52YWx1ZXNbZm9ybVByb3BzW3Byb3BdLmRpc2NyaW1pbmFudF1cbiAgICB9LCBmb3JtUHJvcHNbcHJvcF0pO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkLm9wdGlvbnMucGxhY2Vob2xkZXI7XG59XG5mdW5jdGlvbiBDb21wb25lbnRJbmxpbmVQcm9wKHByb3BzKSB7XG4gIHJldHVybiBjb3JlLmpzeChcInNwYW5cIiwgcHJvcHMuYXR0cmlidXRlcywgcHJvcHMuY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gaW5zZXJ0Q29tcG9uZW50QmxvY2soZWRpdG9yLCBjb21wb25lbnRCbG9ja3MsIGNvbXBvbmVudEJsb2NrLCByZWxhdGlvbnNoaXBzKSB7XG4gIGxldCBub2RlID0gZ2V0SW5pdGlhbFZhbHVlKGNvbXBvbmVudEJsb2NrLCBjb21wb25lbnRCbG9ja3NbY29tcG9uZW50QmxvY2tdLCByZWxhdGlvbnNoaXBzKTtcbiAgaW5zZXJ0Tm9kZXNCdXRSZXBsYWNlSWZTZWxlY3Rpb25Jc0F0RW1wdHlQYXJhZ3JhcGhPckhlYWRpbmcoZWRpdG9yLCBub2RlKTtcbiAgY29uc3QgY29tcG9uZW50QmxvY2tFbnRyeSA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snXG4gIH0pO1xuXG4gIGlmIChjb21wb25lbnRCbG9ja0VudHJ5KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzbGF0ZS5FZGl0b3Iuc3RhcnQoZWRpdG9yLCBjb21wb25lbnRCbG9ja0VudHJ5WzFdKTtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogc3RhcnRcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQmxvY2tDb21wb25lbnRzQnV0dG9ucyA9ICh7XG4gIG9uQ2xvc2Vcbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gc2xhdGVSZWFjdC51c2VTbGF0ZVN0YXRpYygpO1xuICBjb25zdCBibG9ja0NvbXBvbmVudHMgPSBSZWFjdC51c2VDb250ZXh0KENvbXBvbmVudEJsb2NrQ29udGV4dCk7XG4gIGNvbnN0IHJlbGF0aW9uc2hpcHMgPSB1c2VEb2N1bWVudEZpZWxkUmVsYXRpb25zaGlwcygpO1xuICByZXR1cm4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIE9iamVjdC5rZXlzKGJsb2NrQ29tcG9uZW50cykubWFwKGtleSA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIHtcbiAgICBrZXk6IGtleSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGluc2VydENvbXBvbmVudEJsb2NrKGVkaXRvciwgYmxvY2tDb21wb25lbnRzLCBrZXksIHJlbGF0aW9uc2hpcHMpO1xuICAgICAgb25DbG9zZSgpO1xuICAgIH1cbiAgfSwgYmxvY2tDb21wb25lbnRzW2tleV0ubGFiZWwpKSk7XG59O1xuY29uc3QgQ29tcG9uZW50QmxvY2tzRWxlbWVudCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIGNoaWxkcmVuLFxuICBlbGVtZW50OiBfX2VsZW1lbnRUb0dldFBhdGhcbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gc2xhdGVSZWFjdC51c2VTbGF0ZVN0YXRpYygpO1xuICBjb25zdCBmb2N1c2VkID0gc2xhdGVSZWFjdC51c2VGb2N1c2VkKCk7XG4gIGNvbnN0IHNlbGVjdGVkID0gc2xhdGVSZWFjdC51c2VTZWxlY3RlZCgpO1xuICBjb25zdCBbZWRpdE1vZGUsIHNldEVkaXRNb2RlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZUVsZW1lbnRXaXRoU2V0Tm9kZXMoZWRpdG9yLCBfX2VsZW1lbnRUb0dldFBhdGgpO1xuICBjb25zdCB7XG4gICAgY29sb3JzLFxuICAgIGZpZWxkcyxcbiAgICBzcGFjaW5nLFxuICAgIHR5cG9ncmFwaHlcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgY29uc3QgYmxvY2tDb21wb25lbnRzID0gUmVhY3QudXNlQ29udGV4dChDb21wb25lbnRCbG9ja0NvbnRleHQpO1xuICBjb25zdCBjb21wb25lbnRCbG9jayA9IGJsb2NrQ29tcG9uZW50c1tjdXJyZW50RWxlbWVudC5jb21wb25lbnRdO1xuICBjb25zdCBpc1ZhbGlkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNvbXBvbmVudEJsb2NrID8gY2xpZW50U2lkZVZhbGlkYXRlUHJvcCh7XG4gICAgICBraW5kOiAnb2JqZWN0JyxcbiAgICAgIHZhbHVlOiBjb21wb25lbnRCbG9jay5wcm9wc1xuICAgIH0sIGN1cnJlbnRFbGVtZW50LnByb3BzKSA6IHRydWU7XG4gIH0sIFtjb21wb25lbnRCbG9jaywgY3VycmVudEVsZW1lbnQucHJvcHNdKTtcbiAgY29uc3QgZG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHMgPSB1c2VEb2N1bWVudEZpZWxkUmVsYXRpb25zaGlwcygpO1xuXG4gIGlmICghY29tcG9uZW50QmxvY2spIHtcbiAgICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgICAgY3NzOiB7XG4gICAgICAgIGJvcmRlcjogJ3JlZCA0cHggc29saWQnLFxuICAgICAgICBwYWRkaW5nOiBzcGFjaW5nLm1lZGl1bVxuICAgICAgfVxuICAgIH0sIGNvcmUuanN4KFwicHJlXCIsIHtcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICBjc3M6IHtcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXG4gICAgICB9XG4gICAgfSwgYFRoZSBibG9jayBcIiR7Y3VycmVudEVsZW1lbnQuY29tcG9uZW50fVwiIG5vIGxvbmdlciBleGlzdHMuXG5cblByb3BzOlxuXG4ke0pTT04uc3RyaW5naWZ5KGN1cnJlbnRFbGVtZW50LnByb3BzLCBudWxsLCAyKX1cblxuQ29udGVudDpgKSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuanN4KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBcImRhdGEtd2l0aC1jaHJvbWVcIjogIWNvbXBvbmVudEJsb2NrLmNocm9tZWxlc3MsXG4gICAgY3NzOiB7XG4gICAgICBtYXJnaW5Cb3R0b206IHNwYWNpbmcueGxhcmdlLFxuICAgICAgbWFyZ2luVG9wOiBzcGFjaW5nLnhsYXJnZSxcbiAgICAgICcmW2RhdGEtd2l0aC1jaHJvbWU9dHJ1ZV0nOiB7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nLnhsYXJnZSxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICc6YmVmb3JlJzoge1xuICAgICAgICAgIGNvbnRlbnQ6ICdcIiBcIicsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlZGl0TW9kZSA/IGNvbG9ycy5saW5rQ29sb3IgOiBjb2xvcnMuYm9yZGVyLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgICAgICB3aWR0aDogNCxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpLCAhY29tcG9uZW50QmxvY2suY2hyb21lbGVzcyAmJiBjb3JlLmpzeChhcGkuTm90RWRpdGFibGUsIHtcbiAgICBjc3M6IHtcbiAgICAgIGNvbG9yOiBmaWVsZHMubGVnZW5kQ29sb3IsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgZm9udFNpemU6IHR5cG9ncmFwaHkuZm9udFNpemUuc21hbGwsXG4gICAgICBmb250V2VpZ2h0OiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHQuYm9sZCxcbiAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICBtYXJnaW5Cb3R0b206IHNwYWNpbmcuc21hbGwsXG4gICAgICB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJ1xuICAgIH1cbiAgfSwgY29tcG9uZW50QmxvY2subGFiZWwpLCBlZGl0TW9kZSAmJiBjb3JlLmpzeChGb3JtVmFsdWUsIHtcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGNvbXBvbmVudEJsb2NrOiBjb21wb25lbnRCbG9jayxcbiAgICBvbkNsb3NlOiAoKSA9PiB7XG4gICAgICBzZXRFZGl0TW9kZShmYWxzZSk7XG4gICAgfSxcbiAgICB2YWx1ZTogY3VycmVudEVsZW1lbnQucHJvcHMsXG4gICAgb25DaGFuZ2U6IHZhbCA9PiB7XG4gICAgICBzZXRFbGVtZW50KHtcbiAgICAgICAgcHJvcHM6IHZhbFxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogZWRpdE1vZGUgPyAnbm9uZScgOiAnYmxvY2snLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0sIGVkaXRNb2RlID8gY2hpbGRyZW4gOiBjb3JlLmpzeChDb21wb25lbnRCbG9ja1JlbmRlciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb21wb25lbnRCbG9jazogY29tcG9uZW50QmxvY2ssXG4gICAgZWxlbWVudDogY3VycmVudEVsZW1lbnQsXG4gICAgb25FbGVtZW50Q2hhbmdlOiBzZXRFbGVtZW50XG4gIH0pLCAhZWRpdE1vZGUgJiYgKCgpID0+IHtcbiAgICBjb25zdCB0b29sYmFyUHJvcHMgPSBjcmVhdGVQcmV2aWV3UHJvcHMoY3VycmVudEVsZW1lbnQsIGNvbXBvbmVudEJsb2NrLCB7fSwgZG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHMsIHNldEVsZW1lbnQpO1xuICAgIGNvbnN0IENocm9tZWZ1bFRvb2xiYXIgPSBjb21wb25lbnRCbG9jay50b29sYmFyID8gY29tcG9uZW50QmxvY2sudG9vbGJhciA6IERlZmF1bHRUb29sYmFyV2l0aENocm9tZTtcbiAgICBjb25zdCBDaHJvbWVsZXNzVG9vbGJhciA9IGNvbXBvbmVudEJsb2NrLmNocm9tZWxlc3MgJiYgY29tcG9uZW50QmxvY2sudG9vbGJhciA/IGNvbXBvbmVudEJsb2NrLnRvb2xiYXIgOiBEZWZhdWx0VG9vbGJhcldpdGhvdXRDaHJvbWU7XG4gICAgcmV0dXJuIGNvbXBvbmVudEJsb2NrLmNocm9tZWxlc3MgPyBmb2N1c2VkICYmIHNlbGVjdGVkICYmIGNvcmUuanN4KHRvb2xiYXIuSW5saW5lRGlhbG9nLCB7XG4gICAgICBpc1JlbGF0aXZlOiB0cnVlXG4gICAgfSwgY29yZS5qc3goQ2hyb21lbGVzc1Rvb2xiYXIsIHtcbiAgICAgIG9uUmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBzbGF0ZVJlYWN0LlJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX19lbGVtZW50VG9HZXRQYXRoKTtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwcm9wczogdG9vbGJhclByb3BzXG4gICAgfSkpIDogY29yZS5qc3goQ2hyb21lZnVsVG9vbGJhciwge1xuICAgICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICAgIG9uUmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBzbGF0ZVJlYWN0LlJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX19lbGVtZW50VG9HZXRQYXRoKTtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvblNob3dFZGl0TW9kZTogKCkgPT4ge1xuICAgICAgICBzZXRFZGl0TW9kZSh0cnVlKTtcbiAgICAgIH0sXG4gICAgICBwcm9wczogdG9vbGJhclByb3BzXG4gICAgfSk7XG4gIH0pKCkpKTtcbn07XG5cbmZ1bmN0aW9uIERlZmF1bHRUb29sYmFyV2l0aENocm9tZSh7XG4gIG9uU2hvd0VkaXRNb2RlLFxuICBvblJlbW92ZSxcbiAgaXNWYWxpZFxufSkge1xuICBjb25zdCB0aGVtZSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgcmV0dXJuIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckdyb3VwLCB7XG4gICAgYXM6IGFwaS5Ob3RFZGl0YWJsZSxcbiAgICBtYXJnaW5Ub3A6IFwic21hbGxcIlxuICB9LCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBvblNob3dFZGl0TW9kZSgpO1xuICAgIH1cbiAgfSwgXCJFZGl0XCIpLCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJTZXBhcmF0b3IsIG51bGwpLCBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBjb250ZW50OiBcIlJlbW92ZVwiLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICB2YXJpYW50OiBcImRlc3RydWN0aXZlXCIsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25SZW1vdmUoKTtcbiAgICB9XG4gIH0sIGF0dHJzKSwgY29yZS5qc3goVHJhc2gySWNvbi5UcmFzaDJJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pKSksICFpc1ZhbGlkICYmIGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJTZXBhcmF0b3IsIG51bGwpLCBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucmVkNTAwLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZy5zbWFsbFxuICAgIH1cbiAgfSwgXCJQbGVhc2UgZWRpdCB0aGUgZm9ybSwgdGhlcmUgYXJlIGludmFsaWQgZmllbGRzLlwiKSkpO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0VG9vbGJhcldpdGhvdXRDaHJvbWUoe1xuICBvblJlbW92ZVxufSkge1xuICByZXR1cm4gY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gICAgY29udGVudDogXCJSZW1vdmVcIixcbiAgICB3ZWlnaHQ6IFwic3VidGxlXCJcbiAgfSwgYXR0cnMgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgdmFyaWFudDogXCJkZXN0cnVjdGl2ZVwiLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb25SZW1vdmUoKTtcbiAgICB9XG4gIH0sIGF0dHJzKSwgY29yZS5qc3goVHJhc2gySWNvbi5UcmFzaDJJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pKSk7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudEJsb2NrUmVuZGVyKHtcbiAgY29tcG9uZW50QmxvY2ssXG4gIGVsZW1lbnQsXG4gIG9uRWxlbWVudENoYW5nZSxcbiAgY2hpbGRyZW46IF9jaGlsZHJlblxufSkge1xuICBjb25zdCBjaGlsZHJlbkJ5UGF0aCA9IHt9O1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gX2NoaWxkcmVuLnR5cGUoX2NoaWxkcmVuLnByb3BzKS5wcm9wcy5jaGlsZHJlbjtcblxuICBsZXQgbWF5YmVDaGlsZDtcbiAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgbGV0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkoY2hpbGQucHJvcHMuZWxlbWVudC5wcm9wUGF0aCk7XG5cbiAgICBpZiAoc3RyaW5naWZpZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF5YmVDaGlsZCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbkJ5UGF0aFtzdHJpbmdpZmllZF0gPSBjaGlsZDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwcmV2aWV3UHJvcHMgPSBjcmVhdGVQcmV2aWV3UHJvcHMoZWxlbWVudCwgY29tcG9uZW50QmxvY2ssIGNoaWxkcmVuQnlQYXRoLCB1c2VEb2N1bWVudEZpZWxkUmVsYXRpb25zaGlwcygpLCBvbkVsZW1lbnRDaGFuZ2UpO1xuICByZXR1cm4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvcmUuanN4KGNvbXBvbmVudEJsb2NrLmNvbXBvbmVudCwgcHJldmlld1Byb3BzKSwgY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH1cbiAgfSwgbWF5YmVDaGlsZCkpO1xufVxuXG5jb25zdCBMYXlvdXRPcHRpb25zQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KFtdKTtcbmNvbnN0IExheW91dE9wdGlvbnNQcm92aWRlciA9IExheW91dE9wdGlvbnNDb250ZXh0LlByb3ZpZGVyOyAvLyBVSSBDb21wb25lbnRzXG5cbmNvbnN0IExheW91dENvbnRhaW5lciA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIGNoaWxkcmVuLFxuICBlbGVtZW50XG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzcGFjaW5nXG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIGNvbnN0IGZvY3VzZWQgPSBzbGF0ZVJlYWN0LnVzZUZvY3VzZWQoKTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBzbGF0ZVJlYWN0LnVzZVNlbGVjdGVkKCk7XG4gIGNvbnN0IGVkaXRvciA9IHNsYXRlUmVhY3QudXNlU2xhdGVTdGF0aWMoKTtcbiAgY29uc3QgbGF5b3V0ID0gZWxlbWVudC5sYXlvdXQ7XG4gIGNvbnN0IGxheW91dE9wdGlvbnMgPSBSZWFjdC51c2VDb250ZXh0KExheW91dE9wdGlvbnNDb250ZXh0KTtcbiAgcmV0dXJuIGNvcmUuanN4KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjc3M6IHtcbiAgICAgIG1hcmdpbkJvdHRvbTogc3BhY2luZy5tZWRpdW0sXG4gICAgICBtYXJnaW5Ub3A6IHNwYWNpbmcubWVkaXVtLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpLCBjb3JlLmpzeChcImRpdlwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBjb2x1bW5HYXA6IHNwYWNpbmcuc21hbGwsXG4gICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBsYXlvdXQubWFwKHggPT4gYCR7eH1mcmApLmpvaW4oJyAnKVxuICAgIH1cbiAgfSwgY2hpbGRyZW4pLCBmb2N1c2VkICYmIHNlbGVjdGVkICYmIGNvcmUuanN4KHRvb2xiYXIuSW5saW5lRGlhbG9nLCB7XG4gICAgaXNSZWxhdGl2ZTogdHJ1ZVxuICB9LCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJHcm91cCwgbnVsbCwgbGF5b3V0T3B0aW9ucy5tYXAoKGxheW91dE9wdGlvbiwgaSkgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCB7XG4gICAgaXNTZWxlY3RlZDogbGF5b3V0T3B0aW9uLnRvU3RyaW5nKCkgPT09IGxheW91dC50b1N0cmluZygpLFxuICAgIGtleTogaSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHBhdGggPSBzbGF0ZVJlYWN0LlJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCk7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRPcHRpb25cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgbWFrZUxheW91dEljb24obGF5b3V0T3B0aW9uKSkpLCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJTZXBhcmF0b3IsIG51bGwpLCBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBjb250ZW50OiBcIlJlbW92ZVwiLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICB2YXJpYW50OiBcImRlc3RydWN0aXZlXCIsXG4gICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwYXRoID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpO1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgYXR0cnMpLCBjb3JlLmpzeChUcmFzaDJJY29uLlRyYXNoMkljb24sIHtcbiAgICBzaXplOiBcInNtYWxsXCJcbiAgfSkpKSkpKTtcbn07XG5jb25zdCBMYXlvdXRBcmVhID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbG9ycyxcbiAgICByYWRpaSxcbiAgICBzcGFjaW5nXG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIHJldHVybiBjb3JlLmpzeChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY3NzOiB7XG4gICAgICBib3JkZXI6IGAycHggZGFzaGVkICR7Y29sb3JzLmJvcmRlcn1gLFxuICAgICAgYm9yZGVyUmFkaXVzOiByYWRpaS5zbWFsbCxcbiAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nLm1lZGl1bSxcbiAgICAgIHBhZGRpbmdSaWdodDogc3BhY2luZy5tZWRpdW1cbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuY29uc3QgaW5zZXJ0TGF5b3V0ID0gKGVkaXRvciwgbGF5b3V0KSA9PiB7XG4gIGluc2VydE5vZGVzQnV0UmVwbGFjZUlmU2VsZWN0aW9uSXNBdEVtcHR5UGFyYWdyYXBoT3JIZWFkaW5nKGVkaXRvciwgW3tcbiAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICBsYXlvdXQsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0eXBlOiAnbGF5b3V0LWFyZWEnLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9XVxuICB9XSk7XG4gIGNvbnN0IGxheW91dEVudHJ5ID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiB4ID0+IHgudHlwZSA9PT0gJ2xheW91dCdcbiAgfSk7XG5cbiAgaWYgKGxheW91dEVudHJ5KSB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBbLi4ubGF5b3V0RW50cnlbMV0sIDBdKTtcbiAgfVxufTsgLy8gUGx1Z2luXG5cbmZ1bmN0aW9uIHdpdGhMYXlvdXRzKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZFxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIC8vIHRoaXMgaXMganVzdCBhbiBsaXR0bGUgb3B0aW1pc2F0aW9uXG4gICAgLy8gd2UncmUgb25seSBkb2luZyB0aGluZ3MgaWYgd2UncmUgYXQgdGhlIHN0YXJ0IG9mIGEgbGF5b3V0IGFyZWFcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IG9mIGFueXRoaW5nIHdpbGwgYWx3YXlzIGJlIG9mZnNldCAwXG4gICAgLy8gc28gd2UnbGwgYmFpbG91dCBpZiB3ZSdyZSBub3QgYXQgb2Zmc2V0IDBcbiAgICBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IFthYm92ZU5vZGUsIGFib3ZlUGF0aF0gPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ2xheW91dC1hcmVhJ1xuICAgICAgfSkgfHwgW2VkaXRvciwgW11dO1xuXG4gICAgICBpZiAoYWJvdmVOb2RlLnR5cGUgPT09ICdsYXlvdXQtYXJlYScgJiYgc2xhdGUuUG9pbnQuZXF1YWxzKHNsYXRlLkVkaXRvci5zdGFydChlZGl0b3IsIGFib3ZlUGF0aCksIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG5cbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnbGF5b3V0Jykge1xuICAgICAgaWYgKG5vZGUubGF5b3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPCBub2RlLmxheW91dC5sZW5ndGgpIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIEFycmF5LmZyb20oe1xuICAgICAgICAgIGxlbmd0aDogbm9kZS5sYXlvdXQubGVuZ3RoIC0gbm9kZS5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgfSkubWFwKCgpID0+ICh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dC1hcmVhJyxcbiAgICAgICAgICBjaGlsZHJlbjogW3BhcmFncmFwaEVsZW1lbnQoKV1cbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgYXQ6IFsuLi5wYXRoLCBub2RlLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gbm9kZS5sYXlvdXQubGVuZ3RoKSB7XG4gICAgICAgIEFycmF5LmZyb20oe1xuICAgICAgICAgIGxlbmd0aDogbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBub2RlLmxheW91dC5sZW5ndGhcbiAgICAgICAgfSkubWFwKChfLCBpKSA9PiBpKS5yZXZlcnNlKCkuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBjb25zdCBsYXlvdXRBcmVhVG9SZW1vdmVQYXRoID0gWy4uLnBhdGgsIGkgKyBub2RlLmxheW91dC5sZW5ndGhdO1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpICsgbm9kZS5sYXlvdXQubGVuZ3RoXTtcbiAgICAgICAgICBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBsYXlvdXRBcmVhVG9SZW1vdmVQYXRoLCBbLi4ucGF0aCwgbm9kZS5sYXlvdXQubGVuZ3RoIC0gMSwgbm9kZS5jaGlsZHJlbltub2RlLmxheW91dC5sZW5ndGggLSAxXS5jaGlsZHJlbi5sZW5ndGhdLCBub2RlID0+IG5vZGUudHlwZSAhPT0gJ3BhcmFncmFwaCcgfHwgc2xhdGUuTm9kZS5zdHJpbmcoY2hpbGQpICE9PSAnJyk7XG4gICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBsYXlvdXRBcmVhVG9SZW1vdmVQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn0gLy8gVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBtYWtlTGF5b3V0SWNvbihyYXRpb3MpIHtcbiAgY29uc3Qgc2l6ZSA9IDE2O1xuICBjb25zdCBlbGVtZW50ID0gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiaW1nXCIsXG4gICAgY3NzOiB7XG4gICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiByYXRpb3MubWFwKHIgPT4gYCR7cn1mcmApLmpvaW4oJyAnKSxcbiAgICAgIGdhcDogMixcbiAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgaGVpZ2h0OiBzaXplXG4gICAgfVxuICB9LCByYXRpb3MubWFwKChfLCBpKSA9PiB7XG4gICAgcmV0dXJuIGNvcmUuanN4KFwiZGl2XCIsIHtcbiAgICAgIGtleTogaSxcbiAgICAgIGNzczoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Y29sb3InLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDFcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxuY29uc3QgbGF5b3V0c0ljb24gPSBjb3JlLmpzeChDb2x1bW5zSWNvbi5Db2x1bW5zSWNvbiwge1xuICBzaXplOiBcInNtYWxsXCJcbn0pO1xuY29uc3QgTGF5b3V0c0J1dHRvbiA9ICh7XG4gIGxheW91dHNcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGVkaXRvcixcbiAgICBsYXlvdXRzOiB7XG4gICAgICBpc1NlbGVjdGVkXG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgIGNvbnRlbnQ6IFwiTGF5b3V0c1wiLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ2xheW91dCcpKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnbGF5b3V0J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbnNlcnRMYXlvdXQoZWRpdG9yLCBsYXlvdXRzWzBdKTtcbiAgICB9XG4gIH0sIGF0dHJzKSwgbGF5b3V0c0ljb24pKSwgW2VkaXRvciwgaXNTZWxlY3RlZCwgbGF5b3V0c10pO1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJ0eXBlXCJdO1xuY29uc3QgaXNMaXN0VHlwZSA9IHR5cGUgPT4gdHlwZSA9PT0gJ29yZGVyZWQtbGlzdCcgfHwgdHlwZSA9PT0gJ3Vub3JkZXJlZC1saXN0JztcbmNvbnN0IGlzTGlzdE5vZGUgPSBub2RlID0+IGlzTGlzdFR5cGUobm9kZS50eXBlKTtcbmNvbnN0IHRvZ2dsZUxpc3QgPSAoZWRpdG9yLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgbGlzdEFib3ZlID0gZ2V0TGlzdFR5cGVBYm92ZShlZGl0b3IpO1xuICBjb25zdCBpc0FjdGl2ZSA9IGlzRWxlbWVudEFjdGl2ZShlZGl0b3IsIGZvcm1hdCkgJiYgKGxpc3RBYm92ZSA9PT0gJ25vbmUnIHx8IGxpc3RBYm92ZSA9PT0gZm9ybWF0KTtcbiAgc2xhdGUuRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzTGlzdE5vZGUsXG4gICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgIG1vZGU6IGlzQWN0aXZlID8gJ2FsbCcgOiAnbG93ZXN0J1xuICAgIH0pO1xuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIHR5cGU6IGZvcm1hdCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoOiB4ID0+IHgudHlwZSAhPT0gJ2xpc3QtaXRlbS1jb250ZW50JyAmJiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIHgpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JMaXN0KGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcignbGlzdC1pdGVtJylcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzTGlzdE5vZGVcbiAgICB9KTtcblxuICAgIGlmIChsaXN0SXRlbSAmJiBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0luc2lkZTogdHJ1ZSxcbiAgICAgICAgbGlzdEl0ZW0sXG4gICAgICAgIGxpc3RcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0luc2lkZTogZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gd2l0aExpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnRCcmVhayxcbiAgICBub3JtYWxpemVOb2RlLFxuICAgIGRlbGV0ZUJhY2t3YXJkXG4gIH0gPSBlZGl0b3I7XG5cbiAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkID0gdW5pdCA9PiB7XG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yTGlzdCA9IGdldEFuY2VzdG9yTGlzdChlZGl0b3IpO1xuXG4gICAgICBpZiAoYW5jZXN0b3JMaXN0LmlzSW5zaWRlICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIHNsYXRlLkVkaXRvci5pc1N0YXJ0KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IsIGFuY2VzdG9yTGlzdC5saXN0WzFdKSkge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBpc0xpc3ROb2RlLFxuICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG5cbiAgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgIGNvbnN0IFtsaXN0SXRlbV0gPSBzbGF0ZS5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0nLFxuICAgICAgbW9kZTogJ2xvd2VzdCdcbiAgICB9KTtcblxuICAgIGlmIChsaXN0SXRlbSAmJiBzbGF0ZS5Ob2RlLnN0cmluZyhsaXN0SXRlbVswXSkgPT09ICcnKSB7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogaXNMaXN0Tm9kZSxcbiAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc2VydEJyZWFrKCk7XG4gIH07XG5cbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICBpZiAoc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgfHwgc2xhdGUuRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICBjb25zdCBpc0VsZW1lbnRCZWluZ05vcm1hbGl6ZWRBTGlzdCA9IGlzTGlzdE5vZGUobm9kZSk7XG5cbiAgICAgIGZvciAoY29uc3QgW2NoaWxkTm9kZSwgY2hpbGRQYXRoXSBvZiBzbGF0ZS5Ob2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjaGlsZFBhdGhbY2hpbGRQYXRoLmxlbmd0aCAtIDFdOyAvLyBtZXJnZSBzaWJsaW5nIGxpc3RzXG5cbiAgICAgICAgaWYgKGlzTGlzdE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgICAgIHZhciBfbm9kZSRjaGlsZHJlbjtcblxuICAgICAgICAgIGlmICgoKF9ub2RlJGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbltjaGlsZFBhdGhbY2hpbGRQYXRoLmxlbmd0aCAtIDFdICsgMV0pID09PSBudWxsIHx8IF9ub2RlJGNoaWxkcmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjaGlsZHJlbi50eXBlKSA9PT0gY2hpbGROb2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlUGF0aCA9IHNsYXRlLlBhdGgubmV4dChjaGlsZFBhdGgpO1xuICAgICAgICAgICAgbW92ZUNoaWxkcmVuKGVkaXRvciwgc2libGluZ05vZGVQYXRoLCBbLi4uY2hpbGRQYXRoLCBjaGlsZE5vZGUuY2hpbGRyZW4ubGVuZ3RoXSk7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogc2libGluZ05vZGVQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNFbGVtZW50QmVpbmdOb3JtYWxpemVkQUxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4IC0gMV07XG5cbiAgICAgICAgICAgIGlmIChzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChwcmV2aW91c0NoaWxkKSkge1xuICAgICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICAgICAgICAgIHRvOiBbLi4uc2xhdGUuUGF0aC5wcmV2aW91cyhjaGlsZFBhdGgpLCBwcmV2aW91c0NoaWxkLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbScgJiYgY2hpbGROb2RlLnR5cGUgIT09ICdsaXN0LWl0ZW0tY29udGVudCcgJiYgaW5kZXggPT09IDAgJiYgc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGlsZCA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgc2xhdGUuUGF0aC5wcmV2aW91cyhwYXRoKSk7XG5cbiAgICAgICAgICAgIGlmIChzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChwcmV2aW91c0NoaWxkKSkge1xuICAgICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgICAgICB0bzogWy4uLnNsYXRlLlBhdGgucHJldmlvdXMocGF0aCksIHByZXZpb3VzQ2hpbGQuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbScgJiYgY2hpbGROb2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0tY29udGVudCcgJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmNvbnN0IExpc3RCdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaXN0QnV0dG9uKHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvcixcbiAgICBsaXN0czoge1xuICAgICAgW3Byb3BzLnR5cGUgPT09ICdvcmRlcmVkLWxpc3QnID8gJ29yZGVyZWQnIDogJ3Vub3JkZXJlZCddOiB7XG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIGlzU2VsZWN0ZWRcbiAgICAgIH1cbiAgICB9XG4gIH0gPSB1c2VUb29sYmFyU3RhdGUoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gcHJvcHMsXG4gICAgICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMSk7XG5cbiAgICByZXR1cm4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdG9nZ2xlTGlzdChlZGl0b3IsIHR5cGUpO1xuICAgICAgfVxuICAgIH0sIHJlc3RQcm9wcykpO1xuICB9LCBbcHJvcHMsIHJlZiwgaXNEaXNhYmxlZCwgaXNTZWxlY3RlZCwgZWRpdG9yXSk7XG59KTtcbmZ1bmN0aW9uIG5lc3RMaXN0KGVkaXRvcikge1xuICBjb25zdCBibG9jayA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbiA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gIH0pO1xuXG4gIGlmICghYmxvY2sgfHwgYmxvY2tbMF0udHlwZSAhPT0gJ2xpc3QtaXRlbS1jb250ZW50Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGxpc3RJdGVtUGF0aCA9IHNsYXRlLlBhdGgucGFyZW50KGJsb2NrWzFdKTsgLy8gd2UncmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QgdGhlcmVmb3JlIHdlIGNhbid0IG5lc3RcblxuICBpZiAobGlzdEl0ZW1QYXRoW2xpc3RJdGVtUGF0aC5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzTGlzdEl0ZW1QYXRoID0gc2xhdGUuUGF0aC5wcmV2aW91cyhsaXN0SXRlbVBhdGgpO1xuICBjb25zdCBwcmV2aW91c0xpc3RJdGVtTm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcHJldmlvdXNMaXN0SXRlbVBhdGgpO1xuXG4gIGlmIChwcmV2aW91c0xpc3RJdGVtTm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcbiAgICAvLyB0aGVyZSdzIGEgbGlzdCBuZXN0ZWQgaW5zaWRlIG91ciBwcmV2aW91cyBzaWJsaW5nIGxpc3QgaXRlbSBzbyBtb3ZlIHRoZXJlXG4gICAgc2xhdGUuVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogbGlzdEl0ZW1QYXRoLFxuICAgICAgdG86IFsuLi5wcmV2aW91c0xpc3RJdGVtUGF0aCwgcHJldmlvdXNMaXN0SXRlbU5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgcHJldmlvdXNMaXN0SXRlbU5vZGUuY2hpbGRyZW5bcHJldmlvdXNMaXN0SXRlbU5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uY2hpbGRyZW4ubGVuZ3RoXVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IHNsYXRlLkVkaXRvci5wYXJlbnQoZWRpdG9yLCBzbGF0ZS5QYXRoLnBhcmVudChibG9ja1sxXSkpWzBdLnR5cGU7XG4gIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgIHR5cGUsXG4gICAgY2hpbGRyZW46IFtdXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVubmVzdExpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IGJsb2NrID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBuID0+IHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgfSk7XG5cbiAgaWYgKGJsb2NrICYmIGJsb2NrWzBdLnR5cGUgPT09ICdsaXN0LWl0ZW0tY29udGVudCcpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzTGlzdE5vZGUsXG4gICAgICBzcGxpdDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBUb29sYmFyU3RhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlVG9vbGJhclN0YXRlKCkge1xuICBjb25zdCB0b29sYmFyU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFRvb2xiYXJTdGF0ZUNvbnRleHQpO1xuXG4gIGlmICghdG9vbGJhclN0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb29sYmFyU3RhdGVQcm92aWRlciBtdXN0IGJlIHVzZWQgdG8gdXNlIHVzZVRvb2xiYXJTdGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIHRvb2xiYXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldEFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMoZWRpdG9yLCBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MpIHtcbiAgY29uc3QgYW5jZXN0b3JDb21wb25lbnRQcm9wID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBub2RlVHlwZU1hdGNoZXIoJ2NvbXBvbmVudC1ibG9jay1wcm9wJywgJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpXG4gIH0pO1xuXG4gIGlmIChhbmNlc3RvckNvbXBvbmVudFByb3ApIHtcbiAgICBjb25zdCBwcm9wUGF0aCA9IGFuY2VzdG9yQ29tcG9uZW50UHJvcFswXS5wcm9wUGF0aDtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IHNsYXRlLkVkaXRvci5wYXJlbnQoZWRpdG9yLCBhbmNlc3RvckNvbXBvbmVudFByb3BbMV0pO1xuXG4gICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50WzBdLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudFswXS5jb21wb25lbnQ7XG4gICAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbXBvbmVudEJsb2Nrc1tjb21wb25lbnRdO1xuXG4gICAgICBpZiAoY29tcG9uZW50QmxvY2sgJiYgcHJvcFBhdGgpIHtcbiAgICAgICAgdmFyIF9nZXRDaGlsZEZpZWxkQXRQcm9wUDtcblxuICAgICAgICBjb25zdCBvcHRpb25zID0gKF9nZXRDaGlsZEZpZWxkQXRQcm9wUCA9IGdldENoaWxkRmllbGRBdFByb3BQYXRoKHByb3BQYXRoLCBhbmNlc3RvckNvbXBvbmVudFswXS5wcm9wcywgY29tcG9uZW50QmxvY2sucHJvcHMpKSA9PT0gbnVsbCB8fCBfZ2V0Q2hpbGRGaWVsZEF0UHJvcFAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRDaGlsZEZpZWxkQXRQcm9wUC5vcHRpb25zO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIGdldERvY3VtZW50RmVhdHVyZXNGb3JDaGlsZEZpZWxkKGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBjcmVhdGVUb29sYmFyU3RhdGUgPSAoZWRpdG9yLCBjb21wb25lbnRCbG9ja3MsIGVkaXRvckRvY3VtZW50RmVhdHVyZXMpID0+IHtcbiAgY29uc3QgbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzID0gZ2V0QW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyhlZGl0b3IsIGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2NrcykgfHwge1xuICAgIGtpbmQ6ICdibG9jaycsXG4gICAgaW5saW5lTWFya3M6ICdpbmhlcml0JyxcbiAgICBkb2N1bWVudEZlYXR1cmVzOiB7XG4gICAgICBkaXZpZGVyczogdHJ1ZSxcbiAgICAgIGZvcm1hdHRpbmc6IHtcbiAgICAgICAgYWxpZ25tZW50OiB7XG4gICAgICAgICAgY2VudGVyOiB0cnVlLFxuICAgICAgICAgIGVuZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBibG9ja1R5cGVzOiB7XG4gICAgICAgICAgYmxvY2txdW90ZTogdHJ1ZSxcbiAgICAgICAgICBjb2RlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRpbmdMZXZlbHM6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAgICAgICAgbGlzdFR5cGVzOiB7XG4gICAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgICB1bm9yZGVyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxheW91dHM6IGVkaXRvckRvY3VtZW50RmVhdHVyZXMubGF5b3V0cyxcbiAgICAgIGxpbmtzOiB0cnVlLFxuICAgICAgcmVsYXRpb25zaGlwczogdHJ1ZVxuICAgIH0sXG4gICAgc29mdEJyZWFrczogdHJ1ZVxuICB9O1xuICBsZXQgW21heWJlQ29kZUJsb2NrRW50cnldID0gc2xhdGUuRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSAhPT0gJ2NvZGUnICYmIHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSlcbiAgfSk7XG4gIGNvbnN0IGVkaXRvck1hcmtzID0gc2xhdGUuRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge307XG4gIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKGFsbE1hcmtzLm1hcChtYXJrID0+IFttYXJrLCB7XG4gICAgaXNEaXNhYmxlZDogbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmlubGluZU1hcmtzICE9PSAnaW5oZXJpdCcgJiYgIWxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5pbmxpbmVNYXJrc1ttYXJrXSB8fCAhbWF5YmVDb2RlQmxvY2tFbnRyeSxcbiAgICBpc1NlbGVjdGVkOiAhIWVkaXRvck1hcmtzW21hcmtdXG4gIH1dKSk7IC8vIEVkaXRvci5tYXJrcyBpcyBcIndoYXQgYXJlIHRoZSBtYXJrcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgaWYgdGV4dCB3YXMgaW5zZXJ0ZWQgbm93XCJcbiAgLy8gdGhhdCdzIG5vdCByZWFsbHkgdGhlIFVYIHdlIHdhbnQsIGlmIHdlIGhhdmUgc29tZSBhIGRvY3VtZW50IGxpa2UgdGhpc1xuICAvLyA8cGFyYWdyYXBoPlxuICAvLyAgIDx0ZXh0PlxuICAvLyAgICAgPGFuY2hvciAvPlxuICAvLyAgICAgY29udGVudFxuICAvLyAgIDwvdGV4dD5cbiAgLy8gICA8dGV4dCBib2xkPmJvbGQ8L3RleHQ+XG4gIC8vICAgPHRleHQ+XG4gIC8vICAgICBjb250ZW50XG4gIC8vICAgICA8Zm9jdXMgLz5cbiAgLy8gICA8L3RleHQ+XG4gIC8vIDwvcGFyYWdyYXBoPlxuICAvLyB3ZSB3YW50IGJvbGQgdG8gYmUgc2hvd24gYXMgc2VsZWN0ZWQgZXZlbiB0aG91Z2ggaWYgeW91IGluc2VydGVkIHRleHQgZnJvbSB0aGF0IHNlbGVjdGlvbiwgaXQgd291bGRuJ3QgYmUgYm9sZFxuICAvLyBzbyB3ZSBsb29rIGF0IGFsbCB0aGUgdGV4dCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIHRvIGdldCB0aGVpciBtYXJrc1xuICAvLyBidXQgb25seSBpZiB0aGUgc2VsZWN0aW9uIGlzIGV4cGFuZGVkIGJlY2F1c2UgaWYgeW91J3JlIGluIHRoZSBtaWRkbGUgb2Ygc29tZSB0ZXh0XG4gIC8vIHdpdGggeW91ciBzZWxlY3Rpb24gY29sbGFwc2VkIHdpdGggYSBtYXJrIGJ1dCB5b3UndmUgcmVtb3ZlZCBpdChpLmUuIGVkaXRvci5yZW1vdmVNYXJrKVxuICAvLyB0aGUgdGV4dCBub2RlcyB5b3UncmUgaW4gd2lsbCBoYXZlIHRoZSBtYXJrIGJ1dCB0aGUgdWkgc2hvdWxkIHNob3cgdGhlIG1hcmsgYXMgbm90IGJlaW5nIHNlbGVjdGVkXG5cbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgc2xhdGUuUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzbGF0ZS5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogc2xhdGUuVGV4dC5pc1RleHRcbiAgICB9KSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobm9kZVswXSkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2luc2VydE1lbnUnIHx8IGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5IGluIG1hcmtzKSB7XG4gICAgICAgICAgbWFya3Nba2V5XS5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBbaGVhZGluZ0VudHJ5XSA9IHNsYXRlLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZVR5cGVNYXRjaGVyKCdoZWFkaW5nJylcbiAgfSk7XG4gIGxldCBbbGlzdEVudHJ5XSA9IHNsYXRlLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogaXNMaXN0Tm9kZVxuICB9KTtcbiAgbGV0IFthbGlnbmFibGVFbnRyeV0gPSBzbGF0ZS5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigncGFyYWdyYXBoJywgJ2hlYWRpbmcnKVxuICB9KTsgLy8gKHdlJ3JlIGdvbm5hIHVzZSBtYXJrZG93biBoZXJlIGJlY2F1c2UgdGhlIGVxdWl2ZWxhbnQgc2xhdGUgc3RydWN0dXJlIGlzIHF1aXRlIGxhcmdlIGFuZCBkb2Vzbid0IGFkZCB2YWx1ZSBoZXJlKVxuICAvLyBsZXQncyBpbWFnaW5lIGEgZG9jdW1lbnQgdGhhdCBsb29rcyBsaWtlIHRoaXM6XG4gIC8vIC0gdGhpbmdcbiAgLy8gICAxLiBzb21ldGhpbmc8Y3Vyc29yIC8+XG4gIC8vIGluIHRoZSB0b29sYmFyLCB5b3UgZG9uJ3Qgd2FudCB0byBzZWUgdGhhdCBib3RoIG9yZGVyZWQgYW5kIHVub3JkZXJlZCBsaXN0cyBhcmUgc2VsZWN0ZWRcbiAgLy8geW91IHdhbnQgdG8gc2VlIG9ubHkgb3JkZXJlZCBsaXN0IHNlbGVjdGVkLCBiZWNhdXNlXG4gIC8vIC0geW91IHdhbnQgdG8ga25vdyB3aGF0IGxpc3QgeW91J3JlIGFjdHVhbGx5IGluLCB5b3UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgdGhlIG91dGVyIGxpc3RcbiAgLy8gLSB3aGVuIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgbGlzdCB0byBhIHVub3JkZXJlZCBsaXN0LCB0aGUgdW5vcmRlcmVkIGxpc3QgYnV0dG9uIHNob3VsZCBiZSBpbmFjdGl2ZSB0byBzaG93IHlvdSBjYW4gY2hhbmdlIHRvIGl0XG5cbiAgY29uc3QgbGlzdFR5cGVBYm92ZSA9IGdldExpc3RUeXBlQWJvdmUoZWRpdG9yKTtcbiAgcmV0dXJuIHtcbiAgICBtYXJrcyxcbiAgICB0ZXh0U3R5bGVzOiB7XG4gICAgICBzZWxlY3RlZDogaGVhZGluZ0VudHJ5ID8gaGVhZGluZ0VudHJ5WzBdLmxldmVsIDogJ25vcm1hbCcsXG4gICAgICBhbGxvd2VkSGVhZGluZ0xldmVsczogbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmtpbmQgPT09ICdibG9jaycgJiYgIWxpc3RFbnRyeSA/IGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ0xldmVscyA6IFtdXG4gICAgfSxcbiAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICBpc0Rpc2FibGVkOiAhbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMucmVsYXRpb25zaGlwc1xuICAgIH0sXG4gICAgY29kZToge1xuICAgICAgaXNTZWxlY3RlZDogaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ2NvZGUnKSxcbiAgICAgIGlzRGlzYWJsZWQ6ICEobG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmtpbmQgPT09ICdibG9jaycgJiYgbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUpXG4gICAgfSxcbiAgICBsaXN0czoge1xuICAgICAgb3JkZXJlZDoge1xuICAgICAgICBpc1NlbGVjdGVkOiBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnb3JkZXJlZC1saXN0JykgJiYgKGxpc3RUeXBlQWJvdmUgPT09ICdub25lJyB8fCBsaXN0VHlwZUFib3ZlID09PSAnb3JkZXJlZC1saXN0JyksXG4gICAgICAgIGlzRGlzYWJsZWQ6ICEobG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmtpbmQgPT09ICdibG9jaycgJiYgbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5saXN0VHlwZXMub3JkZXJlZCAmJiAhaGVhZGluZ0VudHJ5KVxuICAgICAgfSxcbiAgICAgIHVub3JkZXJlZDoge1xuICAgICAgICBpc1NlbGVjdGVkOiBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAndW5vcmRlcmVkLWxpc3QnKSAmJiAobGlzdFR5cGVBYm92ZSA9PT0gJ25vbmUnIHx8IGxpc3RUeXBlQWJvdmUgPT09ICd1bm9yZGVyZWQtbGlzdCcpLFxuICAgICAgICBpc0Rpc2FibGVkOiAhKGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5raW5kID09PSAnYmxvY2snICYmIGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLnVub3JkZXJlZCAmJiAhaGVhZGluZ0VudHJ5KVxuICAgICAgfVxuICAgIH0sXG4gICAgYWxpZ25tZW50OiB7XG4gICAgICBpc0Rpc2FibGVkOiAhYWxpZ25hYmxlRW50cnkgJiYgIShsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMua2luZCA9PT0gJ2Jsb2NrJyAmJiBsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMuZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmFsaWdubWVudCksXG4gICAgICBzZWxlY3RlZDogKGFsaWduYWJsZUVudHJ5ID09PSBudWxsIHx8IGFsaWduYWJsZUVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGlnbmFibGVFbnRyeVswXS50ZXh0QWxpZ24pIHx8ICdzdGFydCdcbiAgICB9LFxuICAgIGJsb2NrcXVvdGU6IHtcbiAgICAgIGlzRGlzYWJsZWQ6ICEobG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmtpbmQgPT09ICdibG9jaycgJiYgbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmJsb2NrcXVvdGUpLFxuICAgICAgaXNTZWxlY3RlZDogaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ2Jsb2NrcXVvdGUnKVxuICAgIH0sXG4gICAgbGF5b3V0czoge1xuICAgICAgaXNTZWxlY3RlZDogaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ2xheW91dCcpXG4gICAgfSxcbiAgICBsaW5rczoge1xuICAgICAgaXNEaXNhYmxlZDogIWVkaXRvci5zZWxlY3Rpb24gfHwgc2xhdGUuUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgfHwgIWxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmxpbmtzLFxuICAgICAgaXNTZWxlY3RlZDogaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ2xpbmsnKVxuICAgIH0sXG4gICAgZWRpdG9yLFxuICAgIGRpdmlkZXJzOiB7XG4gICAgICBpc0Rpc2FibGVkOiBsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMua2luZCA9PT0gJ2lubGluZScgfHwgIWxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmRpdmlkZXJzXG4gICAgfSxcbiAgICBjbGVhckZvcm1hdHRpbmc6IHtcbiAgICAgIGlzRGlzYWJsZWQ6ICEoT2JqZWN0LnZhbHVlcyhtYXJrcykuc29tZSh4ID0+IHguaXNTZWxlY3RlZCkgfHwgISFoYXNCbG9ja1RoYXRDbGVhcnNPbkNsZWFyRm9ybWF0dGluZyhlZGl0b3IpKVxuICAgIH0sXG4gICAgZWRpdG9yRG9jdW1lbnRGZWF0dXJlc1xuICB9O1xufTtcblxuZnVuY3Rpb24gaGFzQmxvY2tUaGF0Q2xlYXJzT25DbGVhckZvcm1hdHRpbmcoZWRpdG9yKSB7XG4gIGNvbnN0IFtub2RlXSA9IHNsYXRlLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdoZWFkaW5nJyB8fCBub2RlLnR5cGUgPT09ICdjb2RlJyB8fCBub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJ1xuICB9KTtcbiAgcmV0dXJuICEhbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0TGlzdFR5cGVBYm92ZShlZGl0b3IpIHtcbiAgY29uc3QgbGlzdEFib3ZlID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBpc0xpc3ROb2RlXG4gIH0pO1xuXG4gIGlmICghbGlzdEFib3ZlKSB7XG4gICAgcmV0dXJuICdub25lJztcbiAgfVxuXG4gIHJldHVybiBsaXN0QWJvdmVbMF0udHlwZTtcbn1cbmNvbnN0IFRvb2xiYXJTdGF0ZVByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIGNvbXBvbmVudEJsb2NrcyxcbiAgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcyxcbiAgcmVsYXRpb25zaGlwc1xufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBzbGF0ZVJlYWN0LnVzZVNsYXRlKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHNQcm92aWRlciwge1xuICAgIHZhbHVlOiByZWxhdGlvbnNoaXBzXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMYXlvdXRPcHRpb25zUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5sYXlvdXRzXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDb21wb25lbnRCbG9ja0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9uZW50QmxvY2tzXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUb29sYmFyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNyZWF0ZVRvb2xiYXJTdGF0ZShlZGl0b3IsIGNvbXBvbmVudEJsb2NrcywgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcylcbiAgfSwgY2hpbGRyZW4pKSkpO1xufTtcblxuY29uc3QgaXNMaW5rQWN0aXZlID0gZWRpdG9yID0+IHtcbiAgcmV0dXJuIGlzRWxlbWVudEFjdGl2ZShlZGl0b3IsICdsaW5rJyk7XG59O1xuXG5jb25zdCB3cmFwTGluayA9IChlZGl0b3IsIHVybCkgPT4ge1xuICBpZiAoaXNMaW5rQWN0aXZlKGVkaXRvcikpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gbi50eXBlID09PSAnbGluaydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGNvbnN0IGlzQ29sbGFwc2VkID0gc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbik7XG5cbiAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIGhyZWY6IHVybCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0ZXh0OiB1cmxcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICB0eXBlOiAnbGluaycsXG4gICAgICBocmVmOiB1cmwsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgc3BsaXQ6IHRydWVcbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IExpbmtFbGVtZW50ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG4gIGVsZW1lbnQ6IF9fZWxlbWVudEZvckdldHRpbmdQYXRoXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBvZ3JhcGh5XG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIGNvbnN0IGVkaXRvciA9IHNsYXRlUmVhY3QudXNlU2xhdGVTdGF0aWMoKTtcbiAgY29uc3QgW2N1cnJlbnRFbGVtZW50LCBzZXROb2RlXSA9IHVzZUVsZW1lbnRXaXRoU2V0Tm9kZXMoZWRpdG9yLCBfX2VsZW1lbnRGb3JHZXR0aW5nUGF0aCk7XG4gIGNvbnN0IGhyZWYgPSBjdXJyZW50RWxlbWVudC5ocmVmO1xuICBjb25zdCBzZWxlY3RlZCA9IHNsYXRlUmVhY3QudXNlU2VsZWN0ZWQoKTtcbiAgY29uc3QgZm9jdXNlZCA9IHNsYXRlUmVhY3QudXNlRm9jdXNlZCgpO1xuICBjb25zdCBbZm9jdXNlZEluSW5saW5lRGlhbG9nLCBzZXRGb2N1c2VkSW5JbmxpbmVEaWFsb2ddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbG9jYWxGb3JjZVZhbGlkYXRpb24sIHNldExvY2FsRm9yY2VWYWxpZGF0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGRpYWxvZyxcbiAgICB0cmlnZ2VyXG4gIH0gPSBwb3BvdmVyLnVzZUNvbnRyb2xsZWRQb3BvdmVyKHtcbiAgICBpc09wZW46IHNlbGVjdGVkICYmIGZvY3VzZWQgfHwgZm9jdXNlZEluSW5saW5lRGlhbG9nLFxuICAgIG9uQ2xvc2U6ICgpID0+IHt9XG4gIH0sIHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgIG1vZGlmaWVyczogW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IFswLCA4XVxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICBjb25zdCB1bmxpbmsgPSB1c2VFdmVudENhbGxiYWNrKCgpID0+IHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNsYXRlUmVhY3QuUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBfX2VsZW1lbnRGb3JHZXR0aW5nUGF0aClcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGZvcmNlVmFsaWRhdGlvbiA9IHVzZUZvcmNlVmFsaWRhdGlvbigpO1xuICBjb25zdCBzaG93SW52YWxpZFN0YXRlID0gYXBpLmlzVmFsaWRVUkwoaHJlZikgPyBmYWxzZSA6IGZvcmNlVmFsaWRhdGlvbiB8fCBsb2NhbEZvcmNlVmFsaWRhdGlvbjtcbiAgcmV0dXJuIGNvcmUuanN4KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNzczoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgIH1cbiAgfSksIGNvcmUuanN4KFwiYVwiLCBfZXh0ZW5kcyh7fSwgdHJpZ2dlci5wcm9wcywge1xuICAgIGNzczoge1xuICAgICAgY29sb3I6IHNob3dJbnZhbGlkU3RhdGUgPyAncmVkJyA6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgcmVmOiB0cmlnZ2VyLnJlZixcbiAgICBocmVmOiBocmVmXG4gIH0pLCBjaGlsZHJlbiksIChzZWxlY3RlZCAmJiBmb2N1c2VkIHx8IGZvY3VzZWRJbklubGluZURpYWxvZykgJiYgY29yZS5qc3goY29yZS5Qb3J0YWwsIG51bGwsIGNvcmUuanN4KHRvb2xiYXIuSW5saW5lRGlhbG9nLCBfZXh0ZW5kcyh7fSwgZGlhbG9nLnByb3BzLCB7XG4gICAgcmVmOiBkaWFsb2cucmVmLFxuICAgIG9uRm9jdXM6ICgpID0+IHtcbiAgICAgIHNldEZvY3VzZWRJbklubGluZURpYWxvZyh0cnVlKTtcbiAgICB9LFxuICAgIG9uQmx1cjogKCkgPT4ge1xuICAgICAgc2V0Rm9jdXNlZEluSW5saW5lRGlhbG9nKGZhbHNlKTtcbiAgICAgIHNldExvY2FsRm9yY2VWYWxpZGF0aW9uKHRydWUpO1xuICAgIH1cbiAgfSksIGNvcmUuanN4KFwiZGl2XCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgfVxuICB9LCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJHcm91cCwgbnVsbCwgY29yZS5qc3goXCJpbnB1dFwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBmb250U2l6ZTogdHlwb2dyYXBoeS5mb250U2l6ZS5zbWFsbCxcbiAgICAgIHdpZHRoOiAyNDBcbiAgICB9LFxuICAgIHZhbHVlOiBocmVmLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiB7XG4gICAgICBzZXROb2RlKHtcbiAgICAgICAgaHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBjb250ZW50OiBcIk9wZW4gbGluayBpbiBuZXcgdGFiXCIsXG4gICAgd2VpZ2h0OiBcInN1YnRsZVwiXG4gIH0sIGF0dHJzID0+IGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIGFzOiBcImFcIixcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIGhyZWY6IGhyZWYsXG4gICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgIHJlbDogXCJub3JlZmVycmVyXCIsXG4gICAgdmFyaWFudDogXCJhY3Rpb25cIlxuICB9LCBhdHRycyksIGV4dGVybmFsTGlua0ljb24pKSwgc2VwYXJhdG9yLCBjb3JlLmpzeChVbmxpbmtCdXR0b24sIHtcbiAgICBvblVubGluazogdW5saW5rXG4gIH0pKSwgc2hvd0ludmFsaWRTdGF0ZSAmJiBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge1xuICAgICAgY29sb3I6ICdyZWQnXG4gICAgfVxuICB9LCBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIFVSTFwiKSkpKSk7XG59O1xuY29uc3Qgc2VwYXJhdG9yID0gY29yZS5qc3godG9vbGJhci5Ub29sYmFyU2VwYXJhdG9yLCBudWxsKTtcbmNvbnN0IGV4dGVybmFsTGlua0ljb24gPSBjb3JlLmpzeChFeHRlcm5hbExpbmtJY29uLkV4dGVybmFsTGlua0ljb24sIHtcbiAgc2l6ZTogXCJzbWFsbFwiXG59KTtcbmNvbnN0IFVubGlua0J1dHRvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIFVubGlua0J1dHRvbih7XG4gIG9uVW5saW5rXG59KSB7XG4gIHJldHVybiBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBjb250ZW50OiBcIlVubGlua1wiLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICB2YXJpYW50OiBcImRlc3RydWN0aXZlXCIsXG4gICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvblVubGluaygpO1xuICAgIH1cbiAgfSwgYXR0cnMpLCBjb3JlLmpzeChUcmFzaDJJY29uLlRyYXNoMkljb24sIHtcbiAgICBzaXplOiBcInNtYWxsXCJcbiAgfSkpKTtcbn0pO1xubGV0IGxpbmtJY29uID0gY29yZS5qc3goTGlua0ljb24uTGlua0ljb24sIHtcbiAgc2l6ZTogXCJzbWFsbFwiXG59KTtcbmNvbnN0IExpbmtCdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rQnV0dG9uKHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvcixcbiAgICBsaW5rczoge1xuICAgICAgaXNEaXNhYmxlZCxcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9XG4gIH0gPSB1c2VUb29sYmFyU3RhdGUoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgd3JhcExpbmsoZWRpdG9yLCAnJyk7XG4gICAgfVxuICB9LCBwcm9wcyksIGxpbmtJY29uKSwgW2lzU2VsZWN0ZWQsIGlzRGlzYWJsZWQsIGVkaXRvciwgcHJvcHMsIHJlZl0pO1xufSk7XG5jb25zdCBsaW5rQnV0dG9uID0gY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gIGNvbnRlbnQ6IFwiTGlua1wiLFxuICB3ZWlnaHQ6IFwic3VidGxlXCJcbn0sIGF0dHJzID0+IGNvcmUuanN4KExpbmtCdXR0b24sIGF0dHJzKSk7XG5jb25zdCBtYXJrZG93bkxpbmtQYXR0ZXJuID0gLyhefFxccylcXFsoLis/KVxcXVxcKChcXFMrKVxcKSQvO1xuZnVuY3Rpb24gd2l0aExpbmsoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGluc2VydFRleHQsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5pc0lubGluZSA9IGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09ICdsaW5rJyA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcblxuICBpZiAoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5saW5rcykge1xuICAgIGVkaXRvci5pbnNlcnRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICBpbnNlcnRUZXh0KHRleHQpO1xuICAgICAgaWYgKHRleHQgIT09ICcpJyB8fCAhZWRpdG9yLnNlbGVjdGlvbikgcmV0dXJuO1xuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrID0gc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbm9kZSA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpXG4gICAgICB9KVsxXSk7XG4gICAgICBjb25zdCBzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcgPSBzbGF0ZS5FZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICBhbmNob3I6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICBmb2N1czogc3RhcnRPZkJsb2NrXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWFya2Rvd25MaW5rUGF0dGVybi5leGVjKHN0YXJ0T2ZCbG9ja1RvRW5kT2ZTaG9ydGN1dFN0cmluZyk7XG4gICAgICBpZiAoIW1hdGNoKSByZXR1cm47XG4gICAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzID0gZ2V0QW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyhlZGl0b3IsIGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG5cbiAgICAgIGlmICgoYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyA9PT0gbnVsbCB8fCBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMubGlua3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFssIG1heWJlV2hpdGVzcGFjZSwgbGlua1RleHQsIGhyZWZdID0gbWF0Y2g7IC8vIGJ5IGRvaW5nIHRoaXMsIHRoZSBpbnNlcnRUZXh0KCcpJykgYWJvdmUgd2lsbCBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgdW5kbyB0aGFuIHRoZSBsaW5rIHJlcGxhY2VtZW50XG4gICAgICAvLyBzbyB0aGF0IG1lYW5zIHRoYXQgd2hlbiBzb21lb25lIGRvZXMgYW4gdW5kbyBhZnRlciB0aGlzXG4gICAgICAvLyBpdCB3aWxsIHVuZG8gdGhlIHRoZSBzdGF0ZSBvZiBcIltjb250ZW50XShsaW5rKVwiIHJhdGhlciB0aGFuIFwiW2NvbnRlbnRdKGxpbmtcIiAobm90ZSB0aGUgbWlzc2luZyBjbG9zaW5nIGJyYWNrZXQpXG5cbiAgICAgIGVkaXRvci5oaXN0b3J5LnVuZG9zLnB1c2goW10pO1xuICAgICAgY29uc3Qgc3RhcnRPZlNob3J0Y3V0ID0gbWF0Y2guaW5kZXggPT09IDAgPyBzdGFydE9mQmxvY2sgOiBFZGl0b3JBZnRlckJ1dElnbm9yaW5naW5nUG9pbnRzV2l0aE5vQ29udGVudChlZGl0b3IsIHN0YXJ0T2ZCbG9jaywge1xuICAgICAgICBkaXN0YW5jZTogbWF0Y2guaW5kZXhcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhcnRPZkxpbmtUZXh0ID0gRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBzdGFydE9mU2hvcnRjdXQsIHtcbiAgICAgICAgZGlzdGFuY2U6IG1heWJlV2hpdGVzcGFjZSA9PT0gJycgPyAxIDogMlxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmRPZkxpbmtUZXh0ID0gRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBzdGFydE9mTGlua1RleHQsIHtcbiAgICAgICAgZGlzdGFuY2U6IGxpbmtUZXh0Lmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHtcbiAgICAgICAgICBhbmNob3I6IGVuZE9mTGlua1RleHQsXG4gICAgICAgICAgZm9jdXM6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB7XG4gICAgICAgICAgYW5jaG9yOiBzdGFydE9mU2hvcnRjdXQsXG4gICAgICAgICAgZm9jdXM6IHN0YXJ0T2ZMaW5rVGV4dFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfSwge1xuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IHN0YXJ0T2ZTaG9ydGN1dFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnICYmIHNsYXRlLk5vZGUuc3RyaW5nKG5vZGUpID09PSAnJykge1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcblxuICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBpbnNlcnRCbG9ja3F1b3RlID0gZWRpdG9yID0+IHtcbiAgY29uc3QgaXNBY3RpdmUgPSBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnYmxvY2txdW90ZScpO1xuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJ1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldERpcmVjdEJsb2NrcXVvdGVQYXJlbnRGcm9tU2VsZWN0aW9uKGVkaXRvcikge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pIHJldHVybiB7XG4gICAgaXNJbnNpZGU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IFssIHBhcmVudFBhdGhdID0gc2xhdGUuRWRpdG9yLnBhcmVudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICBjb25zdCBbbWF5YmVCbG9ja3F1b3RlUGFyZW50LCBtYXliZUJsb2NrcXVvdGVQYXJlbnRQYXRoXSA9IHNsYXRlLkVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgY29uc3QgaXNCbG9ja3F1b3RlID0gbWF5YmVCbG9ja3F1b3RlUGFyZW50LnR5cGUgPT09ICdibG9ja3F1b3RlJztcbiAgcmV0dXJuIGlzQmxvY2txdW90ZSA/IHtcbiAgICBpc0luc2lkZTogdHJ1ZSxcbiAgICBwYXRoOiBtYXliZUJsb2NrcXVvdGVQYXJlbnRQYXRoXG4gIH0gOiB7XG4gICAgaXNJbnNpZGU6IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpdGhCbG9ja3F1b3RlKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0QnJlYWssXG4gICAgZGVsZXRlQmFja3dhcmRcbiAgfSA9IGVkaXRvcjtcblxuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2txdW90ZSA9IGdldERpcmVjdEJsb2NrcXVvdGVQYXJlbnRGcm9tU2VsZWN0aW9uKGVkaXRvcik7XG5cbiAgICAgIGlmIChwYXJlbnRCbG9ja3F1b3RlLmlzSW5zaWRlICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIC8vIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJhZ3JhcGhcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAvLyBpdCdzIHRoZSBmaXJzdCBwYXJhZ3JhcGggaW4gdGhlIHBhbmVsXG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5wYXRoW2VkaXRvci5zZWxlY3Rpb24uYW5jaG9yLnBhdGgubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICBzcGxpdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9O1xuXG4gIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICBjb25zdCBwYW5lbCA9IGdldERpcmVjdEJsb2NrcXVvdGVQYXJlbnRGcm9tU2VsZWN0aW9uKGVkaXRvcik7XG5cbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBwYW5lbC5pc0luc2lkZSkge1xuICAgICAgY29uc3QgW25vZGUsIG5vZGVQYXRoXSA9IHNsYXRlLkVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChzbGF0ZS5QYXRoLmlzRGVzY2VuZGFudChub2RlUGF0aCwgcGFuZWwucGF0aCkgJiYgc2xhdGUuTm9kZS5zdHJpbmcobm9kZSkgPT09ICcnKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnYmxvY2txdW90ZScsXG4gICAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnNlcnRCcmVhaygpO1xuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59XG5jb25zdCBCbG9ja3F1b3RlRWxlbWVudCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZ1xuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJibG9ja3F1b3RlXCIsIF9leHRlbmRzKHtcbiAgICBjc3M6IHtcbiAgICAgIGJvcmRlckxlZnQ6ICczcHggc29saWQgI0NCRDVFMCcsXG4gICAgICBjb2xvcjogY29sb3JzLmZvcmVncm91bmREaW0sXG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiBgMCAke3NwYWNpbmcueGxhcmdlfXB4YFxuICAgIH1cbiAgfSwgYXR0cmlidXRlcyksIGNoaWxkcmVuKTtcbn07XG5cbmNvbnN0IEJsb2NrcXVvdGVCdXR0b24gPSAoe1xuICBhdHRyc1xufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLFxuICAgIGJsb2NrcXVvdGU6IHtcbiAgICAgIGlzRGlzYWJsZWQsXG4gICAgICBpc1NlbGVjdGVkXG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGluc2VydEJsb2NrcXVvdGUoZWRpdG9yKTtcbiAgICB9XG4gIH0sIGF0dHJzKSwgY29yZS5qc3goUXVvdGVJY29uLCBudWxsKSksIFtlZGl0b3IsIGF0dHJzLCBpc0Rpc2FibGVkLCBpc1NlbGVjdGVkXSk7XG59O1xuXG5jb25zdCBibG9ja3F1b3RlQnV0dG9uID0gY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gIGNvbnRlbnQ6IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIlF1b3RlXCIsIGNvcmUuanN4KHRvb2xiYXIuS2V5Ym9hcmRJblRvb2x0aXAsIG51bGwsICc+ICcpKSxcbiAgd2VpZ2h0OiBcInN1YnRsZVwiXG59LCBhdHRycyA9PiBjb3JlLmpzeChCbG9ja3F1b3RlQnV0dG9uLCB7XG4gIGF0dHJzOiBhdHRyc1xufSkpO1xuXG5jb25zdCBRdW90ZUljb24gPSAoKSA9PiBjb3JlLmpzeChJY29uQmFzZSwgbnVsbCwgY29yZS5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMTEuMzAzMSAyQzkuODM4NDMgMiA4LjY0ODc5IDMuMjIzMjEgOC42NDg3OSA0LjczMTcxQzguNjQ4NzkgNi4yMzkyOCA5LjgzODQzIDcuNDYzNDIgMTEuMzAzMSA3LjQ2MzQyQzEzLjgxOTUgNy40NjM0MiAxMi4zNjEzIDEyLjIwNzEgOS4xODc2NyAxMi43MDEyQzkuMDM3OTMgMTIuNzIzOSA4LjkwMTI3IDEyLjc5OTUgOC44MDI0MyAxMi45MTQzQzguNzAzNTggMTMuMDI5IDguNjQ5MDggMTMuMTc1NCA4LjY0ODc5IDEzLjMyNjhDOC42NDg3OSAxMy43MTQ3IDguOTk1NjEgMTQuMDIxNCA5LjM3OTczIDEzLjk2MjdDMTUuMTQ4IDEzLjA4ODEgMTcuMTk5MSAyLjAwMDkzIDExLjMwMzEgMi4wMDA5M1YyWk0zLjY1NTI2IDJDMi4xODg3MSAyIDEgMy4yMjIyOCAxIDQuNzMxNzFDMSA2LjIzODM1IDIuMTg4NzEgNy40NjE1NSAzLjY1NTI2IDcuNDYxNTVDNi4xNzA2NyA3LjQ2MTU1IDQuNzEyNTIgMTIuMjA3MSAxLjUzODg4IDEyLjcwMTJDMS4zODkzIDEyLjcyMzkgMS4yNTI3NyAxMi43OTkzIDEuMTUzOTQgMTIuOTEzOUMxLjA1NTExIDEzLjAyODUgMS4wMDA1MSAxMy4xNzQ2IDEgMTMuMzI1OUMxIDEzLjcxMzcgMS4zNDY4MiAxNC4wMjA1IDEuNzMwMDEgMTMuOTYxN0M3LjUwMDE2IDEzLjA4NzIgOS41NTEyOCAyIDMuNjU1MjYgMlpcIlxufSkpO1xuXG5mdW5jdGlvbiB3aXRoQ29kZUJsb2NrKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0QnJlYWssXG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgfSkgfHwgW2VkaXRvciwgW11dO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvZGUnICYmIHNsYXRlLlRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5jaGlsZHJlblswXS50ZXh0O1xuXG4gICAgICBpZiAodGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJyAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIHNsYXRlLlBvaW50LmVxdWFscyhzbGF0ZS5FZGl0b3IuZW5kKGVkaXRvciwgcGF0aCksIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yKSkge1xuICAgICAgICBpbnNlcnRCcmVhaygpO1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogdGV4dC5sZW5ndGggLSAxXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlZGl0b3IuaW5zZXJ0VGV4dCgnXFxuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zZXJ0QnJlYWsoKTtcbiAgfTtcblxuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnY29kZScgJiYgc2xhdGUuRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGlmICghc2xhdGUuVGV4dC5pc1RleHQoY2hpbGROb2RlKSkge1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNWb2lkKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgaW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hcmtzID0gT2JqZWN0LmtleXMoY2hpbGROb2RlKS5maWx0ZXIoeCA9PiB4ICE9PSAndGV4dCcpO1xuXG4gICAgICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBtYXJrcywge1xuICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpbmRleF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVOb2RlKFtub2RlLCBwYXRoXSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuZnVuY3Rpb24gQ29kZUJ1dHRvbih7XG4gIGF0dHJzXG59KSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsXG4gICAgY29kZToge1xuICAgICAgaXNEaXNhYmxlZCxcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9XG4gIH0gPSB1c2VUb29sYmFyU3RhdGUoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ2NvZGUnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGF0dHJzKSwgY29yZS5qc3goQ29kZUljb24uQ29kZUljb24sIHtcbiAgICBzaXplOiBcInNtYWxsXCJcbiAgfSkpLCBbaXNEaXNhYmxlZCwgaXNTZWxlY3RlZCwgYXR0cnMsIGVkaXRvcl0pO1xufVxuXG5jb25zdCBjb2RlQnV0dG9uID0gY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gIHdlaWdodDogXCJzdWJ0bGVcIixcbiAgY29udGVudDogY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIFwiQ29kZSBibG9jayBcIiwgY29yZS5qc3godG9vbGJhci5LZXlib2FyZEluVG9vbHRpcCwgbnVsbCwgXCJgYGBcIikpXG59LCBhdHRycyA9PiBjb3JlLmpzeChDb2RlQnV0dG9uLCB7XG4gIGF0dHJzOiBhdHRyc1xufSkpO1xuXG5jb25zdCBUZXh0QWxpZ25NZW51ID0gKHtcbiAgYWxpZ25tZW50XG59KSA9PiB7XG4gIGNvbnN0IFtzaG93TWVudSwgc2V0U2hvd01lbnVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZGlhbG9nLFxuICAgIHRyaWdnZXJcbiAgfSA9IHBvcG92ZXIudXNlQ29udHJvbGxlZFBvcG92ZXIoe1xuICAgIGlzT3Blbjogc2hvd01lbnUsXG4gICAgb25DbG9zZTogKCkgPT4gc2V0U2hvd01lbnUoZmFsc2UpXG4gIH0sIHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgIG1vZGlmaWVyczogW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IFswLCA4XVxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSwgY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gICAgY29udGVudDogXCJUZXh0IGFsaWdubWVudFwiLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeChUZXh0QWxpZ25CdXR0b24sIHtcbiAgICBhdHRyczogYXR0cnMsXG4gICAgb25Ub2dnbGU6ICgpID0+IHtcbiAgICAgIHNldFNob3dNZW51KHggPT4gIXgpO1xuICAgIH0sXG4gICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICBzaG93TWVudTogc2hvd01lbnVcbiAgfSkpLCBzaG93TWVudSA/IGNvcmUuanN4KHRvb2xiYXIuSW5saW5lRGlhbG9nLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaWFsb2cucmVmXG4gIH0sIGRpYWxvZy5wcm9wcyksIGNvcmUuanN4KFRleHRBbGlnbkRpYWxvZywge1xuICAgIGFsaWdubWVudDogYWxpZ25tZW50LFxuICAgIG9uQ2xvc2U6ICgpID0+IHtcbiAgICAgIHNldFNob3dNZW51KGZhbHNlKTtcbiAgICB9XG4gIH0pKSA6IG51bGwpO1xufTtcblxuZnVuY3Rpb24gVGV4dEFsaWduRGlhbG9nKHtcbiAgYWxpZ25tZW50LFxuICBvbkNsb3NlXG59KSB7XG4gIGNvbnN0IHtcbiAgICBhbGlnbm1lbnQ6IHtcbiAgICAgIHNlbGVjdGVkXG4gICAgfSxcbiAgICBlZGl0b3JcbiAgfSA9IHVzZVRvb2xiYXJTdGF0ZSgpO1xuICBjb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsIC4uLk9iamVjdC5rZXlzKGFsaWdubWVudCkuZmlsdGVyKGtleSA9PiBhbGlnbm1lbnRba2V5XSldO1xuICByZXR1cm4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyR3JvdXAsIG51bGwsIGFsaWdubWVudHMubWFwKGFsaWdubWVudCA9PiBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBrZXk6IGFsaWdubWVudCxcbiAgICBjb250ZW50OiBgQWxpZ24gJHthbGlnbm1lbnR9YCxcbiAgICB3ZWlnaHQ6IFwic3VidGxlXCJcbiAgfSwgYXR0cnMgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgaXNTZWxlY3RlZDogc2VsZWN0ZWQgPT09IGFsaWdubWVudCxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAndGV4dEFsaWduJywge1xuICAgICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbm9kZS50eXBlID09PSAnaGVhZGluZydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIHRleHRBbGlnbjogYWxpZ25tZW50XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBhdHRycyksIGFsaWdubWVudEljb25zW2FsaWdubWVudF0pKSkpO1xufVxuXG5jb25zdCBhbGlnbm1lbnRJY29ucyA9IHtcbiAgc3RhcnQ6IGNvcmUuanN4KEFsaWduTGVmdEljb24uQWxpZ25MZWZ0SWNvbiwge1xuICAgIHNpemU6IFwic21hbGxcIlxuICB9KSxcbiAgY2VudGVyOiBjb3JlLmpzeChBbGlnbkNlbnRlckljb24uQWxpZ25DZW50ZXJJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pLFxuICBlbmQ6IGNvcmUuanN4KEFsaWduUmlnaHRJY29uLkFsaWduUmlnaHRJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pXG59O1xuXG5mdW5jdGlvbiBUZXh0QWxpZ25CdXR0b24ocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFsaWdubWVudDoge1xuICAgICAgaXNEaXNhYmxlZCxcbiAgICAgIHNlbGVjdGVkXG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgaXNQcmVzc2VkOiBwcm9wcy5zaG93TWVudSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByb3BzLm9uVG9nZ2xlKCk7XG4gICAgfVxuICB9LCBwcm9wcy5hdHRycywgcHJvcHMudHJpZ2dlci5wcm9wcywge1xuICAgIHJlZjogYXBwbHlSZWYuYXBwbHlSZWZzKHByb3BzLmF0dHJzLnJlZiwgcHJvcHMudHJpZ2dlci5yZWYpXG4gIH0pLCBhbGlnbm1lbnRJY29uc1tzZWxlY3RlZF0sIGRvd25JY29uJDEpLCBbaXNEaXNhYmxlZCwgc2VsZWN0ZWQsIHByb3BzXSk7XG59XG5cbmNvbnN0IGRvd25JY29uJDEgPSBjb3JlLmpzeChDaGV2cm9uRG93bkljb24uQ2hldnJvbkRvd25JY29uLCB7XG4gIHNpemU6IFwic21hbGxcIlxufSk7XG5cbmNvbnN0IG1pbnVzSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChNaW51c0ljb24uTWludXNJY29uLCB7XG4gIHNpemU6IFwic21hbGxcIlxufSk7XG5mdW5jdGlvbiBpbnNlcnREaXZpZGVyKGVkaXRvcikge1xuICBpbnNlcnROb2Rlc0J1dFJlcGxhY2VJZlNlbGVjdGlvbklzQXRFbXB0eVBhcmFncmFwaE9ySGVhZGluZyhlZGl0b3IsIHtcbiAgICB0eXBlOiAnZGl2aWRlcicsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH1dXG4gIH0pO1xuICBzbGF0ZS5FZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIHtcbiAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIHRleHQ6ICcnXG4gICAgfV1cbiAgfSk7XG59XG5cbmNvbnN0IERpdmlkZXJCdXR0b24gPSAoe1xuICBhdHRyc1xufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLFxuICAgIGRpdmlkZXJzOiB7XG4gICAgICBpc0Rpc2FibGVkXG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaW5zZXJ0RGl2aWRlcihlZGl0b3IpO1xuICAgIH1cbiAgfSwgYXR0cnMpLCBtaW51c0ljb24pLCBbZWRpdG9yLCBpc0Rpc2FibGVkLCBhdHRyc10pO1xufTtcblxuY29uc3QgZGl2aWRlckJ1dHRvbiA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgY29udGVudDogLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIkRpdmlkZXJcIiwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHRvb2xiYXIuS2V5Ym9hcmRJblRvb2x0aXAsIG51bGwsIFwiLS0tXCIpKSxcbiAgd2VpZ2h0OiBcInN1YnRsZVwiXG59LCBhdHRycyA9PiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRGl2aWRlckJ1dHRvbiwge1xuICBhdHRyczogYXR0cnNcbn0pKTtcbmZ1bmN0aW9uIHdpdGhEaXZpZGVyKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaXNWb2lkXG4gIH0gPSBlZGl0b3I7XG5cbiAgZWRpdG9yLmlzVm9pZCA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXZpZGVyJyB8fCBpc1ZvaWQobm9kZSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1widHlwZVwiXSxcbiAgICAgIF9leGNsdWRlZDIgPSBbXCJyZWZcIl07XG5mdW5jdGlvbiBUb29sYmFyKHtcbiAgZG9jdW1lbnRGZWF0dXJlcyxcbiAgdmlld1N0YXRlXG59KSB7XG4gIGNvbnN0IHJlbGF0aW9uc2hpcCA9IFJlYWN0LnVzZUNvbnRleHQoRG9jdW1lbnRGaWVsZFJlbGF0aW9uc2hpcHNDb250ZXh0KTtcbiAgY29uc3QgYmxvY2tDb21wb25lbnQgPSBSZWFjdC51c2VDb250ZXh0KENvbXBvbmVudEJsb2NrQ29udGV4dCk7XG4gIGNvbnN0IGhhc0Jsb2NrSXRlbXMgPSBPYmplY3QuZW50cmllcyhyZWxhdGlvbnNoaXApLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhibG9ja0NvbXBvbmVudCkubGVuZ3RoO1xuICByZXR1cm4gY29yZS5qc3goVG9vbGJhckNvbnRhaW5lciwgbnVsbCwgISFkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ0xldmVscy5sZW5ndGggJiYgY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvcmUuanN4KEhlYWRpbmdNZW51LCB7XG4gICAgaGVhZGluZ0xldmVsczogZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdMZXZlbHNcbiAgfSksIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhclNlcGFyYXRvciwgbnVsbCkpLCBPYmplY3QudmFsdWVzKGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5pbmxpbmVNYXJrcykuc29tZSh4ID0+IHgpICYmIGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeChJbmxpbmVNYXJrcywge1xuICAgIG1hcmtzOiBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3NcbiAgfSksIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhclNlcGFyYXRvciwgbnVsbCkpLCAoZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmFsaWdubWVudC5jZW50ZXIgfHwgZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmFsaWdubWVudC5lbmQpICYmIGNvcmUuanN4KFRleHRBbGlnbk1lbnUsIHtcbiAgICBhbGlnbm1lbnQ6IGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5hbGlnbm1lbnRcbiAgfSksIGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5saXN0VHlwZXMudW5vcmRlcmVkICYmIGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgIGNvbnRlbnQ6IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIkJ1bGxldCBMaXN0IFwiLCBjb3JlLmpzeCh0b29sYmFyLktleWJvYXJkSW5Ub29sdGlwLCBudWxsLCBcIi0gXCIpKSxcbiAgICB3ZWlnaHQ6IFwic3VidGxlXCJcbiAgfSwgYXR0cnMgPT4gY29yZS5qc3goTGlzdEJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IFwidW5vcmRlcmVkLWxpc3RcIlxuICB9LCBhdHRycyksIGNvcmUuanN4KEJ1bGxldExpc3RJY29uLCBudWxsKSkpLCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLm9yZGVyZWQgJiYgY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gICAgY29udGVudDogY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIFwiTnVtYmVyZWQgTGlzdCBcIiwgY29yZS5qc3godG9vbGJhci5LZXlib2FyZEluVG9vbHRpcCwgbnVsbCwgXCIxLiBcIikpLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBhdHRycyA9PiBjb3JlLmpzeChMaXN0QnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogXCJvcmRlcmVkLWxpc3RcIlxuICB9LCBhdHRycyksIGNvcmUuanN4KE51bWJlcmVkTGlzdEljb24sIG51bGwpKSksIChkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYWxpZ25tZW50LmNlbnRlciB8fCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYWxpZ25tZW50LmVuZCB8fCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLnVub3JkZXJlZCB8fCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLm9yZGVyZWQpICYmIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhclNlcGFyYXRvciwgbnVsbCksIGRvY3VtZW50RmVhdHVyZXMuZGl2aWRlcnMgJiYgZGl2aWRlckJ1dHRvbiwgZG9jdW1lbnRGZWF0dXJlcy5saW5rcyAmJiBsaW5rQnV0dG9uLCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYmxvY2tUeXBlcy5ibG9ja3F1b3RlICYmIGJsb2NrcXVvdGVCdXR0b24sICEhZG9jdW1lbnRGZWF0dXJlcy5sYXlvdXRzLmxlbmd0aCAmJiBjb3JlLmpzeChMYXlvdXRzQnV0dG9uLCB7XG4gICAgbGF5b3V0czogZG9jdW1lbnRGZWF0dXJlcy5sYXlvdXRzXG4gIH0pLCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlICYmIGNvZGVCdXR0b24sICEhaGFzQmxvY2tJdGVtcyAmJiBjb3JlLmpzeChJbnNlcnRCbG9ja01lbnUsIG51bGwpLCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJTZXBhcmF0b3IsIG51bGwpLCBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBFeHBhbmRJY29uID0gdmlld1N0YXRlICE9PSBudWxsICYmIHZpZXdTdGF0ZSAhPT0gdm9pZCAwICYmIHZpZXdTdGF0ZS5leHBhbmRlZCA/IE1pbmltaXplMkljb24uTWluaW1pemUySWNvbiA6IE1heGltaXplMkljb24uTWF4aW1pemUySWNvbjtcbiAgICByZXR1cm4gdmlld1N0YXRlICYmIGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgICAgY29udGVudDogdmlld1N0YXRlLmV4cGFuZGVkID8gJ0NvbGxhcHNlJyA6ICdFeHBhbmQnLFxuICAgICAgd2VpZ2h0OiBcInN1YnRsZVwiXG4gICAgfSwgYXR0cnMgPT4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2aWV3U3RhdGUudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfSwgYXR0cnMpLCBjb3JlLmpzeChFeHBhbmRJY29uLCB7XG4gICAgICBzaXplOiBcInNtYWxsXCJcbiAgICB9KSkpO1xuICB9LCBbdmlld1N0YXRlXSkpO1xufVxuLyogVUkgQ29tcG9uZW50cyAqL1xuXG5jb25zdCBNYXJrQnV0dG9uID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTWFya0J1dHRvbihwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsXG4gICAgbWFya3M6IHtcbiAgICAgIFtwcm9wcy50eXBlXToge1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBpc1NlbGVjdGVkXG4gICAgICB9XG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgICByZXR1cm4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNsYXRlLkVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgcHJvcHMudHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xhdGUuRWRpdG9yLmFkZE1hcmsoZWRpdG9yLCBwcm9wcy50eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHJlc3RQcm9wcykpO1xuICB9LCBbZWRpdG9yLCBpc0Rpc2FibGVkLCBpc1NlbGVjdGVkLCBwcm9wcywgcmVmXSk7XG59KTtcblxuY29uc3QgVG9vbGJhckNvbnRhaW5lciA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZ1xuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuYmFja2dyb3VuZCxcbiAgICAgIGJveFNoYWRvdzogYDAgMXB4ICR7Y29sb3JzLmJvcmRlcn0sIDAgLTFweCAke2NvbG9ycy5ib3JkZXJ9YCxcbiAgICAgIHBhZGRpbmdCb3R0b206IHNwYWNpbmcuc21hbGwsXG4gICAgICBwYWRkaW5nVG9wOiBzcGFjaW5nLnNtYWxsLFxuICAgICAgcG9zaXRpb246ICdzdGlja3knLFxuICAgICAgdG9wOiAwLFxuICAgICAgekluZGV4OiAyXG4gICAgfVxuICB9LCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJHcm91cCwgbnVsbCwgY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IGRvd25JY29uID0gY29yZS5qc3goQ2hldnJvbkRvd25JY29uLkNoZXZyb25Eb3duSWNvbiwge1xuICBzaXplOiBcInNtYWxsXCJcbn0pO1xuXG5mdW5jdGlvbiBIZWFkaW5nQnV0dG9uKHtcbiAgdHJpZ2dlcixcbiAgb25Ub2dnbGVTaG93TWVudSxcbiAgc2hvd01lbnVcbn0pIHtcbiAgY29uc3Qge1xuICAgIHRleHRTdHlsZXNcbiAgfSA9IHVzZVRvb2xiYXJTdGF0ZSgpO1xuICBsZXQgYnV0dG9uTGFiZWwgPSB0ZXh0U3R5bGVzLnNlbGVjdGVkID09PSAnbm9ybWFsJyA/ICdOb3JtYWwgdGV4dCcgOiAnSGVhZGluZyAnICsgdGV4dFN0eWxlcy5zZWxlY3RlZDtcbiAgY29uc3QgaXNEaXNhYmxlZCA9IHRleHRTdHlsZXMuYWxsb3dlZEhlYWRpbmdMZXZlbHMubGVuZ3RoID09PSAwO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICByZWY6IHRyaWdnZXIucmVmLFxuICAgIGlzUHJlc3NlZDogc2hvd01lbnUsXG4gICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uVG9nZ2xlU2hvd01lbnUoKTtcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIHdpZHRoOiAxMTZcbiAgICB9XG4gIH0sIHRyaWdnZXIucHJvcHMpLCBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge1xuICAgICAgZmxleDogMVxuICAgIH1cbiAgfSwgYnV0dG9uTGFiZWwpLCBkb3duSWNvbiksIFtidXR0b25MYWJlbCwgdHJpZ2dlciwgc2hvd01lbnUsIG9uVG9nZ2xlU2hvd01lbnUsIGlzRGlzYWJsZWRdKTtcbn1cblxuY29uc3QgSGVhZGluZ01lbnUgPSAoe1xuICBoZWFkaW5nTGV2ZWxzXG59KSA9PiB7XG4gIGNvbnN0IFtzaG93TWVudSwgc2V0U2hvd01lbnVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZGlhbG9nLFxuICAgIHRyaWdnZXJcbiAgfSA9IHBvcG92ZXIudXNlQ29udHJvbGxlZFBvcG92ZXIoe1xuICAgIGlzT3Blbjogc2hvd01lbnUsXG4gICAgb25DbG9zZTogKCkgPT4gc2V0U2hvd01lbnUoZmFsc2UpXG4gIH0sIHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgIG1vZGlmaWVyczogW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IFswLCA4XVxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSwgY29yZS5qc3goSGVhZGluZ0J1dHRvbiwge1xuICAgIHNob3dNZW51OiBzaG93TWVudSxcbiAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgIG9uVG9nZ2xlU2hvd01lbnU6ICgpID0+IHtcbiAgICAgIHNldFNob3dNZW51KHggPT4gIXgpO1xuICAgIH1cbiAgfSksIHNob3dNZW51ID8gY29yZS5qc3godG9vbGJhci5JbmxpbmVEaWFsb2csIF9leHRlbmRzKHtcbiAgICByZWY6IGRpYWxvZy5yZWZcbiAgfSwgZGlhbG9nLnByb3BzKSwgY29yZS5qc3goSGVhZGluZ0RpYWxvZywge1xuICAgIGhlYWRpbmdMZXZlbHM6IGhlYWRpbmdMZXZlbHMsXG4gICAgb25DbG9zZU1lbnU6ICgpID0+IHtcbiAgICAgIHNldFNob3dNZW51KGZhbHNlKTtcbiAgICB9XG4gIH0pKSA6IG51bGwpO1xufTtcblxuZnVuY3Rpb24gSGVhZGluZ0RpYWxvZyh7XG4gIGhlYWRpbmdMZXZlbHMsXG4gIG9uQ2xvc2VNZW51XG59KSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsXG4gICAgdGV4dFN0eWxlc1xuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJHcm91cCwge1xuICAgIGRpcmVjdGlvbjogXCJjb2x1bW5cIlxuICB9LCBoZWFkaW5nTGV2ZWxzLm1hcChoTnVtID0+IHtcbiAgICBsZXQgVGFnID0gYGgke2hOdW19YDtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGV4dFN0eWxlcy5zZWxlY3RlZCA9PT0gaE51bTtcbiAgICByZXR1cm4gY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCB7XG4gICAgICBrZXk6IGhOdW0sXG4gICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogbiA9PiBuLnR5cGUgPT09ICdoZWFkaW5nJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICBsZXZlbDogaE51bVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbm9kZS50eXBlID09PSAnaGVhZGluZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uQ2xvc2VNZW51KCk7XG4gICAgICB9XG4gICAgfSwgY29yZS5qc3goVGFnLCBudWxsLCBcIkhlYWRpbmcgXCIsIGhOdW0pKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBJbnNlcnRCbG9ja01lbnUoKSB7XG4gIGNvbnN0IFtzaG93TWVudSwgc2V0U2hvd01lbnVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZGlhbG9nLFxuICAgIHRyaWdnZXJcbiAgfSA9IHBvcG92ZXIudXNlQ29udHJvbGxlZFBvcG92ZXIoe1xuICAgIGlzT3Blbjogc2hvd01lbnUsXG4gICAgb25DbG9zZTogKCkgPT4gc2V0U2hvd01lbnUoZmFsc2UpXG4gIH0sIHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgIG1vZGlmaWVyczogW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IFswLCA4XVxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSwgY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gICAgY29udGVudDogY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIFwiSW5zZXJ0IFwiLCBjb3JlLmpzeCh0b29sYmFyLktleWJvYXJkSW5Ub29sdGlwLCBudWxsLCBcIi9cIikpLFxuICAgIHdlaWdodDogXCJzdWJ0bGVcIlxuICB9LCBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgcmVmXG4gICAgfSA9IF9yZWYsXG4gICAgICAgIGF0dHJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZDIpO1xuXG4gICAgcmV0dXJuIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBhcHBseVJlZi5hcHBseVJlZnMocmVmLCB0cmlnZ2VyLnJlZiksXG4gICAgICBpc1ByZXNzZWQ6IHNob3dNZW51LFxuICAgICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0U2hvd01lbnUodiA9PiAhdik7XG4gICAgICB9XG4gICAgfSwgdHJpZ2dlci5wcm9wcywgYXR0cnMpLCBjb3JlLmpzeChQbHVzSWNvbi5QbHVzSWNvbiwge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDNcbiAgICAgIH1cbiAgICB9KSwgY29yZS5qc3goQ2hldnJvbkRvd25JY29uLkNoZXZyb25Eb3duSWNvbiwge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgfSkpO1xuICB9KSwgc2hvd01lbnUgPyBjb3JlLmpzeCh0b29sYmFyLklubGluZURpYWxvZywgX2V4dGVuZHMoe1xuICAgIHJlZjogZGlhbG9nLnJlZlxuICB9LCBkaWFsb2cucHJvcHMpLCBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJHcm91cCwge1xuICAgIGRpcmVjdGlvbjogXCJjb2x1bW5cIlxuICB9LCBjb3JlLmpzeChSZWxhdGlvbnNoaXBCdXR0b24sIHtcbiAgICBvbkNsb3NlOiAoKSA9PiBzZXRTaG93TWVudShmYWxzZSlcbiAgfSksIGNvcmUuanN4KEJsb2NrQ29tcG9uZW50c0J1dHRvbnMsIHtcbiAgICBvbkNsb3NlOiAoKSA9PiBzZXRTaG93TWVudShmYWxzZSlcbiAgfSkpKSA6IG51bGwpO1xufVxuXG5mdW5jdGlvbiBJbmxpbmVNYXJrcyh7XG4gIG1hcmtzXG59KSB7XG4gIGNvbnN0IFtzaG93TWVudSwgc2V0U2hvd01lbnVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZGlhbG9nLFxuICAgIHRyaWdnZXJcbiAgfSA9IHBvcG92ZXIudXNlQ29udHJvbGxlZFBvcG92ZXIoe1xuICAgIGlzT3Blbjogc2hvd01lbnUsXG4gICAgb25DbG9zZTogKCkgPT4gc2V0U2hvd01lbnUoZmFsc2UpXG4gIH0sIHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgIG1vZGlmaWVyczogW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IFswLCA4XVxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICByZXR1cm4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIG1hcmtzLmJvbGQgJiYgY29yZS5qc3godG9vbHRpcC5Ub29sdGlwLCB7XG4gICAgY29udGVudDogY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIG51bGwsIFwiQm9sZFwiLCBjb3JlLmpzeCh0b29sYmFyLktleWJvYXJkSW5Ub29sdGlwLCBudWxsLCBtb2RpZmllcktleVRleHQsIFwiQlwiKSksXG4gICAgd2VpZ2h0OiBcInN1YnRsZVwiXG4gIH0sIGF0dHJzID0+IGNvcmUuanN4KE1hcmtCdXR0b24sIF9leHRlbmRzKHtcbiAgICB0eXBlOiBcImJvbGRcIlxuICB9LCBhdHRycyksIGNvcmUuanN4KEJvbGRJY29uLkJvbGRJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBzdHJva2VXaWR0aDogM1xuICAgIH1cbiAgfSkpKSwgbWFya3MuaXRhbGljICYmIGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgIGNvbnRlbnQ6IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIkl0YWxpY1wiLCBjb3JlLmpzeCh0b29sYmFyLktleWJvYXJkSW5Ub29sdGlwLCBudWxsLCBtb2RpZmllcktleVRleHQsIFwiSVwiKSksXG4gICAgd2VpZ2h0OiBcInN1YnRsZVwiXG4gIH0sIGF0dHJzID0+IGNvcmUuanN4KE1hcmtCdXR0b24sIF9leHRlbmRzKHtcbiAgICB0eXBlOiBcIml0YWxpY1wiXG4gIH0sIGF0dHJzKSwgY29yZS5qc3goSXRhbGljSWNvbi5JdGFsaWNJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pKSksIGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgIGNvbnRlbnQ6IFwiTW9yZSBmb3JtYXR0aW5nXCIsXG4gICAgd2VpZ2h0OiBcInN1YnRsZVwiXG4gIH0sIGF0dHJzID0+IGNvcmUuanN4KE1vcmVGb3JtYXR0aW5nQnV0dG9uLCB7XG4gICAgaXNPcGVuOiBzaG93TWVudSxcbiAgICBvblRvZ2dsZTogKCkgPT4ge1xuICAgICAgc2V0U2hvd01lbnUodiA9PiAhdik7XG4gICAgfSxcbiAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgIGF0dHJzOiBhdHRyc1xuICB9KSksIHNob3dNZW51ICYmIGNvcmUuanN4KE1vcmVGb3JtYXR0aW5nRGlhbG9nLCB7XG4gICAgb25DbG9zZU1lbnU6ICgpID0+IHtcbiAgICAgIHNldFNob3dNZW51KGZhbHNlKTtcbiAgICB9LFxuICAgIGRpYWxvZzogZGlhbG9nLFxuICAgIG1hcmtzOiBtYXJrc1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIE1vcmVGb3JtYXR0aW5nRGlhbG9nKHtcbiAgZGlhbG9nLFxuICBtYXJrcyxcbiAgb25DbG9zZU1lbnVcbn0pIHtcbiAgLy8gbm90IGRvaW5nIG9wdGltaXNhdGlvbnMgaW4gaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBvbmx5IHJlbmRlciB3aGVuIGl0J3Mgb3BlblxuICAvLyB3aGljaCB3aWxsIGJlIHJhcmUgYW5kIHlvdSB3b24ndCBiZSB0eXBpbmcgd2hpbGUgaXQncyBvcGVuXG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsXG4gICAgY2xlYXJGb3JtYXR0aW5nOiB7XG4gICAgICBpc0Rpc2FibGVkXG4gICAgfVxuICB9ID0gdXNlVG9vbGJhclN0YXRlKCk7XG4gIHJldHVybiBjb3JlLmpzeCh0b29sYmFyLklubGluZURpYWxvZywgX2V4dGVuZHMoe1xuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSAnQlVUVE9OJykge1xuICAgICAgICBvbkNsb3NlTWVudSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVmOiBkaWFsb2cucmVmXG4gIH0sIGRpYWxvZy5wcm9wcyksIGNvcmUuanN4KHRvb2xiYXIuVG9vbGJhckdyb3VwLCB7XG4gICAgZGlyZWN0aW9uOiBcImNvbHVtblwiXG4gIH0sIG1hcmtzLnVuZGVybGluZSAmJiBjb3JlLmpzeChNYXJrQnV0dG9uLCB7XG4gICAgdHlwZTogXCJ1bmRlcmxpbmVcIlxuICB9LCBjb3JlLmpzeChDb250ZW50SW5CdXR0b25XaXRoU2hvcnRjdXQsIHtcbiAgICBjb250ZW50OiBcIlVuZGVybGluZVwiLFxuICAgIHNob3J0Y3V0OiBgJHttb2RpZmllcktleVRleHR9VWBcbiAgfSkpLCBtYXJrcy5zdHJpa2V0aHJvdWdoICYmIGNvcmUuanN4KE1hcmtCdXR0b24sIHtcbiAgICB0eXBlOiBcInN0cmlrZXRocm91Z2hcIlxuICB9LCBcIlN0cmlrZXRocm91Z2hcIiksIG1hcmtzLmNvZGUgJiYgY29yZS5qc3goTWFya0J1dHRvbiwge1xuICAgIHR5cGU6IFwiY29kZVwiXG4gIH0sIFwiQ29kZVwiKSwgbWFya3Mua2V5Ym9hcmQgJiYgY29yZS5qc3goTWFya0J1dHRvbiwge1xuICAgIHR5cGU6IFwia2V5Ym9hcmRcIlxuICB9LCBcIktleWJvYXJkXCIpLCBtYXJrcy5zdWJzY3JpcHQgJiYgY29yZS5qc3goTWFya0J1dHRvbiwge1xuICAgIHR5cGU6IFwic3Vic2NyaXB0XCJcbiAgfSwgXCJTdWJzY3JpcHRcIiksIG1hcmtzLnN1cGVyc2NyaXB0ICYmIGNvcmUuanN4KE1hcmtCdXR0b24sIHtcbiAgICB0eXBlOiBcInN1cGVyc2NyaXB0XCJcbiAgfSwgXCJTdXBlcnNjcmlwdFwiKSwgY29yZS5qc3godG9vbGJhci5Ub29sYmFyQnV0dG9uLCB7XG4gICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsZWFyRm9ybWF0dGluZyhlZGl0b3IpO1xuICAgIH1cbiAgfSwgY29yZS5qc3goQ29udGVudEluQnV0dG9uV2l0aFNob3J0Y3V0LCB7XG4gICAgY29udGVudDogXCJDbGVhciBGb3JtYXR0aW5nXCIsXG4gICAgc2hvcnRjdXQ6IGAke21vZGlmaWVyS2V5VGV4dH1cXFxcYFxuICB9KSkpKTtcbn1cblxuZnVuY3Rpb24gQ29udGVudEluQnV0dG9uV2l0aFNob3J0Y3V0KHtcbiAgY29udGVudCxcbiAgc2hvcnRjdXRcbn0pIHtcbiAgY29uc3QgdGhlbWUgPSBjb3JlLnVzZVRoZW1lKCk7XG4gIHJldHVybiBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH1cbiAgfSwgY29yZS5qc3goXCJzcGFuXCIsIG51bGwsIGNvbnRlbnQpLCBjb3JlLmpzeChcImtiZFwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgICBtYXJnaW5MZWZ0OiB0aGVtZS5zcGFjaW5nLnNtYWxsLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZy54eHNtYWxsLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcueHNtYWxsLFxuICAgICAgcGFkZGluZ1JpZ2h0OiB0aGVtZS5zcGFjaW5nLnhzbWFsbCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsNDAwLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5yYWRpaS54c21hbGwsXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLmZvcmVncm91bmREaW0sXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlJ1xuICAgIH1cbiAgfSwgc2hvcnRjdXQpKTtcbn1cblxuZnVuY3Rpb24gTW9yZUZvcm1hdHRpbmdCdXR0b24oe1xuICBvblRvZ2dsZSxcbiAgaXNPcGVuLFxuICB0cmlnZ2VyLFxuICBhdHRyc1xufSkge1xuICBjb25zdCB7XG4gICAgbWFya3NcbiAgfSA9IHVzZVRvb2xiYXJTdGF0ZSgpO1xuICBjb25zdCBpc0FjdGl2ZSA9IG1hcmtzLnN0cmlrZXRocm91Z2guaXNTZWxlY3RlZCB8fCBtYXJrcy51bmRlcmxpbmUuaXNTZWxlY3RlZCB8fCBtYXJrcy5jb2RlLmlzU2VsZWN0ZWQgfHwgbWFya3Mua2V5Ym9hcmQuaXNTZWxlY3RlZCB8fCBtYXJrcy5zdWJzY3JpcHQuaXNTZWxlY3RlZCB8fCBtYXJrcy5zdXBlcnNjcmlwdC5pc1NlbGVjdGVkO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIF9leHRlbmRzKHtcbiAgICBpc1ByZXNzZWQ6IGlzT3BlbixcbiAgICBpc1NlbGVjdGVkOiBpc0FjdGl2ZSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uVG9nZ2xlKCk7XG4gICAgfVxuICB9LCB0cmlnZ2VyLnByb3BzLCBhdHRycywge1xuICAgIHJlZjogYXBwbHlSZWYuYXBwbHlSZWZzKGF0dHJzLnJlZiwgdHJpZ2dlci5yZWYpXG4gIH0pLCBjb3JlLmpzeChNb3JlSG9yaXpvbnRhbEljb24uTW9yZUhvcml6b250YWxJY29uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0pKSwgW2lzQWN0aXZlLCBvblRvZ2dsZSwgaXNPcGVuLCB0cmlnZ2VyLCBhdHRyc10pO1xufSAvLyBDdXN0b20gKG5vbi1mZWF0aGVyKSBJY29uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuY29uc3QgSWNvbkJhc2UgPSBwcm9wcyA9PiBjb3JlLmpzeChcInN2Z1wiLCBfZXh0ZW5kcyh7XG4gIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICBoZWlnaHQ6IFwiMTZcIixcbiAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgdmlld0JveDogXCIwIDAgMTYgMTZcIixcbiAgd2lkdGg6IFwiMTZcIlxufSwgcHJvcHMpKTtcblxuY29uc3QgQnVsbGV0TGlzdEljb24gPSAoKSA9PiBjb3JlLmpzeChJY29uQmFzZSwgbnVsbCwgY29yZS5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMiA0YTEgMSAwIDEwMC0yIDEgMSAwIDAwMCAyem0zLjc1LTEuNWEuNzUuNzUgMCAwMDAgMS41aDguNWEuNzUuNzUgMCAwMDAtMS41aC04LjV6bTAgNWEuNzUuNzUgMCAwMDAgMS41aDguNWEuNzUuNzUgMCAwMDAtMS41aC04LjV6bTAgNWEuNzUuNzUgMCAwMDAgMS41aDguNWEuNzUuNzUgMCAwMDAtMS41aC04LjV6TTMgOGExIDEgMCAxMS0yIDAgMSAxIDAgMDEyIDB6bS0xIDZhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6XCJcbn0pKTtcblxuY29uc3QgTnVtYmVyZWRMaXN0SWNvbiA9ICgpID0+IGNvcmUuanN4KEljb25CYXNlLCBudWxsLCBjb3JlLmpzeChcInBhdGhcIiwge1xuICBkOiBcIk0yLjAwMyAyLjVhLjUuNSAwIDAwLS43MjMtLjQ0N2wtMS4wMDMuNWEuNS41IDAgMDAuNDQ2Ljg5NWwuMjgtLjE0VjZILjVhLjUuNSAwIDAwMCAxaDIuMDA2YS41LjUgMCAxMDAtMWgtLjUwM1YyLjV6TTUgMy4yNWEuNzUuNzUgMCAwMS43NS0uNzVoOC41YS43NS43NSAwIDAxMCAxLjVoLTguNUEuNzUuNzUgMCAwMTUgMy4yNXptMCA1YS43NS43NSAwIDAxLjc1LS43NWg4LjVhLjc1Ljc1IDAgMDEwIDEuNWgtOC41QS43NS43NSAwIDAxNSA4LjI1em0wIDVhLjc1Ljc1IDAgMDEuNzUtLjc1aDguNWEuNzUuNzUgMCAwMTAgMS41aC04LjVhLjc1Ljc1IDAgMDEtLjc1LS43NXpNLjkyNCAxMC4zMmwuMDAzLS4wMDRhLjg1MS44NTEgMCAwMS4xNDQtLjE1M0EuNjYuNjYgMCAwMTEuNSAxMGMuMTk1IDAgLjMwNi4wNjguMzc0LjE0NmEuNTcuNTcgMCAwMS4xMjguMzc2YzAgLjQ1My0uMjY5LjY4Mi0uOCAxLjA3OGwtLjAzNS4wMjVDLjY5MiAxMS45OCAwIDEyLjQ5NSAwIDEzLjVhLjUuNSAwIDAwLjUuNWgyLjAwM2EuNS41IDAgMDAwLTFIMS4xNDZjLjEzMi0uMTk3LjM1MS0uMzcyLjY1NC0uNTk3bC4wNDctLjAzNWMuNDctLjM1IDEuMTU2LS44NTggMS4xNTYtMS44NDUgMC0uMzY1LS4xMTgtLjc0NC0uMzc3LTEuMDM4LS4yNjgtLjMwMy0uNjU4LS40ODQtMS4xMjYtLjQ4NC0uNDggMC0uODQuMjAyLTEuMDY4LjM5MmExLjg1OCAxLjg1OCAwIDAwLS4zNDguMzg0bC0uMDA3LjAxMS0uMDAyLjAwNC0uMDAxLjAwMi0uMDAxLjAwMWEuNS41IDAgMDAuODUxLjUyNXpNLjUgMTAuMDU1bC0uNDI3LS4yNi40MjcuMjZ6XCJcbn0pKTtcblxuY29uc3QgaGVhZGluZ1N0eWxlc01hcCA9IHtcbiAgaDE6IHtcbiAgICBmb250U2l6ZTogJzIuMnJlbSdcbiAgfSxcbiAgaDI6IHtcbiAgICBmb250U2l6ZTogJzEuOHJlbSdcbiAgfSxcbiAgaDM6IHtcbiAgICBmb250U2l6ZTogJzEuNXJlbSdcbiAgfSxcbiAgaDQ6IHtcbiAgICBmb250U2l6ZTogJzEuMnJlbSdcbiAgfSxcbiAgaDU6IHtcbiAgICBmb250U2l6ZTogJzAuODNyZW0nXG4gIH0sXG4gIGg2OiB7XG4gICAgZm9udFNpemU6ICcwLjY3cmVtJ1xuICB9XG59O1xuY29uc3QgSGVhZGluZ0VsZW1lbnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlbixcbiAgZWxlbWVudFxufSkgPT4ge1xuICBjb25zdCBUYWcgPSBgaCR7ZWxlbWVudC5sZXZlbH1gO1xuICBjb25zdCBoZWFkaW5nU3R5bGUgPSBoZWFkaW5nU3R5bGVzTWFwW1RhZ107XG4gIHJldHVybiBjb3JlLmpzeChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY3NzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGhlYWRpbmdTdHlsZSksIHt9LCB7XG4gICAgICB0ZXh0QWxpZ246IGVsZW1lbnQudGV4dEFsaWduXG4gICAgfSlcbiAgfSksIGNoaWxkcmVuKTtcbn07XG5mdW5jdGlvbiB3aXRoSGVhZGluZyhlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGluc2VydEJyZWFrXG4gIH0gPSBlZGl0b3I7XG5cbiAgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgIGluc2VydEJyZWFrKCk7XG4gICAgY29uc3QgZW50cnkgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBuLnR5cGUgPT09ICdoZWFkaW5nJ1xuICAgIH0pO1xuICAgIGlmICghZW50cnkgfHwgIWVkaXRvci5zZWxlY3Rpb24gfHwgIXNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgcGF0aCA9IGVudHJ5WzFdO1xuXG4gICAgaWYgKCAvLyB3ZSB3YW50IHRvIHVud3JhcCB0aGUgaGVhZGluZyB3aGVuIHRoZSB1c2VyIGluc2VydGVkIGEgYnJlYWsgYXQgdGhlIGVuZCBvZiB0aGUgaGVhZGluZ1xuICAgIC8vIHdoZW4gdGhlIHVzZXIgaW5zZXJ0cyBhIGJyZWFrIGF0IHRoZSBlbmQgb2YgYSBoZWFkaW5nLCB0aGUgbmV3IGhlYWRpbmdcbiAgICAvLyB0aGF0IHdlIHdhbnQgdG8gdW53cmFwIHdpbGwgYmUgZW1wdHkgc28gdGhlIGVuZCB3aWxsIGJlIGVxdWFsIHRvIHRoZSBzZWxlY3Rpb25cbiAgICBzbGF0ZS5Qb2ludC5lcXVhbHMoc2xhdGUuRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcikpIHtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHdlIGFsc28gd2FudCB0byB1bndyYXAgdGhlIF9wcmV2aW91c18gaGVhZGluZyB3aGVuIHRoZSB1c2VyIGluc2VydGVkIGEgYnJlYWtcbiAgICAvLyBhdCB0aGUgc3RhcnQgb2YgdGhlIGhlYWRpbmcsIGVzc2VudGlhbGx5IGp1c3QgaW5zZXJ0aW5nIGFuIGVtcHR5IHBhcmFncmFwaCBhYm92ZSB0aGUgaGVhZGluZ1xuXG5cbiAgICBpZiAoIXNsYXRlLlBhdGguaGFzUHJldmlvdXMocGF0aCkpIHJldHVybjtcbiAgICBjb25zdCBwcmV2aW91c1BhdGggPSBzbGF0ZS5QYXRoLnByZXZpb3VzKHBhdGgpO1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHNsYXRlLk5vZGUuZ2V0KGVkaXRvciwgcHJldmlvdXNQYXRoKTtcblxuICAgIGlmIChwcmV2aW91c05vZGUudHlwZSA9PT0gJ2hlYWRpbmcnICYmIHByZXZpb3VzTm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgc2xhdGUuVGV4dC5pc1RleHQocHJldmlvdXNOb2RlLmNoaWxkcmVuWzBdKSAmJiBwcmV2aW91c05vZGUuY2hpbGRyZW5bMF0udGV4dCA9PT0gJycpIHtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwcmV2aW91c1BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZWRpdG9yO1xufVxuXG4vLyBhbmQgVFMgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSB0eXBlIG5hcnJvd2luZyB3aGVuIGRvaW5nIGEgc3ByZWFkIGZvciBzb21lIHJlYXNvblxuLy8gc28gdGhhdCdzIHdoeSB0aGluZ3MgYXJlbid0IGJlaW5nIHNwcmVhZCBpbiBzb21lIGNhc2VzXG5cbmNvbnN0IHJlbmRlckVsZW1lbnQgPSBwcm9wcyA9PiB7XG4gIHN3aXRjaCAocHJvcHMuZWxlbWVudC50eXBlKSB7XG4gICAgY2FzZSAnbGF5b3V0JzpcbiAgICAgIHJldHVybiBjb3JlLmpzeChMYXlvdXRDb250YWluZXIsIHtcbiAgICAgICAgYXR0cmlidXRlczogcHJvcHMuYXR0cmlidXRlcyxcbiAgICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBlbGVtZW50OiBwcm9wcy5lbGVtZW50XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xheW91dC1hcmVhJzpcbiAgICAgIHJldHVybiBjb3JlLmpzeChMYXlvdXRBcmVhLCBwcm9wcyk7XG5cbiAgICBjYXNlICdjb2RlJzpcbiAgICAgIHJldHVybiBjb3JlLmpzeChDb2RlRWxlbWVudCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnY29tcG9uZW50LWJsb2NrJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGNvcmUuanN4KENvbXBvbmVudEJsb2Nrc0VsZW1lbnQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBwcm9wcy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICBlbGVtZW50OiBwcm9wcy5lbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29tcG9uZW50LWlubGluZS1wcm9wJzpcbiAgICBjYXNlICdjb21wb25lbnQtYmxvY2stcHJvcCc6XG4gICAgICByZXR1cm4gY29yZS5qc3goQ29tcG9uZW50SW5saW5lUHJvcCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICByZXR1cm4gY29yZS5qc3goSGVhZGluZ0VsZW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogcHJvcHMuYXR0cmlidXRlcyxcbiAgICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBlbGVtZW50OiBwcm9wcy5lbGVtZW50XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgcmV0dXJuIGNvcmUuanN4KExpbmtFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHByb3BzLmF0dHJpYnV0ZXMsXG4gICAgICAgIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZWxlbWVudDogcHJvcHMuZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdvcmRlcmVkLWxpc3QnOlxuICAgICAgcmV0dXJuIGNvcmUuanN4KFwib2xcIiwgcHJvcHMuYXR0cmlidXRlcywgcHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgY2FzZSAndW5vcmRlcmVkLWxpc3QnOlxuICAgICAgcmV0dXJuIGNvcmUuanN4KFwidWxcIiwgcHJvcHMuYXR0cmlidXRlcywgcHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgY2FzZSAnbGlzdC1pdGVtJzpcbiAgICAgIHJldHVybiBjb3JlLmpzeChcImxpXCIsIHByb3BzLmF0dHJpYnV0ZXMsIHByb3BzLmNoaWxkcmVuKTtcblxuICAgIGNhc2UgJ2xpc3QtaXRlbS1jb250ZW50JzpcbiAgICAgIHJldHVybiBjb3JlLmpzeChcInNwYW5cIiwgcHJvcHMuYXR0cmlidXRlcywgcHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICByZXR1cm4gY29yZS5qc3goQmxvY2txdW90ZUVsZW1lbnQsIHByb3BzKTtcblxuICAgIGNhc2UgJ3JlbGF0aW9uc2hpcCc6XG4gICAgICByZXR1cm4gY29yZS5qc3goUmVsYXRpb25zaGlwRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiBwcm9wcy5hdHRyaWJ1dGVzLFxuICAgICAgICBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGVsZW1lbnQ6IHByb3BzLmVsZW1lbnRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnZGl2aWRlcic6XG4gICAgICByZXR1cm4gY29yZS5qc3goRGl2aWRlckVsZW1lbnQsIHByb3BzKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29yZS5qc3goXCJwXCIsIF9leHRlbmRzKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdGV4dEFsaWduOiBwcm9wcy5lbGVtZW50LnRleHRBbGlnblxuICAgICAgICB9XG4gICAgICB9LCBwcm9wcy5hdHRyaWJ1dGVzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICB9XG59O1xuLyogQmxvY2sgRWxlbWVudHMgKi9cblxuY29uc3QgQ29kZUVsZW1lbnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY29sb3JzLFxuICAgIHJhZGlpLFxuICAgIHNwYWNpbmcsXG4gICAgdHlwb2dyYXBoeVxuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJwcmVcIiwgX2V4dGVuZHMoe1xuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIixcbiAgICBjc3M6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLmJhY2tncm91bmREaW0sXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHtjb2xvcnMuYm9yZGVyfWAsXG4gICAgICBib3JkZXJSYWRpdXM6IHJhZGlpLnhzbWFsbCxcbiAgICAgIGZvbnRGYW1pbHk6IHR5cG9ncmFwaHkuZm9udEZhbWlseS5tb25vc3BhY2UsXG4gICAgICBmb250U2l6ZTogdHlwb2dyYXBoeS5mb250U2l6ZS5zbWFsbCxcbiAgICAgIHBhZGRpbmc6IGAke3NwYWNpbmcuc21hbGx9cHggJHtzcGFjaW5nLm1lZGl1bX1weGBcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpLCBjb3JlLmpzeChcImNvZGVcIiwge1xuICAgIGNzczoge1xuICAgICAgZm9udEZhbWlseTogJ2luaGVyaXQnXG4gICAgfVxuICB9LCBjaGlsZHJlbikpO1xufTtcblxuY29uc3QgRGl2aWRlckVsZW1lbnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY29sb3JzLFxuICAgIHNwYWNpbmdcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBzbGF0ZVJlYWN0LnVzZVNlbGVjdGVkKCk7XG4gIHJldHVybiBjb3JlLmpzeChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNzczoge1xuICAgICAgcGFkZGluZ0JvdHRvbTogc3BhY2luZy5tZWRpdW0sXG4gICAgICBwYWRkaW5nVG9wOiBzcGFjaW5nLm1lZGl1bSxcbiAgICAgIG1hcmdpbkJvdHRvbTogc3BhY2luZy5tZWRpdW0sXG4gICAgICBtYXJnaW5Ub3A6IHNwYWNpbmcubWVkaXVtLFxuICAgICAgY2FyZXRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgIH1cbiAgfSksIGNvcmUuanN4KFwiaHJcIiwge1xuICAgIGNzczoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBzZWxlY3RlZCA/IGNvbG9ycy5saW5rQ29sb3IgOiBjb2xvcnMuYm9yZGVyLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgaGVpZ2h0OiAyXG4gICAgfVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuY29uc3QgYWxsTWFya2Rvd25TaG9ydGN1dHMgPSB7XG4gIGJvbGQ6IFsnKionLCAnX18nXSxcbiAgaXRhbGljOiBbJyonLCAnXyddLFxuICBzdHJpa2V0aHJvdWdoOiBbJ35+J10sXG4gIGNvZGU6IFsnYCddXG59O1xuXG5mdW5jdGlvbiBhcHBseU1hcmsoZWRpdG9yLCBtYXJrLCBzaG9ydGN1dFRleHQsIHN0YXJ0T2ZTdGFydFBvaW50KSB7XG4gIC8vIHNvIHRoYXQgdGhpcyBzdGFydHMgYSBuZXcgdW5kbyBncm91cFxuICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKFtdKTtcbiAgY29uc3Qgc3RhcnRQb2ludFJlZiA9IHNsYXRlLkVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0T2ZTdGFydFBvaW50KTtcbiAgc2xhdGUuVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLFxuICAgIGRpc3RhbmNlOiBzaG9ydGN1dFRleHQubGVuZ3RoLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSk7XG4gIHNsYXRlLlRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgIGF0OiBzdGFydE9mU3RhcnRQb2ludCxcbiAgICBkaXN0YW5jZTogc2hvcnRjdXRUZXh0Lmxlbmd0aFxuICB9KTtcbiAgc2xhdGUuVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICBbbWFya106IHRydWVcbiAgfSwge1xuICAgIG1hdGNoOiBzbGF0ZS5UZXh0LmlzVGV4dCxcbiAgICBzcGxpdDogdHJ1ZSxcbiAgICBhdDoge1xuICAgICAgYW5jaG9yOiBzdGFydFBvaW50UmVmLnVucmVmKCksXG4gICAgICBmb2N1czogZWRpdG9yLnNlbGVjdGlvbi5hbmNob3JcbiAgICB9XG4gIH0pOyAvLyBvbmNlIHlvdSd2ZSBlbmRlZCB0aGUgc2hvcnRjdXQsIHlvdSdyZSBkb25lIHdpdGggdGhlIG1hcmtcbiAgLy8gc28gd2UgbmVlZCB0byByZW1vdmUgaXQgc28gdGhlIHRleHQgeW91IGluc2VydCBhZnRlciBkb2Vzbid0IGhhdmUgaXRcblxuICBlZGl0b3IucmVtb3ZlTWFyayhtYXJrKTtcbn1cblxuZnVuY3Rpb24gd2l0aE1hcmtzKGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2NrcywgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnRUZXh0LFxuICAgIGluc2VydEJyZWFrXG4gIH0gPSBlZGl0b3I7XG5cbiAgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgIGluc2VydEJyZWFrKCk7XG4gICAgY29uc3QgbWFya3NBZnRlckluc2VydEJyZWFrID0gc2xhdGUuRWRpdG9yLm1hcmtzKGVkaXRvcik7XG4gICAgaWYgKCFtYXJrc0FmdGVySW5zZXJ0QnJlYWsgfHwgIWVkaXRvci5zZWxlY3Rpb24pIHJldHVybjtcbiAgICBjb25zdCBwYXJlbnRCbG9jayA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBub2RlID0+IHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSlcbiAgICB9KTtcbiAgICBpZiAoIXBhcmVudEJsb2NrKSByZXR1cm47XG4gICAgY29uc3QgcG9pbnQgPSBFZGl0b3JBZnRlckJ1dElnbm9yaW5naW5nUG9pbnRzV2l0aE5vQ29udGVudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICBjb25zdCBtYXJrc0FmdGVySW5zZXJ0QnJlYWtBcnIgPSBPYmplY3Qua2V5cyhtYXJrc0FmdGVySW5zZXJ0QnJlYWspO1xuXG4gICAgaWYgKCFwb2ludCB8fCAhc2xhdGUuUGF0aC5pc0Rlc2NlbmRhbnQocG9pbnQucGF0aCwgcGFyZW50QmxvY2tbMV0pKSB7XG4gICAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3NBZnRlckluc2VydEJyZWFrQXJyKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmVNYXJrKG1hcmspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dE5vZGUgPSBzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIHBvaW50LnBhdGgpO1xuXG4gICAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzQWZ0ZXJJbnNlcnRCcmVha0Fycikge1xuICAgICAgaWYgKCF0ZXh0Tm9kZVttYXJrXSkge1xuICAgICAgICBlZGl0b3IucmVtb3ZlTWFyayhtYXJrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2VsZWN0ZWRNYXJrZG93blNob3J0Y3V0cyA9IHt9O1xuICBjb25zdCBlbmFibGVkTWFya3MgPSBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3M7XG4gIE9iamVjdC5rZXlzKGFsbE1hcmtkb3duU2hvcnRjdXRzKS5mb3JFYWNoKG1hcmsgPT4ge1xuICAgIGlmIChlbmFibGVkTWFya3NbbWFya10pIHtcbiAgICAgIHNlbGVjdGVkTWFya2Rvd25TaG9ydGN1dHNbbWFya10gPSBhbGxNYXJrZG93blNob3J0Y3V0c1ttYXJrXTtcbiAgICB9XG4gIH0pO1xuICBpZiAoT2JqZWN0LmtleXMoc2VsZWN0ZWRNYXJrZG93blNob3J0Y3V0cykubGVuZ3RoID09PSAwKSByZXR1cm4gZWRpdG9yO1xuXG4gIGVkaXRvci5pbnNlcnRUZXh0ID0gdGV4dCA9PiB7XG4gICAgaW5zZXJ0VGV4dCh0ZXh0KTtcblxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IFttYXJrLCBzaG9ydGN1dHNdIG9mIE9iamVjdC5lbnRyaWVzKHNlbGVjdGVkTWFya2Rvd25TaG9ydGN1dHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2hvcnRjdXRUZXh0IG9mIHNob3J0Y3V0cykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSBzaG9ydGN1dFRleHRbc2hvcnRjdXRUZXh0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mQmxvY2sgPSBzbGF0ZS5FZGl0b3Iuc3RhcnQoZWRpdG9yLCBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiBub2RlID0+IHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSlcbiAgICAgICAgICAgIH0pWzFdKTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcgPSBzbGF0ZS5FZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgICBhbmNob3I6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgICAgICBmb2N1czogc3RhcnRPZkJsb2NrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1doaXRlc3BhY2VCZWZvcmVFbmRPZlNob3J0Y3V0ID0gL1xccy8udGVzdChzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcuc3Vic3RyKC1zaG9ydGN1dFRleHQubGVuZ3RoIC0gMSwgMSkpO1xuICAgICAgICAgICAgY29uc3QgZW5kT2ZTaG9ydGN1dENvbnRhaW5zRXhwZWN0ZWRDb250ZW50ID0gc2hvcnRjdXRUZXh0ID09PSBzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcuc2xpY2UoLXNob3J0Y3V0VGV4dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAoaGFzV2hpdGVzcGFjZUJlZm9yZUVuZE9mU2hvcnRjdXQgfHwgIWVuZE9mU2hvcnRjdXRDb250YWluc0V4cGVjdGVkQ29udGVudCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RyVG9NYXRjaE9uID0gc3RhcnRPZkJsb2NrVG9FbmRPZlNob3J0Y3V0U3RyaW5nLnNsaWNlKDAsIC1zaG9ydGN1dFRleHQubGVuZ3RoIC0gMSk7IC8vIFRPRE86IHVzZSByZWdleCBwcm9ic1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtvZmZzZXRGcm9tU3RhcnRPZkJsb2NrXSBvZiBbLi4uc3RyVG9NYXRjaE9uXS5yZXZlcnNlKCkuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU2hvcnRjdXRUZXh0ID0gc3RyVG9NYXRjaE9uLnN1YnN0cihvZmZzZXRGcm9tU3RhcnRPZkJsb2NrLCBzaG9ydGN1dFRleHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRTaG9ydGN1dFRleHQgIT09IHNob3J0Y3V0VGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRPZlN0YXJ0T2ZTaG9ydGN1dCA9IG9mZnNldEZyb21TdGFydE9mQmxvY2sgPT09IDAgPyBzdGFydE9mQmxvY2sgOiBFZGl0b3JBZnRlckJ1dElnbm9yaW5naW5nUG9pbnRzV2l0aE5vQ29udGVudChlZGl0b3IsIHN0YXJ0T2ZCbG9jaywge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBvZmZzZXRGcm9tU3RhcnRPZkJsb2NrXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbmRPZlN0YXJ0T2ZTaG9ydGN1dCA9IHNsYXRlLkVkaXRvci5hZnRlcihlZGl0b3IsIHN0YXJ0T2ZTdGFydE9mU2hvcnRjdXQsIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZTogc2hvcnRjdXRUZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAob2Zmc2V0RnJvbVN0YXJ0T2ZCbG9jayAhPT0gMCAmJiAhL1xccy8udGVzdChzbGF0ZS5FZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGFuY2hvcjogc2xhdGUuRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0T2ZTdGFydE9mU2hvcnRjdXQsIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQ6ICdjaGFyYWN0ZXInXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZm9jdXM6IHN0YXJ0T2ZTdGFydE9mU2hvcnRjdXRcbiAgICAgICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50QmV0d2VlblNob3J0Y3V0cyA9IHNsYXRlLkVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBlbmRPZlN0YXJ0T2ZTaG9ydGN1dCxcbiAgICAgICAgICAgICAgICBmb2N1czogZWRpdG9yLnNlbGVjdGlvbi5hbmNob3JcbiAgICAgICAgICAgICAgfSkuc2xpY2UoMCwgLXNob3J0Y3V0VGV4dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZW50QmV0d2VlblNob3J0Y3V0cyA9PT0gJycgfHwgL1xccy8udGVzdChjb250ZW50QmV0d2VlblNob3J0Y3V0c1swXSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSAvLyB0aGlzIGlzIGEgYml0IG9mIGEgd2VpcmQgb25lXG4gICAgICAgICAgICAgIC8vIGxldCdzIHNheSB5b3UgaGFkIDx0ZXh0Pl9fdGhpbmcgXzxjdXJzb3IgLz48L3RleHQ+IGFuZCB5b3UgaW5zZXJ0IGBfYC5cbiAgICAgICAgICAgICAgLy8gd2l0aG91dCB0aGUgYmVsb3csIHRoYXQgd291bGQgdHVybiBpbnRvIDx0ZXh0IGl0YWxpYz5fdGhpbmcgXzxjdXJzb3IgLz48L3RleHQ+XG4gICAgICAgICAgICAgIC8vIGJ1dCBpdCdzIHByb2JhYmx5IG1lYW50IHRvIGJlIGJvbGQgYnV0IGl0J3Mgbm90IGJlY2F1c2Ugb2YgdGhlIHNwYWNlIGJlZm9yZSB0aGUgZW5kaW5nIF9cbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcyBidXQgbWVoLCB0aGlzIHdvcmtzXG5cblxuICAgICAgICAgICAgICBpZiAobWFyayA9PT0gJ2l0YWxpYycgJiYgKGNvbnRlbnRCZXR3ZWVuU2hvcnRjdXRzWzBdID09PSAnXycgfHwgY29udGVudEJldHdlZW5TaG9ydGN1dHNbMF0gPT09ICcqJykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMgPSBnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzKGVkaXRvciwgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKTtcblxuICAgICAgICAgICAgICBpZiAoYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyAmJiBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzLmlubGluZU1hcmtzICE9PSAnaW5oZXJpdCcgJiYgYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcy5pbmxpbmVNYXJrc1ttYXJrXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFwcGx5TWFyayhlZGl0b3IsIG1hcmssIHNob3J0Y3V0VGV4dCwgc3RhcnRPZlN0YXJ0T2ZTaG9ydGN1dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxubGV0IG5vb3AgPSAoKSA9PiB7fTtcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyh0b29sYmFyU3RhdGUsIGNvbXBvbmVudEJsb2NrcywgcmVsYXRpb25zaGlwcykge1xuICBjb25zdCBvcHRpb25zID0gWy4uLk9iamVjdC5lbnRyaWVzKHJlbGF0aW9uc2hpcHMpLmZpbHRlcih4ID0+IHhbMV0ua2luZCA9PT0gJ2lubGluZScpLm1hcCgoW3JlbGF0aW9uc2hpcCwge1xuICAgIGxhYmVsXG4gIH1dKSA9PiAoe1xuICAgIGxhYmVsLFxuICAgIGluc2VydDogZWRpdG9yID0+IHtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIHR5cGU6ICdyZWxhdGlvbnNoaXAnLFxuICAgICAgICByZWxhdGlvbnNoaXAsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9XG4gIH0pKSwgLi4uT2JqZWN0LmtleXMoY29tcG9uZW50QmxvY2tzKS5tYXAoa2V5ID0+ICh7XG4gICAgbGFiZWw6IGNvbXBvbmVudEJsb2Nrc1trZXldLmxhYmVsLFxuICAgIGluc2VydDogZWRpdG9yID0+IHtcbiAgICAgIGluc2VydENvbXBvbmVudEJsb2NrKGVkaXRvciwgY29tcG9uZW50QmxvY2tzLCBrZXksIHJlbGF0aW9uc2hpcHMpO1xuICAgIH1cbiAgfSkpLCAuLi50b29sYmFyU3RhdGUudGV4dFN0eWxlcy5hbGxvd2VkSGVhZGluZ0xldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICBsYWJlbDogYEhlYWRpbmcgJHtsZXZlbH1gLFxuXG4gICAgaW5zZXJ0KGVkaXRvcikge1xuICAgICAgaW5zZXJ0Tm9kZXNCdXRSZXBsYWNlSWZTZWxlY3Rpb25Jc0F0RW1wdHlQYXJhZ3JhcGhPckhlYWRpbmcoZWRpdG9yLCB7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSkpLCAhdG9vbGJhclN0YXRlLmJsb2NrcXVvdGUuaXNEaXNhYmxlZCAmJiB0b29sYmFyU3RhdGUuZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMuYmxvY2txdW90ZSAmJiB7XG4gICAgbGFiZWw6ICdCbG9ja3F1b3RlJyxcblxuICAgIGluc2VydChlZGl0b3IpIHtcbiAgICAgIGluc2VydE5vZGVzQnV0UmVwbGFjZUlmU2VsZWN0aW9uSXNBdEVtcHR5UGFyYWdyYXBoT3JIZWFkaW5nKGVkaXRvciwge1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSwgIXRvb2xiYXJTdGF0ZS5jb2RlLmlzRGlzYWJsZWQgJiYgdG9vbGJhclN0YXRlLmVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUgJiYge1xuICAgIGxhYmVsOiAnQ29kZSBibG9jaycsXG5cbiAgICBpbnNlcnQoZWRpdG9yKSB7XG4gICAgICBpbnNlcnROb2Rlc0J1dFJlcGxhY2VJZlNlbGVjdGlvbklzQXRFbXB0eVBhcmFncmFwaE9ySGVhZGluZyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH0sICF0b29sYmFyU3RhdGUuZGl2aWRlcnMuaXNEaXNhYmxlZCAmJiB0b29sYmFyU3RhdGUuZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5kaXZpZGVycyAmJiB7XG4gICAgbGFiZWw6ICdEaXZpZGVyJyxcblxuICAgIGluc2VydChlZGl0b3IpIHtcbiAgICAgIGluc2VydE5vZGVzQnV0UmVwbGFjZUlmU2VsZWN0aW9uSXNBdEVtcHR5UGFyYWdyYXBoT3JIZWFkaW5nKGVkaXRvciwge1xuICAgICAgICB0eXBlOiAnZGl2aWRlcicsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSwgISF0b29sYmFyU3RhdGUuZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5sYXlvdXRzLmxlbmd0aCAmJiB7XG4gICAgbGFiZWw6ICdMYXlvdXQnLFxuXG4gICAgaW5zZXJ0KGVkaXRvcikge1xuICAgICAgaW5zZXJ0TGF5b3V0KGVkaXRvciwgdG9vbGJhclN0YXRlLmVkaXRvckRvY3VtZW50RmVhdHVyZXMubGF5b3V0c1swXSk7XG4gICAgfVxuXG4gIH0sICF0b29sYmFyU3RhdGUubGlzdHMub3JkZXJlZC5pc0Rpc2FibGVkICYmIHRvb2xiYXJTdGF0ZS5lZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLm9yZGVyZWQgJiYge1xuICAgIGxhYmVsOiAnTnVtYmVyZWQgTGlzdCcsXG4gICAga2V5d29yZHM6IFsnb3JkZXJlZCBsaXN0J10sXG5cbiAgICBpbnNlcnQoZWRpdG9yKSB7XG4gICAgICBpbnNlcnROb2Rlc0J1dFJlcGxhY2VJZlNlbGVjdGlvbklzQXRFbXB0eVBhcmFncmFwaE9ySGVhZGluZyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ29yZGVyZWQtbGlzdCcsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSwgIXRvb2xiYXJTdGF0ZS5saXN0cy51bm9yZGVyZWQuaXNEaXNhYmxlZCAmJiB0b29sYmFyU3RhdGUuZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmxpc3RUeXBlcy51bm9yZGVyZWQgJiYge1xuICAgIGxhYmVsOiAnQnVsbGV0IExpc3QnLFxuICAgIGtleXdvcmRzOiBbJ3Vub3JkZXJlZCBsaXN0J10sXG5cbiAgICBpbnNlcnQoZWRpdG9yKSB7XG4gICAgICBpbnNlcnROb2Rlc0J1dFJlcGxhY2VJZlNlbGVjdGlvbklzQXRFbXB0eVBhcmFncmFwaE9ySGVhZGluZyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ3Vub3JkZXJlZC1saXN0JyxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XTtcbiAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKHggPT4gdHlwZW9mIHggIT09ICdib29sZWFuJyk7XG59XG5cbmZ1bmN0aW9uIGluc2VydE9wdGlvbihlZGl0b3IsIHRleHQsIG9wdGlvbikge1xuICBjb25zdCBwYXRoID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRleHQpO1xuICBzbGF0ZS5UcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICBhdDoge1xuICAgICAgZm9jdXM6IHNsYXRlLkVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpLFxuICAgICAgYW5jaG9yOiBzbGF0ZS5FZGl0b3IuZW5kKGVkaXRvciwgcGF0aClcbiAgICB9XG4gIH0pO1xuICBvcHRpb24uaW5zZXJ0KGVkaXRvcik7XG59IC8vIFRPRE86IHRoZSBjaGFuZ2luZyB3aWR0aCBvZiB0aGUgbWVudSB3aGVuIHNlYXJjaGluZyBpc24ndCBncmVhdFxuXG5cbmZ1bmN0aW9uIEluc2VydE1lbnUoe1xuICBjaGlsZHJlbixcbiAgdGV4dFxufSkge1xuICBjb25zdCB0b29sYmFyU3RhdGUgPSB1c2VUb29sYmFyU3RhdGUoKTtcbiAgY29uc3Qge1xuICAgIGVkaXRvcixcbiAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICBpc0Rpc2FibGVkOiByZWxhdGlvbnNoaXBzRGlzYWJsZWRcbiAgICB9XG4gIH0gPSB0b29sYmFyU3RhdGU7XG4gIGNvbnN0IHtcbiAgICBkaWFsb2csXG4gICAgdHJpZ2dlclxuICB9ID0gcG9wb3Zlci51c2VDb250cm9sbGVkUG9wb3Zlcih7XG4gICAgaXNPcGVuOiB0cnVlLFxuICAgIG9uQ2xvc2U6IG5vb3BcbiAgfSwge1xuICAgIHBsYWNlbWVudDogJ2JvdHRvbS1zdGFydCdcbiAgfSk7XG4gIGNvbnN0IGNvbXBvbmVudEJsb2NrcyA9IFJlYWN0LnVzZUNvbnRleHQoQ29tcG9uZW50QmxvY2tDb250ZXh0KTtcbiAgY29uc3QgcmVsYXRpb25zaGlwcyA9IHVzZURvY3VtZW50RmllbGRSZWxhdGlvbnNoaXBzKCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBtYXRjaFNvcnRlci5tYXRjaFNvcnRlcihnZXRPcHRpb25zKHRvb2xiYXJTdGF0ZSwgY29tcG9uZW50QmxvY2tzLCByZWxhdGlvbnNoaXBzRGlzYWJsZWQgPyB7fSA6IHJlbGF0aW9uc2hpcHMpLCB0ZXh0LnRleHQuc2xpY2UoMSksIHtcbiAgICBrZXlzOiBbJ2xhYmVsJywgJ2tleXdvcmRzJ11cbiAgfSk7XG4gIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuXG4gIGlmIChvcHRpb25zLmxlbmd0aCAmJiBzZWxlY3RlZEluZGV4ID49IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgc2V0U2VsZWN0ZWRJbmRleCgwKTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlUmVmID0gUmVhY3QudXNlUmVmKHtcbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIG9wdGlvbnMsXG4gICAgdGV4dFxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGRpYWxvZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2RpYWxvZ1JlZiRjdXJyZW50LCBfZGlhbG9nUmVmJGN1cnJlbnQkY2g7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gKF9kaWFsb2dSZWYkY3VycmVudCA9IGRpYWxvZ1JlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZGlhbG9nUmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZGlhbG9nUmVmJGN1cnJlbnQkY2ggPSBfZGlhbG9nUmVmJGN1cnJlbnQuY2hpbGRyZW4pID09PSBudWxsIHx8IF9kaWFsb2dSZWYkY3VycmVudCRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RpYWxvZ1JlZiRjdXJyZW50JGNoW3NlbGVjdGVkSW5kZXhdO1xuXG4gICAgaWYgKGRpYWxvZ1JlZi5jdXJyZW50ICYmIGVsZW1lbnQpIHtcbiAgICAgIHNjcm9sbEludG9WaWV3X19kZWZhdWx0W1wiZGVmYXVsdFwiXShlbGVtZW50LCB7XG4gICAgICAgIHNjcm9sbE1vZGU6ICdpZi1uZWVkZWQnLFxuICAgICAgICBib3VuZGFyeTogZGlhbG9nUmVmLmN1cnJlbnQsXG4gICAgICAgIGJsb2NrOiAnbmVhcmVzdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3NlbGVjdGVkSW5kZXhdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBkb21Ob2RlID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuXG4gICAgbGV0IGxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHN0YXRlUmVmLmN1cnJlbnQuc2VsZWN0ZWRJbmRleCA9PT0gc3RhdGVSZWYuY3VycmVudC5vcHRpb25zLmxlbmd0aCAtIDEgPyAwIDogc3RhdGVSZWYuY3VycmVudC5zZWxlY3RlZEluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChzdGF0ZVJlZi5jdXJyZW50LnNlbGVjdGVkSW5kZXggPT09IDAgPyBzdGF0ZVJlZi5jdXJyZW50Lm9wdGlvbnMubGVuZ3RoIC0gMSA6IHN0YXRlUmVmLmN1cnJlbnQuc2VsZWN0ZWRJbmRleCAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBzdGF0ZVJlZi5jdXJyZW50Lm9wdGlvbnNbc3RhdGVSZWYuY3VycmVudC5zZWxlY3RlZEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICBpbnNlcnRPcHRpb24oZWRpdG9yLCBzdGF0ZVJlZi5jdXJyZW50LnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHN0YXRlUmVmLmN1cnJlbnQudGV4dCk7XG4gICAgICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAnaW5zZXJ0TWVudScsIHtcbiAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9tTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgbGlzdGVuZXIpO1xuICAgIH07XG4gIH0sIFtlZGl0b3JdKTtcbiAgY29uc3QgRElBTE9HX0hFSUdIVCA9IDMwMDtcbiAgcmV0dXJuIGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHRyaWdnZXIucHJvcHMsIHtcbiAgICBjc3M6IHtcbiAgICAgIGNvbG9yOiAnYmx1ZSdcbiAgICB9LFxuICAgIHJlZjogdHJpZ2dlci5yZWZcbiAgfSksIGNoaWxkcmVuKSwgY29yZS5qc3goY29yZS5Qb3J0YWwsIG51bGwsIGNvcmUuanN4KHRvb2xiYXIuSW5saW5lRGlhbG9nLCBfZXh0ZW5kcyh7XG4gICAgY29udGVudEVkaXRhYmxlOiBmYWxzZVxuICB9LCBkaWFsb2cucHJvcHMsIHtcbiAgICBjc3M6IHtcbiAgICAgIGRpc3BsYXk6IG9wdGlvbnMubGVuZ3RoID8gdW5kZWZpbmVkIDogJ25vbmUnLFxuICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgbWF4SGVpZ2h0OiBESUFMT0dfSEVJR0hUXG4gICAgfSxcbiAgICByZWY6IGRpYWxvZy5yZWZcbiAgfSksIGNvcmUuanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IGRpYWxvZ1JlZixcbiAgICBjc3M6IHtcbiAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgbWF4SGVpZ2h0OiBESUFMT0dfSEVJR0hUIC0gOCAqIDJcbiAgICB9XG4gIH0sIG9wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiBjb3JlLmpzeCh0b29sYmFyLlRvb2xiYXJCdXR0b24sIHtcbiAgICBrZXk6IG9wdGlvbi5sYWJlbCxcbiAgICBpc1ByZXNzZWQ6IGluZGV4ID09PSBzZWxlY3RlZEluZGV4LFxuICAgIG9uTW91c2VFbnRlcjogKCkgPT4ge1xuICAgICAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCk7XG4gICAgfSxcbiAgICBvbk1vdXNlRG93bjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGluc2VydE9wdGlvbihlZGl0b3IsIHRleHQsIG9wdGlvbik7XG4gICAgfVxuICB9LCBvcHRpb24ubGFiZWwpKSkpKSk7XG59XG5jb25zdCBub2RlTGlzdHNXaXRob3V0SW5zZXJ0TWVudSA9IG5ldyBXZWFrU2V0KCk7XG5jb25zdCBub2Rlc1dpdGhvdXRJbnNlcnRNZW51ID0gbmV3IFdlYWtTZXQoKTtcblxuZnVuY3Rpb24gZmluZFBhdGhXaXRoSW5zZXJ0TWVudShub2RlLCBwYXRoKSB7XG4gIGlmIChzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBub2RlLmluc2VydE1lbnUgPyBwYXRoIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKG5vZGVMaXN0c1dpdGhvdXRJbnNlcnRNZW51Lmhhcyhub2RlLmNoaWxkcmVuKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICBpZiAobm9kZXNXaXRob3V0SW5zZXJ0TWVudS5oYXMoY2hpbGQpKSBjb250aW51ZTtcbiAgICBsZXQgbWF5YmVQYXRoID0gZmluZFBhdGhXaXRoSW5zZXJ0TWVudShjaGlsZCwgWy4uLnBhdGgsIGluZGV4XSk7XG5cbiAgICBpZiAobWF5YmVQYXRoKSB7XG4gICAgICByZXR1cm4gbWF5YmVQYXRoO1xuICAgIH1cblxuICAgIG5vZGVzV2l0aG91dEluc2VydE1lbnUuYWRkKGNoaWxkKTtcbiAgfVxuXG4gIG5vZGVMaXN0c1dpdGhvdXRJbnNlcnRNZW51LmFkZChub2RlLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW5zZXJ0TWVudU1hcmtXaGVuT3V0c2lkZU9mU2VsZWN0aW9uKGVkaXRvcikge1xuICB2YXIgX0VkaXRvciRtYXJrcztcblxuICBjb25zdCBwYXRoID0gZmluZFBhdGhXaXRoSW5zZXJ0TWVudShlZGl0b3IsIFtdKTtcblxuICBpZiAocGF0aCAmJiAhKChfRWRpdG9yJG1hcmtzID0gc2xhdGUuRWRpdG9yLm1hcmtzKGVkaXRvcikpICE9PSBudWxsICYmIF9FZGl0b3IkbWFya3MgIT09IHZvaWQgMCAmJiBfRWRpdG9yJG1hcmtzLmluc2VydE1lbnUpICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhc2xhdGUuUGF0aC5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aCwgcGF0aCkgfHwgIXNsYXRlLlBhdGguZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aCwgcGF0aCkpKSB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgJ2luc2VydE1lbnUnLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3aXRoSW5zZXJ0TWVudShlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIG5vcm1hbGl6ZU5vZGUsXG4gICAgYXBwbHksXG4gICAgaW5zZXJ0VGV4dFxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgIGlmIChzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSAmJiBub2RlLmluc2VydE1lbnUpIHtcbiAgICAgIGlmIChub2RlLnRleHRbMF0gIT09ICcvJykge1xuICAgICAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAnaW5zZXJ0TWVudScsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3aGl0ZXNwYWNlTWF0Y2ggPSAvXFxzLy5leGVjKG5vZGUudGV4dCk7XG5cbiAgICAgIGlmICh3aGl0ZXNwYWNlTWF0Y2gpIHtcbiAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgJ2luc2VydE1lbnUnLCB7XG4gICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHdoaXRlc3BhY2VNYXRjaC5pbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiBzbGF0ZS5FZGl0b3IuZW5kKGVkaXRvciwgcGF0aClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hdGNoOiBzbGF0ZS5UZXh0LmlzVGV4dCxcbiAgICAgICAgICBzcGxpdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzbGF0ZS5FZGl0b3IuaXNFZGl0b3IoZWRpdG9yKSAmJiByZW1vdmVJbnNlcnRNZW51TWFya1doZW5PdXRzaWRlT2ZTZWxlY3Rpb24oZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcblxuICBlZGl0b3IuYXBwbHkgPSBvcCA9PiB7XG4gICAgYXBwbHkob3ApOyAvLyB3ZSdyZSBjYWxsaW5nIHRoaXMgaGVyZSBBTkQgaW4gbm9ybWFsaXplTm9kZVxuICAgIC8vIGJlY2F1c2Ugbm9ybWFsaXplTm9kZSB3b24ndCBiZSBjYWxsZWQgb24gc2VsZWN0aW9uIGNoYW5nZXNcbiAgICAvLyBidXQgYXBwbHkgd2lsbFxuICAgIC8vIHdlJ3JlIHN0aWxsIGNhbGxpbmcgdGhpcyBmcm9tIG5vcm1hbGl6ZU5vZGUgdGhvdWdoIGJlY2F1c2Ugd2Ugd2FudCBpdCB0byBoYXBwZW5cbiAgICAvLyB3aGVuIG5vcm1hbGl6YXRpb24gaGFwcGVuc1xuXG4gICAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgICAgcmVtb3ZlSW5zZXJ0TWVudU1hcmtXaGVuT3V0c2lkZU9mU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgfVxuICB9O1xuXG4gIGVkaXRvci5pbnNlcnRUZXh0ID0gdGV4dCA9PiB7XG4gICAgaW5zZXJ0VGV4dCh0ZXh0KTtcblxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHRleHQgPT09ICcvJykge1xuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrID0gc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogbm9kZSA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpXG4gICAgICB9KVsxXSk7XG4gICAgICBjb25zdCBiZWZvcmUgPSBzbGF0ZS5FZGl0b3IuYmVmb3JlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IsIHtcbiAgICAgICAgdW5pdDogJ2NoYXJhY3RlcidcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYmVmb3JlICYmIChzbGF0ZS5Qb2ludC5lcXVhbHMoc3RhcnRPZkJsb2NrLCBiZWZvcmUpIHx8IGJlZm9yZS5vZmZzZXQgIT09IDAgJiYgL1xccy8udGVzdChzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIGJlZm9yZS5wYXRoKS50ZXh0W2JlZm9yZS5vZmZzZXQgLSAxXSkpKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgaW5zZXJ0TWVudTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgIGFuY2hvcjogYmVmb3JlLFxuICAgICAgICAgICAgZm9jdXM6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXRjaDogc2xhdGUuVGV4dC5pc1RleHQsXG4gICAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgcGxhY2Vob2xkZXIsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IFt3aWR0aCwgc2V0V2lkdGhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIHJldHVybiBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIHdpZHRoXG4gICAgfVxuICB9LCBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgb3BhY2l0eTogJzAuNScsXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnbGVmdCdcbiAgICB9XG4gIH0sIGNvcmUuanN4KFwic3BhblwiLCB7XG4gICAgcmVmOiBub2RlID0+IHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aDtcblxuICAgICAgICBpZiAob2Zmc2V0V2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgc2V0V2lkdGgob2Zmc2V0V2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBwbGFjZWhvbGRlcikpLCBjaGlsZHJlbik7XG59XG5cbmNvbnN0IExlYWYgPSAoe1xuICBsZWFmLFxuICB0ZXh0LFxuICBjaGlsZHJlbixcbiAgYXR0cmlidXRlc1xufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY29sb3JzLFxuICAgIHJhZGlpLFxuICAgIHNwYWNpbmcsXG4gICAgdHlwb2dyYXBoeVxuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICBjb25zdCB7XG4gICAgdW5kZXJsaW5lLFxuICAgIHN0cmlrZXRocm91Z2gsXG4gICAgYm9sZCxcbiAgICBpdGFsaWMsXG4gICAgY29kZSxcbiAgICBrZXlib2FyZCxcbiAgICBzdXBlcnNjcmlwdCxcbiAgICBzdWJzY3JpcHQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgaW5zZXJ0TWVudVxuICB9ID0gbGVhZjtcblxuICBpZiAocGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkcmVuID0gY29yZS5qc3goUGxhY2Vob2xkZXIsIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlclxuICAgIH0sIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChpbnNlcnRNZW51KSB7XG4gICAgY2hpbGRyZW4gPSBjb3JlLmpzeChJbnNlcnRNZW51LCB7XG4gICAgICB0ZXh0OiB0ZXh0XG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGNvZGUpIHtcbiAgICBjaGlsZHJlbiA9IGNvcmUuanN4KFwiY29kZVwiLCB7XG4gICAgICBjc3M6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuYmFja2dyb3VuZERpbSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiByYWRpaS54c21hbGwsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBmb250RmFtaWx5OiB0eXBvZ3JhcGh5LmZvbnRGYW1pbHkubW9ub3NwYWNlLFxuICAgICAgICBmb250U2l6ZTogdHlwb2dyYXBoeS5mb250U2l6ZS5zbWFsbCxcbiAgICAgICAgcGFkZGluZzogYDAgJHtzcGFjaW5nLnh4c21hbGx9cHhgXG4gICAgICB9XG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGJvbGQpIHtcbiAgICBjaGlsZHJlbiA9IGNvcmUuanN4KFwic3Ryb25nXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChzdHJpa2V0aHJvdWdoKSB7XG4gICAgY2hpbGRyZW4gPSBjb3JlLmpzeChcInNcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGl0YWxpYykge1xuICAgIGNoaWxkcmVuID0gY29yZS5qc3goXCJlbVwiLCBudWxsLCBjaGlsZHJlbik7XG4gIH1cblxuICBpZiAoa2V5Ym9hcmQpIHtcbiAgICBjaGlsZHJlbiA9IGNvcmUuanN4KFwia2JkXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChzdXBlcnNjcmlwdCkge1xuICAgIGNoaWxkcmVuID0gY29yZS5qc3goXCJzdXBcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKHN1YnNjcmlwdCkge1xuICAgIGNoaWxkcmVuID0gY29yZS5qc3goXCJzdWJcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKHVuZGVybGluZSkge1xuICAgIGNoaWxkcmVuID0gY29yZS5qc3goXCJ1XCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIHJldHVybiBjb3JlLmpzeChcInNwYW5cIiwgYXR0cmlidXRlcywgY2hpbGRyZW4pO1xufTtcblxuY29uc3QgcmVuZGVyTGVhZiA9IHByb3BzID0+IHtcbiAgcmV0dXJuIGNvcmUuanN4KExlYWYsIHByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIHdpdGhTb2Z0QnJlYWtzKGlzU2hpZnRQcmVzc2VkUmVmLCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGluc2VydEJyZWFrXG4gIH0gPSBlZGl0b3I7IC8vIFRPRE86IHNob3VsZCBzb2Z0IGJyZWFrcyBvbmx5IHdvcmsgaW4gcGFydGljdWxhciBwbGFjZXNcblxuICBlZGl0b3IuaW5zZXJ0QnJlYWsgPSAoKSA9PiB7XG4gICAgaWYgKGlzU2hpZnRQcmVzc2VkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsICdcXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0QnJlYWsoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmZ1bmN0aW9uIHVzZUtleURvd25SZWYodGFyZ2V0S2V5KSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgICAgaWYgKGUua2V5ICE9PSB0YXJnZXRLZXkpIHJldHVybjtcbiAgICAgIHJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlS2V5VXAgPSBlID0+IHtcbiAgICAgIGlmIChlLmtleSAhPT0gdGFyZ2V0S2V5KSByZXR1cm47XG4gICAgICByZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlS2V5VXAsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVLZXlVcCk7XG4gICAgfTtcbiAgfSwgW3RhcmdldEtleV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzaG9ydGN1dHMgPSB7XG4gICcuLi4nOiAn4oCmJyxcbiAgJy0tPic6ICfihpInLFxuICAnLT4nOiAn4oaSJyxcbiAgJzwtJzogJ+KGkCcsXG4gICc8LS0nOiAn4oaQJyxcbiAgJy0tJzogJ+KAkydcbn07XG5mdW5jdGlvbiB3aXRoU2hvcnRjdXRzKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0VGV4dFxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5pbnNlcnRUZXh0ID0gdGV4dCA9PiB7XG4gICAgaW5zZXJ0VGV4dCh0ZXh0KTtcblxuICAgIGlmICh0ZXh0ID09PSAnICcgJiYgZWRpdG9yLnNlbGVjdGlvbiAmJiBzbGF0ZS5SYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uUG9pbnQgPSBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGFuY2VzdG9yQmxvY2sgPSBzbGF0ZS5FZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBub2RlID0+IHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYW5jZXN0b3JCbG9jaykge1xuICAgICAgICBPYmplY3Qua2V5cyhzaG9ydGN1dHMpLmZvckVhY2goc2hvcnRjdXQgPT4ge1xuICAgICAgICAgIGNvbnN0IHBvaW50QmVmb3JlID0gc2xhdGUuRWRpdG9yLmJlZm9yZShlZGl0b3IsIHNlbGVjdGlvblBvaW50LCB7XG4gICAgICAgICAgICB1bml0OiAnY2hhcmFjdGVyJyxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBzaG9ydGN1dC5sZW5ndGggKyAxXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAocG9pbnRCZWZvcmUgJiYgc2xhdGUuUGF0aC5pc0Rlc2NlbmRhbnQocG9pbnRCZWZvcmUucGF0aCwgYW5jZXN0b3JCbG9ja1sxXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgICBhbmNob3I6IHNlbGVjdGlvblBvaW50LFxuICAgICAgICAgICAgICBmb2N1czogcG9pbnRCZWZvcmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBzbGF0ZS5FZGl0b3Iuc3RyaW5nKGVkaXRvciwgcmFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoc3RyLnN1YnN0cigwLCBzaG9ydGN1dC5sZW5ndGgpID09PSBzaG9ydGN1dCkge1xuICAgICAgICAgICAgICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCByYW5nZSk7XG4gICAgICAgICAgICAgIGVkaXRvci5pbnNlcnRUZXh0KHNob3J0Y3V0c1tzaG9ydGN1dF0gKyAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmZ1bmN0aW9uIHdpdGhCbG9ja01hcmtkb3duU2hvcnRjdXRzKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2NrcywgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnRUZXh0XG4gIH0gPSBlZGl0b3I7XG4gIGNvbnN0IHNob3J0Y3V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgY29uc3QgZWRpdG9yRG9jdW1lbnRGZWF0dXJlc0Zvck5vcm1hbGl6YXRpb25Ub0NoZWNrID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkb2N1bWVudEZlYXR1cmVzKSwge30sIHtcbiAgICByZWxhdGlvbnNoaXBzOiB0cnVlXG4gIH0pO1xuXG4gIGxldCBhZGRTaG9ydGN1dCA9ICh0ZXh0LCBpbnNlcnQsIHNob3VsZEJlRW5hYmxlZEluQ29tcG9uZW50QmxvY2ssIHR5cGUgPSAncGFyYWdyYXBoJykgPT4ge1xuICAgIGlmICghc2hvdWxkQmVFbmFibGVkSW5Db21wb25lbnRCbG9jayhlZGl0b3JEb2N1bWVudEZlYXR1cmVzRm9yTm9ybWFsaXphdGlvblRvQ2hlY2spKSByZXR1cm47XG4gICAgY29uc3QgdHJpZ2dlciA9IHRleHRbdGV4dC5sZW5ndGggLSAxXTtcblxuICAgIGlmICghc2hvcnRjdXRzW3RyaWdnZXJdKSB7XG4gICAgICBzaG9ydGN1dHNbdHJpZ2dlcl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIHNob3J0Y3V0c1t0cmlnZ2VyXVt0ZXh0XSA9IHtcbiAgICAgIGluc2VydCxcbiAgICAgIHR5cGUsXG4gICAgICBzaG91bGRCZUVuYWJsZWRJbkNvbXBvbmVudEJsb2NrXG4gICAgfTtcbiAgfTtcblxuICBhZGRTaG9ydGN1dCgnMS4gJywgKCkgPT4ge1xuICAgIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgdHlwZTogJ29yZGVyZWQtbGlzdCcsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9LCB7XG4gICAgICBtYXRjaDogbiA9PiBzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pXG4gICAgfSk7XG4gIH0sIGZlYXR1cmVzID0+IGZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzLm9yZGVyZWQpO1xuICBhZGRTaG9ydGN1dCgnLSAnLCAoKSA9PiB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICB0eXBlOiAndW5vcmRlcmVkLWxpc3QnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSwge1xuICAgICAgbWF0Y2g6IG4gPT4gc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgIH0pO1xuICB9LCBmZWF0dXJlcyA9PiBmZWF0dXJlcy5mb3JtYXR0aW5nLmxpc3RUeXBlcy51bm9yZGVyZWQpO1xuICBhZGRTaG9ydGN1dCgnKiAnLCAoKSA9PiB7XG4gICAgc2xhdGUuVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICB0eXBlOiAndW5vcmRlcmVkLWxpc3QnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSwge1xuICAgICAgbWF0Y2g6IG4gPT4gc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgIH0pO1xuICB9LCBmZWF0dXJlcyA9PiBmZWF0dXJlcy5mb3JtYXR0aW5nLmxpc3RUeXBlcy51bm9yZGVyZWQpO1xuICBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ0xldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICBhZGRTaG9ydGN1dCgnIycucmVwZWF0KGxldmVsKSArICcgJywgKCkgPT4ge1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBsZXZlbFxuICAgICAgfSwge1xuICAgICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnXG4gICAgICB9KTtcbiAgICB9LCBmZWF0dXJlcyA9PiBmZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdMZXZlbHMuaW5jbHVkZXMobGV2ZWwpLCAnaGVhZGluZy1vci1wYXJhZ3JhcGgnKTtcbiAgfSk7XG4gIGFkZFNob3J0Y3V0KCc+ICcsICgpID0+IHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0sIHtcbiAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCdcbiAgICB9KTtcbiAgfSwgZmVhdHVyZXMgPT4gZmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmJsb2NrcXVvdGUpO1xuICBhZGRTaG9ydGN1dCgnYGBgJywgKCkgPT4ge1xuICAgIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSwge1xuICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgIH0pO1xuICB9LCBmZWF0dXJlcyA9PiBmZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZSk7XG4gIGFkZFNob3J0Y3V0KCctLS0nLCAoKSA9PiB7XG4gICAgaW5zZXJ0RGl2aWRlcihlZGl0b3IpO1xuICB9LCBmZWF0dXJlcyA9PiBmZWF0dXJlcy5kaXZpZGVycyk7XG5cbiAgZWRpdG9yLmluc2VydFRleHQgPSB0ZXh0ID0+IHtcbiAgICBpbnNlcnRUZXh0KHRleHQpO1xuICAgIGNvbnN0IHNob3J0Y3V0c0ZvclRyaWdnZXIgPSBzaG9ydGN1dHNbdGV4dF07XG5cbiAgICBpZiAoc2hvcnRjdXRzRm9yVHJpZ2dlciAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIHNsYXRlLlJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvclxuICAgICAgfSA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBibG9jayA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG5vZGUgPT4gc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBub2RlKVxuICAgICAgfSk7XG4gICAgICBpZiAoIWJsb2NrIHx8IGJsb2NrWzBdLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmIGJsb2NrWzBdLnR5cGUgIT09ICdoZWFkaW5nJykgcmV0dXJuO1xuICAgICAgY29uc3Qgc3RhcnQgPSBzbGF0ZS5FZGl0b3Iuc3RhcnQoZWRpdG9yLCBibG9ja1sxXSk7XG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1czogc3RhcnRcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG9ydGN1dFRleHQgPSBzbGF0ZS5FZGl0b3Iuc3RyaW5nKGVkaXRvciwgcmFuZ2UpO1xuICAgICAgY29uc3Qgc2hvcnRjdXQgPSBzaG9ydGN1dHNGb3JUcmlnZ2VyW3Nob3J0Y3V0VGV4dF07XG5cbiAgICAgIGlmICghc2hvcnRjdXQgfHwgc2hvcnRjdXQudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgYmxvY2tbMF0udHlwZSAhPT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMgPSBnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzKGVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKTtcblxuICAgICAgaWYgKGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcyAmJiAobG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmtpbmQgPT09ICdpbmxpbmUnIHx8ICFzaG9ydGN1dC5zaG91bGRCZUVuYWJsZWRJbkNvbXBvbmVudEJsb2NrKGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBzbyB0aGF0IHRoaXMgc3RhcnRzIGEgbmV3IHVuZG8gZ3JvdXBcblxuXG4gICAgICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKFtdKTtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgc2xhdGUuVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIHNob3J0Y3V0Lmluc2VydCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZWRpdG9yO1xufVxuXG4vLyBhIHYgaW1wb3J0YW50IG5vdGVcbi8vIG1hcmtzIGluIHRoZSBtYXJrZG93biBhc3QvaHRtbCBhcmUgcmVwcmVzZW50ZWQgcXVpdGUgZGlmZmVyZW50bHkgdG8gaG93IHRoZXkgYXJlIGluIHNsYXRlXG4vLyBpZiB5b3UgaGFkIHRoZSBtYXJrZG93biAqKnNvbWV0aGluZyBodHRwczovL2tleXN0b25lanMuY29tIHNvbWV0aGluZyoqXG4vLyB0aGUgYm9sZCBub2RlIGlzIHRoZSBwYXJlbnQgb2YgdGhlIGxpbmsgbm9kZVxuLy8gYnV0IGluIHNsYXRlLCBtYXJrcyBhcmUgb25seSByZXByZXNlbnRlZCBvbiB0ZXh0IG5vZGVzXG5jb25zdCBjdXJyZW50bHlBY3RpdmVNYXJrcyA9IG5ldyBTZXQoKTtcbmNvbnN0IGN1cnJlbnRseURpc2FibGVkTWFya3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBhZGRNYXJrVG9DaGlsZHJlbihtYXJrLCBjYikge1xuICBjb25zdCB3YXNQcmV2aW91c2x5QWN0aXZlID0gY3VycmVudGx5QWN0aXZlTWFya3MuaGFzKG1hcmspO1xuICBjdXJyZW50bHlBY3RpdmVNYXJrcy5hZGQobWFyayk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIXdhc1ByZXZpb3VzbHlBY3RpdmUpIHtcbiAgICAgIGN1cnJlbnRseUFjdGl2ZU1hcmtzLmRlbGV0ZShtYXJrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZE1hcmtzVG9DaGlsZHJlbihtYXJrcywgY2IpIHtcbiAgY29uc3QgbWFya3NUb1JlbW92ZSA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICBpZiAoIWN1cnJlbnRseUFjdGl2ZU1hcmtzLmhhcyhtYXJrKSkge1xuICAgICAgbWFya3NUb1JlbW92ZS5hZGQobWFyayk7XG4gICAgfVxuXG4gICAgY3VycmVudGx5QWN0aXZlTWFya3MuYWRkKG1hcmspO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3NUb1JlbW92ZSkge1xuICAgICAgY3VycmVudGx5QWN0aXZlTWFya3MuZGVsZXRlKG1hcmspO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VEaXNhYmxlTWFya0ZvckNoaWxkcmVuKG1hcmssIGNiKSB7XG4gIGNvbnN0IHdhc1ByZXZpb3VzbHlEaXNhYmxlZCA9IGN1cnJlbnRseURpc2FibGVkTWFya3MuaGFzKG1hcmspO1xuICBjdXJyZW50bHlEaXNhYmxlZE1hcmtzLmFkZChtYXJrKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICghd2FzUHJldmlvdXNseURpc2FibGVkKSB7XG4gICAgICBjdXJyZW50bHlEaXNhYmxlZE1hcmtzLmRlbGV0ZShtYXJrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRleHROb2RlRm9yQ3VycmVudGx5QWN0aXZlTWFya3ModGV4dCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHRleHRcbiAgfTtcblxuICBmb3IgKGNvbnN0IG1hcmsgb2YgY3VycmVudGx5QWN0aXZlTWFya3MpIHtcbiAgICBpZiAoIWN1cnJlbnRseURpc2FibGVkTWFya3MuaGFzKG1hcmspKSB7XG4gICAgICBub2RlW21hcmtdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7IC8vIGNvbmZsdWVuY2VcblxuICBjb25zdCBhdHRyaWJ1dGUgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFsaWduJyk7IC8vIG5vdGU6IHdlIGRvbid0IHNob3cgaHRtbCB0aGF0IGNvbmZsdWVuY2Ugd291bGQgcGFyc2UgYXMgYWxpZ25tZW50XG4gIC8vIHdlIGNvdWxkIGNoYW5nZSB0aGF0IGJ1dCBtZWhcbiAgLy8gKHRoZXkgbWF0Y2ggb24gZGl2LmZhYnJpYy1lZGl0b3ItYmxvY2stbWFyayB3aXRoIGRhdGEtYWxpZ24pXG5cbiAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2NlbnRlcicgfHwgYXR0cmlidXRlID09PSAnZW5kJykge1xuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgLy8gR29vZ2xlIGRvY3NcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBlbGVtZW50LnN0eWxlLnRleHRBbGlnbjtcblxuICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfSAvLyBUT0RPOiBSVEwgdGhpbmdzP1xuXG5cbiAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnIHx8IHRleHRBbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiAnZW5kJztcbiAgICB9XG4gIH1cbn0gLy8gU2VlIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTguaHRtbCNkaXN0cmlidXRpdmUtY29uZGl0aW9uYWwtdHlwZXNcblxuXG5jb25zdCBFTEVNRU5UX1RBR1MgPSB7XG4gIEE6IGVsID0+ICh7XG4gICAgdHlwZTogJ2xpbmsnLFxuICAgIGhyZWY6IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgIC8vIHVuZGVybGluZSBpcyBvbiBsaW5rcyBpbiBHb29nbGUgRG9jc1xuICAgIGNoaWxkcmVuOiBmb3JjZURpc2FibGVNYXJrRm9yQ2hpbGRyZW4oJ3VuZGVybGluZScsICgpID0+IGRlc2VyaWFsaXplQ2hpbGRyZW4kMShlbC5jaGlsZE5vZGVzKSlcbiAgfSksXG4gIEJMT0NLUVVPVEU6ICgpID0+ICh7XG4gICAgdHlwZTogJ2Jsb2NrcXVvdGUnXG4gIH0pLFxuICBIMTogZWwgPT4gKHtcbiAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgbGV2ZWw6IDEsXG4gICAgdGV4dEFsaWduOiBnZXRBbGlnbm1lbnRGcm9tRWxlbWVudChlbClcbiAgfSksXG4gIEgyOiBlbCA9PiAoe1xuICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICBsZXZlbDogMixcbiAgICB0ZXh0QWxpZ246IGdldEFsaWdubWVudEZyb21FbGVtZW50KGVsKVxuICB9KSxcbiAgSDM6IGVsID0+ICh7XG4gICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgIGxldmVsOiAzLFxuICAgIHRleHRBbGlnbjogZ2V0QWxpZ25tZW50RnJvbUVsZW1lbnQoZWwpXG4gIH0pLFxuICBINDogZWwgPT4gKHtcbiAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgbGV2ZWw6IDQsXG4gICAgdGV4dEFsaWduOiBnZXRBbGlnbm1lbnRGcm9tRWxlbWVudChlbClcbiAgfSksXG4gIEg1OiBlbCA9PiAoe1xuICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICBsZXZlbDogNSxcbiAgICB0ZXh0QWxpZ246IGdldEFsaWdubWVudEZyb21FbGVtZW50KGVsKVxuICB9KSxcbiAgSDY6IGVsID0+ICh7XG4gICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgIGxldmVsOiA2LFxuICAgIHRleHRBbGlnbjogZ2V0QWxpZ25tZW50RnJvbUVsZW1lbnQoZWwpXG4gIH0pLFxuICBJTUc6IGVsID0+ICh7XG4gICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0ZXh0OiBgPGltZyBhbHQ9JHtKU09OLnN0cmluZ2lmeShlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8ICcnKX0gc3JjPSR7SlNPTi5zdHJpbmdpZnkoZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSB8fCAnJyl9PmBcbiAgICB9XVxuICB9KSxcbiAgTEk6ICgpID0+ICh7XG4gICAgdHlwZTogJ2xpc3QtaXRlbSdcbiAgfSksXG4gIE9MOiAoKSA9PiAoe1xuICAgIHR5cGU6ICdvcmRlcmVkLWxpc3QnXG4gIH0pLFxuICBQOiBlbCA9PiAoe1xuICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgIHRleHRBbGlnbjogZ2V0QWxpZ25tZW50RnJvbUVsZW1lbnQoZWwpXG4gIH0pLFxuICBQUkU6ICgpID0+ICh7XG4gICAgdHlwZTogJ2NvZGUnXG4gIH0pLFxuICBVTDogKCkgPT4gKHtcbiAgICB0eXBlOiAndW5vcmRlcmVkLWxpc3QnXG4gIH0pLFxuICBIUjogKCkgPT4gKHtcbiAgICB0eXBlOiAnZGl2aWRlcicsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH1dXG4gIH0pXG59O1xuY29uc3QgVEVYVF9UQUdTID0ge1xuICBDT0RFOiAnY29kZScsXG4gIERFTDogJ3N0cmlrZXRocm91Z2gnLFxuICBTOiAnc3RyaWtldGhyb3VnaCcsXG4gIFNUUklLRTogJ3N0cmlrZXRocm91Z2gnLFxuICBFTTogJ2l0YWxpYycsXG4gIEk6ICdpdGFsaWMnLFxuICBTVFJPTkc6ICdib2xkJyxcbiAgVTogJ3VuZGVybGluZScsXG4gIFNVUDogJ3N1cGVyc2NyaXB0JyxcbiAgU1VCOiAnc3Vic2NyaXB0J1xufTtcblxuZnVuY3Rpb24gbWFya3NGcm9tRWxlbWVudEF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICBjb25zdCBtYXJrcyA9IG5ldyBTZXQoKTtcblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGVOYW1lXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgbWFya0Zyb21Ob2RlTmFtZSA9IFRFWFRfVEFHU1tub2RlTmFtZV07XG5cbiAgICBpZiAobWFya0Zyb21Ob2RlTmFtZSkge1xuICAgICAgbWFya3MuYWRkKG1hcmtGcm9tTm9kZU5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgIHZlcnRpY2FsQWxpZ25cbiAgICB9ID0gc3R5bGU7XG5cbiAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICBtYXJrcy5hZGQoJ3VuZGVybGluZScpO1xuICAgIH0gZWxzZSBpZiAodGV4dERlY29yYXRpb24gPT09ICdsaW5lLXRocm91Z2gnKSB7XG4gICAgICBtYXJrcy5hZGQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICB9IC8vIGNvbmZsdWVuY2VcblxuXG4gICAgaWYgKG5vZGVOYW1lID09PSAnU1BBTicgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvZGUnKSkge1xuICAgICAgbWFya3MuYWRkKCdjb2RlJyk7XG4gICAgfSAvLyBHb29nbGUgRG9jcyBkb2VzIHdlaXJkIHRoaW5ncyB3aXRoIDxiPlxuXG5cbiAgICBpZiAobm9kZU5hbWUgPT09ICdCJyAmJiBmb250V2VpZ2h0ICE9PSAnbm9ybWFsJykge1xuICAgICAgbWFya3MuYWRkKCdib2xkJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udFdlaWdodCA9PT0gJ3N0cmluZycgJiYgKGZvbnRXZWlnaHQgPT09ICdib2xkJyB8fCBmb250V2VpZ2h0ID09PSAnYm9sZGVyJyB8fCBmb250V2VpZ2h0ID09PSAnMTAwMCcgfHwgL15bNS05XVxcZHsyfSQvLnRlc3QoZm9udFdlaWdodCkpKSB7XG4gICAgICBtYXJrcy5hZGQoJ2JvbGQnKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgbWFya3MuYWRkKCdpdGFsaWMnKTtcbiAgICB9IC8vIEdvb2dsZSBEb2NzIHVzZXMgdmVydGljYWwgYWxpZ24gZm9yIHN1YnNjcmlwdCBhbmQgc3VwZXJzY3JpcHQgaW5zdGVhZCBvZiA8c3VwPiBhbmQgPHN1Yj5cblxuXG4gICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdXBlcicpIHtcbiAgICAgIG1hcmtzLmFkZCgnc3VwZXJzY3JpcHQnKTtcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdWInKSB7XG4gICAgICBtYXJrcy5hZGQoJ3N1YnNjcmlwdCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXJrcztcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVIVE1MKGh0bWwpIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCAndGV4dC9odG1sJyk7XG4gIHJldHVybiBkZXNlcmlhbGl6ZUhUTUxOb2RlKHBhcnNlZC5ib2R5KTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplSFRNTE5vZGUoZWwpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAzKSB7XG4gICAgY29uc3QgdGV4dCA9IGVsLnRleHRDb250ZW50O1xuXG4gICAgaWYgKCEodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgJiYgdGV4dC50cmltKCkpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtnZXRUZXh0Tm9kZUZvckN1cnJlbnRseUFjdGl2ZU1hcmtzKHRleHQpXTtcbiAgfVxuXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGxldCB7XG4gICAgbm9kZU5hbWVcbiAgfSA9IGVsO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIHJldHVybiBbZ2V0VGV4dE5vZGVGb3JDdXJyZW50bHlBY3RpdmVNYXJrcygnXFxuJyldO1xuICB9XG5cbiAgY29uc3QgbWFya3MgPSBtYXJrc0Zyb21FbGVtZW50QXR0cmlidXRlcyhlbCk7IC8vIERyb3Bib3ggUGFwZXIgZGlzcGxheXMgYmxvY2txdW90ZXMgYXMgbGlzdHMgZm9yIHNvbWUgcmVhc29uXG5cbiAgaWYgKGVsIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FbGVtZW50ICYmIGVsLmNsYXNzTGlzdC5jb250YWlucygnbGlzdHR5cGUtcXVvdGUnKSkge1xuICAgIG1hcmtzLmRlbGV0ZSgnaXRhbGljJyk7XG4gICAgbm9kZU5hbWUgPSAnQkxPQ0tRVU9URSc7XG4gIH1cblxuICByZXR1cm4gYWRkTWFya3NUb0NoaWxkcmVuKG1hcmtzLCAoKSA9PiB7XG4gICAgaWYgKEVMRU1FTlRfVEFHU1tub2RlTmFtZV0pIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gRUxFTUVOVF9UQUdTW25vZGVOYW1lXShlbCk7XG5cbiAgICAgIGlmIChhdHRycy5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gW2F0dHJzXTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNoaWxkcmVuID0gZGVzZXJpYWxpemVDaGlsZHJlbiQxKGVsLmNoaWxkTm9kZXMpO1xuICAgICAgcmV0dXJuIFtfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF0dHJzKSwge30sIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2VyaWFsaXplQ2hpbGRyZW4kMShlbC5jaGlsZE5vZGVzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQ2hpbGRyZW4kMShub2Rlcykge1xuICBjb25zdCBvdXRwdXROb2RlcyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlc2VyaWFsaXplSFRNTE5vZGUobm9kZSk7XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgb3V0cHV0Tm9kZXMucHVzaCguLi5yZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3V0cHV0Tm9kZXMubGVuZ3RoKSB7XG4gICAgb3V0cHV0Tm9kZXMucHVzaCh7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dE5vZGVzO1xufVxuXG5jb25zdCBtYXJrZG93bkNvbmZpZyA9IHtcbiAgbWRhc3RFeHRlbnNpb25zOiBbYXV0b0xpbmtMaXRlcmFsRnJvbU1hcmtkb3duRXh0ZW5zaW9uX19kZWZhdWx0W1wiZGVmYXVsdFwiXSwgZ2ZtU3RyaWtldGhyb3VnaEZyb21NYXJrZG93bkV4dGVuc2lvbl9fZGVmYXVsdFtcImRlZmF1bHRcIl1dLFxuICBleHRlbnNpb25zOiBbYXV0b0xpbmtMaXRlcmFsTWFya2Rvd25TeW50YXhfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLCBnZm1TdHJpa2V0aHJvdWdoTWFya2Rvd25TeW50YXhfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCldXG59O1xuZnVuY3Rpb24gZGVzZXJpYWxpemVNYXJrZG93bihtYXJrZG93bikge1xuICBjb25zdCByb290ID0gbWRBU1RVdGlsRnJvbU1hcmtkb3duX19kZWZhdWx0W1wiZGVmYXVsdFwiXShtYXJrZG93biwgbWFya2Rvd25Db25maWcpO1xuICBjb25zdCBnZXREZWZpbml0aW9uID0gZGVmaW5pdGlvbnNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHJvb3QpO1xuICBsZXQgbm9kZXMgPSByb290LmNoaWxkcmVuO1xuXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICBub2RlcyA9IG5vZGVzWzBdLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIGRlc2VyaWFsaXplQ2hpbGRyZW4obm9kZXMsIGdldERlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUNoaWxkcmVuKG5vZGVzLCBnZXREZWZpbml0aW9uKSB7XG4gIGNvbnN0IG91dHB1dE5vZGVzID0gW107XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVzZXJpYWxpemVNYXJrZG93bk5vZGUobm9kZSwgZ2V0RGVmaW5pdGlvbik7XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgb3V0cHV0Tm9kZXMucHVzaCguLi5yZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3V0cHV0Tm9kZXMubGVuZ3RoKSB7XG4gICAgb3V0cHV0Tm9kZXMucHVzaCh7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dE5vZGVzO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZU1hcmtkb3duTm9kZShub2RlLCBnZXREZWZpbml0aW9uKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICBjaGlsZHJlbjogZGVzZXJpYWxpemVDaGlsZHJlbihub2RlLmNoaWxkcmVuLCBnZXREZWZpbml0aW9uKVxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2xpbmtSZWZlcmVuY2UnOlxuICAgICAge1xuICAgICAgICB2YXIgX2dldERlZmluaXRpb247XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgIGhyZWY6ICgoX2dldERlZmluaXRpb24gPSBnZXREZWZpbml0aW9uKG5vZGUuaWRlbnRpZmllcikpID09PSBudWxsIHx8IF9nZXREZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RGVmaW5pdGlvbi51cmwpIHx8ICcnLFxuICAgICAgICAgIGNoaWxkcmVuOiBkZXNlcmlhbGl6ZUNoaWxkcmVuKG5vZGUuY2hpbGRyZW4sIGdldERlZmluaXRpb24pXG4gICAgICAgIH1dO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbGluayc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICBocmVmOiBub2RlLnVybCxcbiAgICAgICAgICBjaGlsZHJlbjogZGVzZXJpYWxpemVDaGlsZHJlbihub2RlLmNoaWxkcmVuLCBnZXREZWZpbml0aW9uKVxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvZGUnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICB0ZXh0OiBub2RlLnZhbHVlXG4gICAgICAgICAgfV1cbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICBjaGlsZHJlbjogZGVzZXJpYWxpemVDaGlsZHJlbihub2RlLmNoaWxkcmVuLCBnZXREZWZpbml0aW9uKVxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgbGV2ZWw6IG5vZGUuZGVwdGgsXG4gICAgICAgICAgY2hpbGRyZW46IGRlc2VyaWFsaXplQ2hpbGRyZW4obm9kZS5jaGlsZHJlbiwgZ2V0RGVmaW5pdGlvbilcbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICBjYXNlICdsaXN0JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdHlwZTogbm9kZS5vcmRlcmVkID8gJ29yZGVyZWQtbGlzdCcgOiAndW5vcmRlcmVkLWxpc3QnLFxuICAgICAgICAgIGNoaWxkcmVuOiBkZXNlcmlhbGl6ZUNoaWxkcmVuKG5vZGUuY2hpbGRyZW4sIGdldERlZmluaXRpb24pXG4gICAgICAgIH1dO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW1hZ2VSZWZlcmVuY2UnOlxuICAgICAge1xuICAgICAgICB2YXIgX2dldERlZmluaXRpb24yO1xuXG4gICAgICAgIHJldHVybiBbZ2V0VGV4dE5vZGVGb3JDdXJyZW50bHlBY3RpdmVNYXJrcyhgIVske25vZGUuYWx0IHx8ICcnfV0oJHsoKF9nZXREZWZpbml0aW9uMiA9IGdldERlZmluaXRpb24obm9kZS5pZGVudGlmaWVyKSkgPT09IG51bGwgfHwgX2dldERlZmluaXRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RGVmaW5pdGlvbjIudXJsKSB8fCAnJ30pYCldO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW2dldFRleHROb2RlRm9yQ3VycmVudGx5QWN0aXZlTWFya3MoYCFbJHtub2RlLmFsdCB8fCAnJ31dKCR7bm9kZS51cmx9KWApXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2xpc3RJdGVtJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdHlwZTogJ2xpc3QtaXRlbScsXG4gICAgICAgICAgY2hpbGRyZW46IGRlc2VyaWFsaXplQ2hpbGRyZW4obm9kZS5jaGlsZHJlbiwgZ2V0RGVmaW5pdGlvbilcbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICBjYXNlICd0aGVtYXRpY0JyZWFrJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgdHlwZTogJ2RpdmlkZXInLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9XVxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtnZXRUZXh0Tm9kZUZvckN1cnJlbnRseUFjdGl2ZU1hcmtzKCdcXG4nKV07XG4gICAgICB9XG5cbiAgICBjYXNlICdkZWxldGUnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ3N0cmlrZXRocm91Z2gnLCAoKSA9PiBkZXNlcmlhbGl6ZUNoaWxkcmVuKG5vZGUuY2hpbGRyZW4sIGdldERlZmluaXRpb24pKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignYm9sZCcsICgpID0+IGRlc2VyaWFsaXplQ2hpbGRyZW4obm9kZS5jaGlsZHJlbiwgZ2V0RGVmaW5pdGlvbikpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZW1waGFzaXMnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ2l0YWxpYycsICgpID0+IGRlc2VyaWFsaXplQ2hpbGRyZW4obm9kZS5jaGlsZHJlbiwgZ2V0RGVmaW5pdGlvbikpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5saW5lQ29kZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignY29kZScsICgpID0+IFtnZXRUZXh0Tm9kZUZvckN1cnJlbnRseUFjdGl2ZU1hcmtzKG5vZGUudmFsdWUpXSk7XG4gICAgICB9XG4gICAgLy8gd2hpbGUgaXQgd291bGQgYmUgbmljZSBpZiB3ZSBwYXJzZWQgdGhlIGh0bWwgaGVyZVxuICAgIC8vIGl0J3MgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIGp1c3QgcGFyc2luZyB0aGUgaHRtbFxuICAgIC8vIGJlY2F1c2UgYW4gaHRtbCBub2RlIG1pZ2h0IGp1c3QgYmUgYW4gb3BlbmluZy9jbG9zaW5nIG5vZGVcbiAgICAvLyBidXQgd2UganVzdCBoYXZlIGFuIG9wZW5pbmcvY2xvc2luZyBub2RlIGhlcmVcbiAgICAvLyBub3QgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYW5kIGNoaWxkcmVuXG5cbiAgICBjYXNlICdodG1sJzpcbiAgICBjYXNlICd0ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtnZXRUZXh0Tm9kZUZvckN1cnJlbnRseUFjdGl2ZU1hcmtzKG5vZGUudmFsdWUpXTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnRCdXREaWZmZXJlbnQoZWRpdG9yLCBub2Rlcykge1xuICBpZiAoc2xhdGUuRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBub2Rlc1swXSkpIHtcbiAgICBpbnNlcnROb2Rlc0J1dFJlcGxhY2VJZlNlbGVjdGlvbklzQXRFbXB0eVBhcmFncmFwaE9ySGVhZGluZyhlZGl0b3IsIG5vZGVzKTtcbiAgfSBlbHNlIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgbm9kZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhQYXN0aW5nKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0RGF0YSxcbiAgICBzZXRGcmFnbWVudERhdGFcbiAgfSA9IGVkaXRvcjtcblxuICBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGRhdGEuc2V0RGF0YSgnYXBwbGljYXRpb24veC1rZXlzdG9uZS1kb2N1bWVudC1lZGl0b3InLCAndHJ1ZScpO1xuICAgIH1cblxuICAgIHNldEZyYWdtZW50RGF0YShkYXRhKTtcbiAgfTtcblxuICBlZGl0b3IuaW5zZXJ0RGF0YSA9IGRhdGEgPT4ge1xuICAgIC8vIHRoaXMgZXhpc3RzIGJlY2F1c2UgYmVoaW5kIHRoZSBzY2VuZXMsIFNsYXRlIHNldHMgdGhlIHNsYXRlIGRvY3VtZW50XG4gICAgLy8gb24gdGhlIGRhdGEgdHJhbnNmZXIsIHRoaXMgaXMgZ3JlYXQgYmVjYXVzZSBpdCBtZWFucyB3aGVuIHlvdSBjb3B5IGFuZCBwYXN0ZVxuICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgZWRpdG9yIG9yIGJldHdlZW4gZWRpdG9ycywgaXQnbGwgdXNlIHRoZSBhY3R1YWwgU2xhdGUgZGF0YVxuICAgIC8vIHJhdGhlciB0aGFuIHRoZSBzZXJpYWxpemVkIGh0bWwgc28gY29tcG9uZW50IGJsb2NrcyBhbmQgZXRjLiB3aWxsIHdvcmsgZmluZVxuICAgIC8vIHdlJ3JlIHNldHRpbmcgYXBwbGljYXRpb24veC1rZXlzdG9uZS1kb2N1bWVudC1lZGl0b3JcbiAgICAvLyB0aG91Z2ggc28gdGhhdCB3ZSBvbmx5IGFjY2VwdCBzbGF0ZSBkYXRhIGZyb20gS2V5c3RvbmUncyBlZGl0b3JcbiAgICAvLyBiZWNhdXNlIG90aGVyIGVkaXRvcnMgd2lsbCBsaWtlbHkgaGF2ZSBhIGRpZmZlcmVudCBzdHJ1Y3R1cmVcbiAgICAvLyBzbyB3ZSdsbCByZWx5IG9uIHRoZSBodG1sIGRlc2VyaWFsaXphdGlvbiBpbnN0ZWFkXG4gICAgLy8gKG5vdGUgdGhhdCB5ZXMsIHdlIGRvIGNhbGwgaW5zZXJ0RGF0YSBhdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAvLyB3aGljaCBpcyB3aGVyZSBTbGF0ZSdzIGxvZ2ljIHdpbGwgcnVuLCBpdCdsbCBuZXZlciBkbyBhbnl0aGluZyB0aGVyZSB0aG91Z2hcbiAgICAvLyBzaW5jZSBhbnl0aGluZyB0aGF0IHdpbGwgaGF2ZSBzbGF0ZSBkYXRhIHdpbGwgYWxzbyBoYXZlIHRleHQvaHRtbCB3aGljaCB3ZSBoYW5kbGVcbiAgICAvLyBiZWZvcmUgd2UgY2FsbCBpbnNlcnREYXRhKVxuICAgIC8vIFRPRE86IGhhbmRsZSB0aGUgY2FzZSBvZiBjb3B5aW5nIGJldHdlZW4gZWRpdG9ycyB3aXRoIGRpZmZlcmVudCBjb21wb25lbnRzIGJsb2Nrc1xuICAgIC8vIChyaWdodCBub3csIHRoaW5ncyB3aWxsIGJsb3cgdXAgaW4gbW9zdCBjYXNlcylcbiAgICBpZiAoZGF0YS5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWtleXN0b25lLWRvY3VtZW50LWVkaXRvcicpID09PSAndHJ1ZScpIHtcbiAgICAgIGluc2VydERhdGEoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tBYm92ZSA9IHNsYXRlLkVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBub2RlID0+IHNsYXRlLkVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSlcbiAgICB9KTtcblxuICAgIGlmICgoYmxvY2tBYm92ZSA9PT0gbnVsbCB8fCBibG9ja0Fib3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja0Fib3ZlWzBdLnR5cGUpID09PSAnY29kZScpIHtcbiAgICAgIGNvbnN0IHBsYWluID0gZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICBlZGl0b3IuaW5zZXJ0VGV4dChwbGFpbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZzQ29kZUVkaXRvckRhdGEgPSBkYXRhLmdldERhdGEoJ3ZzY29kZS1lZGl0b3ItZGF0YScpO1xuXG4gICAgaWYgKHZzQ29kZUVkaXRvckRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZzQ29kZURhdGEgPSBKU09OLnBhcnNlKHZzQ29kZUVkaXRvckRhdGEpO1xuXG4gICAgICAgIGlmICgodnNDb2RlRGF0YSA9PT0gbnVsbCB8fCB2c0NvZGVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2c0NvZGVEYXRhLm1vZGUpID09PSAnbWFya2Rvd24nIHx8ICh2c0NvZGVEYXRhID09PSBudWxsIHx8IHZzQ29kZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZzQ29kZURhdGEubW9kZSkgPT09ICdtZHgnKSB7XG4gICAgICAgICAgY29uc3QgcGxhaW4gPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgICAgICAgIGlmIChwbGFpbikge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkZXNlcmlhbGl6ZU1hcmtkb3duKHBsYWluKTtcbiAgICAgICAgICAgIGluc2VydEZyYWdtZW50QnV0RGlmZmVyZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGh0bWwgPSBkYXRhLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuXG4gICAgaWYgKGh0bWwpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZGVzZXJpYWxpemVIVE1MKGh0bWwpO1xuICAgICAgaW5zZXJ0RnJhZ21lbnRCdXREaWZmZXJlbnQoZWRpdG9yLCBmcmFnbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGxhaW4gPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmIChwbGFpbikge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkZXNlcmlhbGl6ZU1hcmtkb3duKHBsYWluKTtcbiAgICAgIGluc2VydEZyYWdtZW50QnV0RGlmZmVyZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc2VydERhdGEoZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuLyoqIEBqc3hSdW50aW1lIGNsYXNzaWMgKi9cbmNvbnN0IEhPVEtFWVMgPSB7XG4gICdtb2QrYic6ICdib2xkJyxcbiAgJ21vZCtpJzogJ2l0YWxpYycsXG4gICdtb2QrdSc6ICd1bmRlcmxpbmUnXG59O1xuY29uc3QgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gYSB3b3JrYXJvdW5kIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzQwNzIgaXMgbWVyZ2VkXG4vLyB0aGlzIGhhcyB0YWtlbiBhbiBhdmVyYWdlIGtleXByZXNzIGZyb20gfjQwLTUwbXMgdG8gfjIwLTMwbXMgaW4gZGV2XG5cbnNsYXRlLk5vZGUuaXNOb2RlTGlzdCA9IHZhbHVlID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IElTX05PREVfTElTVF9DQUNIRS5nZXQodmFsdWUpO1xuXG4gIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICBjb25zdCBpc05vZGVMaXN0ID0gdmFsdWUuZXZlcnkodmFsID0+IHNsYXRlLk5vZGUuaXNOb2RlKHZhbCkpO1xuICBJU19OT0RFX0xJU1RfQ0FDSEUuc2V0KHZhbHVlLCBpc05vZGVMaXN0KTtcbiAgcmV0dXJuIGlzTm9kZUxpc3Q7XG59O1xuXG5jb25zdCBJU19PUEVSQVRJT05fTElTVF9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7IC8vIHRoaXMgaGFzIHRha2VuIHBhc3RpbmcgYSBwcmV0dHkgbGFyZ2UgZG9jdW1lbnQgZnJvbSB+NSBzZWNvbmRzIHRvIH4zIHNlY29uZHMgaW4gZGV2XG5cbnNsYXRlLk9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QgPSB2YWx1ZSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBJU19PUEVSQVRJT05fTElTVF9DQUNIRS5nZXQodmFsdWUpO1xuXG4gIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICBjb25zdCBpc09wZXJhdGlvbkxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gc2xhdGUuT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbCkpO1xuICBJU19PUEVSQVRJT05fTElTVF9DQUNIRS5zZXQodmFsdWUsIGlzT3BlcmF0aW9uTGlzdCk7XG4gIHJldHVybiBpc09wZXJhdGlvbkxpc3Q7XG59O1xuXG5mdW5jdGlvbiBpc01hcmtBY3RpdmUoZWRpdG9yLCBtYXJrKSB7XG4gIGNvbnN0IG1hcmtzID0gc2xhdGUuRWRpdG9yLm1hcmtzKGVkaXRvcik7XG5cbiAgaWYgKG1hcmtzICE9PSBudWxsICYmIG1hcmtzICE9PSB2b2lkIDAgJiYgbWFya3NbbWFya10pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBzZWUgdGhlIHN0dWZmIGFib3V0IG1hcmtzIGluIHRvb2xiYXItc3RhdGUgZm9yIHdoeSB0aGlzIGlzIGhlcmVcblxuXG4gIGZvciAoY29uc3QgZW50cnkgb2Ygc2xhdGUuRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBzbGF0ZS5UZXh0LmlzVGV4dFxuICB9KSkge1xuICAgIGlmIChlbnRyeVswXVttYXJrXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBnZXRLZXlEb3duSGFuZGxlciA9IGVkaXRvciA9PiBldmVudCA9PiB7XG4gIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgZm9yIChjb25zdCBob3RrZXkgaW4gSE9US0VZUykge1xuICAgIGlmIChpc0hvdGtleV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBtYXJrID0gSE9US0VZU1tob3RrZXldO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSBpc01hcmtBY3RpdmUoZWRpdG9yLCBtYXJrKTtcblxuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHNsYXRlLkVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgbWFyayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGF0ZS5FZGl0b3IuYWRkTWFyayhlZGl0b3IsIG1hcmssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzSG90a2V5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSgnbW9kK1xcXFwnLCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICBjbGVhckZvcm1hdHRpbmcoZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNIb3RrZXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdtb2QraycsIGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgd3JhcExpbmsoZWRpdG9yLCAnJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHVubmVzdExpc3QoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdExpc3QoZWRpdG9yKTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC5rZXkgPT09ICdUYWInICYmIGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zdCBsYXlvdXRBcmVhID0gc2xhdGUuRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnbGF5b3V0LWFyZWEnXG4gICAgfSk7XG5cbiAgICBpZiAobGF5b3V0QXJlYSkge1xuICAgICAgY29uc3QgbGF5b3V0QXJlYVRvRW50ZXIgPSBldmVudC5zaGlmdEtleSA/IHNsYXRlLkVkaXRvci5iZWZvcmUoZWRpdG9yLCBsYXlvdXRBcmVhWzFdLCB7XG4gICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgIH0pIDogc2xhdGUuRWRpdG9yLmFmdGVyKGVkaXRvciwgbGF5b3V0QXJlYVsxXSwge1xuICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICB9KTtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICBhbmNob3I6IGxheW91dEFyZWFUb0VudGVyLFxuICAgICAgICBmb2N1czogbGF5b3V0QXJlYVRvRW50ZXJcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RWRpdG9yKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2NrcywgcmVsYXRpb25zaGlwcywgaXNTaGlmdFByZXNzZWRSZWYpIHtcbiAgcmV0dXJuIHdpdGhQYXN0aW5nKHdpdGhTb2Z0QnJlYWtzKGlzU2hpZnRQcmVzc2VkUmVmLCB3aXRoQmxvY2tzU2NoZW1hKHdpdGhMaW5rKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcywgd2l0aExpc3Qod2l0aEhlYWRpbmcod2l0aFJlbGF0aW9uc2hpcCh3aXRoSW5zZXJ0TWVudSh3aXRoQ29tcG9uZW50QmxvY2tzKGNvbXBvbmVudEJsb2NrcywgZG9jdW1lbnRGZWF0dXJlcywgcmVsYXRpb25zaGlwcywgd2l0aFBhcmFncmFwaHMod2l0aFNob3J0Y3V0cyh3aXRoRGl2aWRlcih3aXRoTGF5b3V0cyh3aXRoTWFya3MoZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCB3aXRoQ29kZUJsb2NrKHdpdGhCbG9ja01hcmtkb3duU2hvcnRjdXRzKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcywgd2l0aEJsb2NrcXVvdGUod2l0aERvY3VtZW50RmVhdHVyZXNOb3JtYWxpemF0aW9uKGRvY3VtZW50RmVhdHVyZXMsIHJlbGF0aW9uc2hpcHMsIHNsYXRlSGlzdG9yeS53aXRoSGlzdG9yeShzbGF0ZVJlYWN0LndpdGhSZWFjdChzbGF0ZS5jcmVhdGVFZGl0b3IoKSkpKSkpKSkpKSkpKSkpKSkpKSkpO1xufVxuZnVuY3Rpb24gRG9jdW1lbnRFZGl0b3Ioe1xuICBhdXRvRm9jdXMsXG4gIG9uQ2hhbmdlLFxuICB2YWx1ZSxcbiAgY29tcG9uZW50QmxvY2tzLFxuICByZWxhdGlvbnNoaXBzLFxuICBkb2N1bWVudEZlYXR1cmVzXG59KSB7XG4gIGNvbnN0IGlzU2hpZnRQcmVzc2VkUmVmID0gdXNlS2V5RG93blJlZignU2hpZnQnKTtcbiAgY29uc3Qge1xuICAgIGNvbG9ycyxcbiAgICBzcGFjaW5nXG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIGNvbnN0IFtleHBhbmRlZCwgc2V0RXhwYW5kZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBlZGl0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZURvY3VtZW50RWRpdG9yKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2NrcywgcmVsYXRpb25zaGlwcywgaXNTaGlmdFByZXNzZWRSZWYpLCBbZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCByZWxhdGlvbnNoaXBzLCBpc1NoaWZ0UHJlc3NlZFJlZl0pO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczogW3tcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgfSwgZXhwYW5kZWQgJiYge1xuICAgICAgYmFja2dyb3VuZDogY29sb3JzLmJhY2tncm91bmQsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAvLyByZXF1aXJlZCB0byBrZWVwIHRoZSB0b29sYmFyIHN0dWNrIGluIHBsYWNlXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgekluZGV4OiAxMDBcbiAgICB9XVxuICB9LCBjb3JlLmpzeChEb2N1bWVudEVkaXRvclByb3ZpZGVyLCB7XG4gICAgY29tcG9uZW50QmxvY2tzOiBjb21wb25lbnRCbG9ja3MsXG4gICAgZG9jdW1lbnRGZWF0dXJlczogZG9jdW1lbnRGZWF0dXJlcyxcbiAgICByZWxhdGlvbnNoaXBzOiByZWxhdGlvbnNoaXBzLFxuICAgIGVkaXRvcjogZWRpdG9yLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvbkNoYW5nZTogdmFsdWUgPT4ge1xuICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHZhbHVlKTsgLy8gdGhpcyBmaXhlcyBhIHN0cmFuZ2UgaXNzdWUgaW4gU2FmYXJpIHdoZXJlIHRoZSBzZWxlY3Rpb24gc3RheXMgaW5zaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgIC8vIGFmdGVyIGEgYmx1ciBldmVudCBoYXBwZW5zIGJ1dCB0aGUgc2VsZWN0aW9uIGlzIHN0aWxsIGluIHRoZSBlZGl0b3JcbiAgICAgIC8vIHNvIHRoZSBjdXJzb3IgaXMgdmlzdWFsbHkgaW4gdGhlIHdyb25nIHBsYWNlIGFuZCBpdCBpbnNlcnRzIHRleHQgYmFja3dhcmRzXG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBlZGl0b3JOb2RlID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gZWRpdG9yTm9kZSkge1xuICAgICAgICAgIHNsYXRlUmVhY3QuUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgUmVhY3QudXNlTWVtbygoKSA9PiBjb3JlLmpzeChUb29sYmFyLCB7XG4gICAgZG9jdW1lbnRGZWF0dXJlczogZG9jdW1lbnRGZWF0dXJlcyxcbiAgICB2aWV3U3RhdGU6IHtcbiAgICAgIGV4cGFuZGVkLFxuICAgICAgdG9nZ2xlOiAoKSA9PiB7XG4gICAgICAgIHNldEV4cGFuZGVkKHYgPT4gIXYpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtleHBhbmRlZCwgZG9jdW1lbnRGZWF0dXJlc10pLCBjb3JlLmpzeChEb2N1bWVudEVkaXRvckVkaXRhYmxlLCB7XG4gICAgY3NzOiBleHBhbmRlZCAmJiB7XG4gICAgICBtYXJnaW5MZWZ0OiBzcGFjaW5nLm1lZGl1bSxcbiAgICAgIG1hcmdpblJpZ2h0OiBzcGFjaW5nLm1lZGl1bVxuICAgIH0sXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgcmVhZE9ubHk6IG9uQ2hhbmdlID09PSB1bmRlZmluZWRcbiAgfSksIC8vIGZvciBkZWJ1Z2dpbmdcbiAgZmFsc2UgKSk7XG59XG5mdW5jdGlvbiBEb2N1bWVudEVkaXRvclByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGVkaXRvcixcbiAgb25DaGFuZ2UsXG4gIHZhbHVlLFxuICBjb21wb25lbnRCbG9ja3MsXG4gIGRvY3VtZW50RmVhdHVyZXMsXG4gIHJlbGF0aW9uc2hpcHNcbn0pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBjb25zdCBpZGVudGl0eSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNiksIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNvcmUuanN4KHNsYXRlUmVhY3QuU2xhdGUgLy8gdGhpcyBmaXhlcyBpc3N1ZXMgd2l0aCBTbGF0ZSBjcmFzaGluZyB3aGVuIGEgZmFzdCByZWZyZXNoIG9jY2N1cnNcbiAgLCB7XG4gICAga2V5OiBpZGVudGl0eSxcbiAgICBlZGl0b3I6IGVkaXRvcixcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb25DaGFuZ2U6IHZhbHVlID0+IHtcbiAgICAgIG9uQ2hhbmdlKHZhbHVlKTsgLy8gdGhpcyBmaXhlcyBhIHN0cmFuZ2UgaXNzdWUgaW4gU2FmYXJpIHdoZXJlIHRoZSBzZWxlY3Rpb24gc3RheXMgaW5zaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgIC8vIGFmdGVyIGEgYmx1ciBldmVudCBoYXBwZW5zIGJ1dCB0aGUgc2VsZWN0aW9uIGlzIHN0aWxsIGluIHRoZSBlZGl0b3JcbiAgICAgIC8vIHNvIHRoZSBjdXJzb3IgaXMgdmlzdWFsbHkgaW4gdGhlIHdyb25nIHBsYWNlIGFuZCBpdCBpbnNlcnRzIHRleHQgYmFja3dhcmRzXG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhc2xhdGVSZWFjdC5SZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBlZGl0b3JOb2RlID0gc2xhdGVSZWFjdC5SZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gZWRpdG9yTm9kZSkge1xuICAgICAgICAgIHNsYXRlUmVhY3QuUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgY29yZS5qc3goVG9vbGJhclN0YXRlUHJvdmlkZXIsIHtcbiAgICBjb21wb25lbnRCbG9ja3M6IGNvbXBvbmVudEJsb2NrcyxcbiAgICBlZGl0b3JEb2N1bWVudEZlYXR1cmVzOiBkb2N1bWVudEZlYXR1cmVzLFxuICAgIHJlbGF0aW9uc2hpcHM6IHJlbGF0aW9uc2hpcHNcbiAgfSwgY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIERvY3VtZW50RWRpdG9yRWRpdGFibGUoe1xuICBhdXRvRm9jdXMsXG4gIHJlYWRPbmx5LFxuICBjbGFzc05hbWVcbn0pIHtcbiAgY29uc3QgZWRpdG9yID0gc2xhdGVSZWFjdC51c2VTbGF0ZSgpO1xuICBjb25zdCBjb21wb25lbnRCbG9ja3MgPSBSZWFjdC51c2VDb250ZXh0KENvbXBvbmVudEJsb2NrQ29udGV4dCk7XG4gIGNvbnN0IG9uS2V5RG93biA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0S2V5RG93bkhhbmRsZXIoZWRpdG9yKSwgW2VkaXRvcl0pO1xuICByZXR1cm4gY29yZS5qc3goc2xhdGVSZWFjdC5FZGl0YWJsZSwge1xuICAgIGRlY29yYXRlOiBSZWFjdC51c2VDYWxsYmFjaygoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcblxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNsYXRlLkVsZW1lbnQuaXNFbGVtZW50KG5vZGUuY2hpbGRyZW5bMF0pICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcgJiYgbm9kZS5jaGlsZHJlblswXS5wcm9wUGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoc2xhdGUuTm9kZS5zdHJpbmcoY2hpbGQpID09PSAnJyAmJiBzbGF0ZS5FbGVtZW50LmlzRWxlbWVudChjaGlsZCkgJiYgKGNoaWxkLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgfHwgY2hpbGQudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpICYmIGNoaWxkLnByb3BQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc2xhdGUuRWRpdG9yLnN0YXJ0KGVkaXRvciwgWy4uLnBhdGgsIGluZGV4XSk7XG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyVGV4dEZvclByb3BQYXRoKGNoaWxkLnByb3BQYXRoLCBjb21wb25lbnRCbG9ja3Nbbm9kZS5jb21wb25lbnRdLnByb3BzLCBub2RlLnByb3BzKTtcblxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgICAgICAgICAgZm9jdXM6IHN0YXJ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvcmF0aW9ucztcbiAgICB9LCBbZWRpdG9yLCBjb21wb25lbnRCbG9ja3NdKSxcbiAgICBjc3M6IHN0eWxlcyxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pO1xufVxuXG5jb25zdCBvcmRlcmVkTGlzdFN0eWxlcyA9IFsnbG93ZXItcm9tYW4nLCAnZGVjaW1hbCcsICdsb3dlci1hbHBoYSddO1xuY29uc3QgdW5vcmRlcmVkTGlzdFN0eWxlcyA9IFsnc3F1YXJlJywgJ2Rpc2MnLCAnY2lyY2xlJ107XG5sZXQgc3R5bGVzID0ge1xuICBmbGV4OiAxXG59O1xubGV0IGxpc3REZXB0aCA9IDEwO1xuXG53aGlsZSAobGlzdERlcHRoLS0pIHtcbiAgbGV0IGFyciA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogbGlzdERlcHRoXG4gIH0pO1xuXG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgc3R5bGVzW2Fyci5tYXAoKCkgPT4gYG9sYCkuam9pbignICcpXSA9IHtcbiAgICAgIGxpc3RTdHlsZTogb3JkZXJlZExpc3RTdHlsZXNbbGlzdERlcHRoICUgM11cbiAgICB9O1xuICAgIHN0eWxlc1thcnIubWFwKCgpID0+IGB1bGApLmpvaW4oJyAnKV0gPSB7XG4gICAgICBsaXN0U3R5bGU6IHVub3JkZXJlZExpc3RTdHlsZXNbbGlzdERlcHRoICUgM11cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VFZGl0b3JTY2hlbWEob2JqKSB7XG4gIGxldCByZXQgPSB7fTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsLmtpbmQgPT09ICdibG9ja3MnKSB7XG4gICAgICByZXRba2V5XSA9IHtcbiAgICAgICAga2luZDogJ2Jsb2NrcycsXG4gICAgICAgIGFsbG93ZWRDaGlsZHJlbjogbmV3IFNldCh2YWwuYWxsb3dlZENoaWxkcmVuKSxcbiAgICAgICAgYmxvY2tUb1dyYXBJbmxpbmVzSW46IHZhbC5hbGxvd2VkQ2hpbGRyZW5bMF0sXG4gICAgICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6IHZhbC5pbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBibG9ja3F1b3RlQ2hpbGRyZW4gPSBbJ3BhcmFncmFwaCcsICdjb2RlJywgJ2hlYWRpbmcnLCAnb3JkZXJlZC1saXN0JywgJ3Vub3JkZXJlZC1saXN0JywgJ2RpdmlkZXInXTtcbmNvbnN0IHBhcmFncmFwaExpa2UgPSBbLi4uYmxvY2txdW90ZUNoaWxkcmVuLCAnYmxvY2txdW90ZSddO1xuY29uc3QgaW5zaWRlT2ZMYXlvdXRzID0gWy4uLnBhcmFncmFwaExpa2UsICdjb21wb25lbnQtYmxvY2snXTtcbmNvbnN0IGVkaXRvclNjaGVtYSA9IG1ha2VFZGl0b3JTY2hlbWEoe1xuICBlZGl0b3I6IHtcbiAgICBraW5kOiAnYmxvY2tzJyxcbiAgICBhbGxvd2VkQ2hpbGRyZW46IFsuLi5pbnNpZGVPZkxheW91dHMsICdsYXlvdXQnXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xheW91dC1hcmVhJ10sXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnXG4gIH0sXG4gICdsYXlvdXQtYXJlYSc6IHtcbiAgICBraW5kOiAnYmxvY2tzJyxcbiAgICBhbGxvd2VkQ2hpbGRyZW46IGluc2lkZU9mTGF5b3V0cyxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9LFxuICBibG9ja3F1b3RlOiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBibG9ja3F1b3RlQ2hpbGRyZW4sXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnXG4gIH0sXG4gIHBhcmFncmFwaDoge1xuICAgIGtpbmQ6ICdpbmxpbmVzJyxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9LFxuICBjb2RlOiB7XG4gICAga2luZDogJ2lubGluZXMnLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9LFxuICBkaXZpZGVyOiB7XG4gICAga2luZDogJ2lubGluZXMnLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9LFxuICBoZWFkaW5nOiB7XG4gICAga2luZDogJ2lubGluZXMnLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0sXG4gICdjb21wb25lbnQtYmxvY2snOiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2NvbXBvbmVudC1ibG9jay1wcm9wJywgJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9LFxuICAnY29tcG9uZW50LWlubGluZS1wcm9wJzoge1xuICAgIGtpbmQ6ICdpbmxpbmVzJyxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9LFxuICAnY29tcG9uZW50LWJsb2NrLXByb3AnOiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBwYXJhZ3JhcGhMaWtlLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0sXG4gICdvcmRlcmVkLWxpc3QnOiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbSddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9LFxuICAndW5vcmRlcmVkLWxpc3QnOiB7XG4gICAga2luZDogJ2Jsb2NrcycsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbSddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9LFxuICAnbGlzdC1pdGVtJzoge1xuICAgIGtpbmQ6ICdibG9ja3MnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogWydsaXN0LWl0ZW0tY29udGVudCcsICdvcmRlcmVkLWxpc3QnLCAndW5vcmRlcmVkLWxpc3QnXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9LFxuICAnbGlzdC1pdGVtLWNvbnRlbnQnOiB7XG4gICAga2luZDogJ2lubGluZXMnLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3aXRoQmxvY2tzU2NoZW1hKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuXG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgIGlmICghc2xhdGUuVGV4dC5pc1RleHQobm9kZSkgJiYgbm9kZS50eXBlICE9PSAnbGluaycgJiYgbm9kZS50eXBlICE9PSAncmVsYXRpb25zaGlwJykge1xuICAgICAgY29uc3Qgbm9kZVR5cGUgPSBzbGF0ZS5FZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyAnZWRpdG9yJyA6IG5vZGUudHlwZTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlVHlwZSAhPT0gJ3N0cmluZycgfHwgZWRpdG9yU2NoZW1hW25vZGVUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5mbyA9IGVkaXRvclNjaGVtYVtub2RlVHlwZV07XG5cbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IFsuLi5wYXRoLCBpbmRleF07XG5cbiAgICAgICAgaWYgKGluZm8ua2luZCA9PT0gJ2lubGluZXMnKSB7XG4gICAgICAgICAgaWYgKCFzbGF0ZS5UZXh0LmlzVGV4dChjaGlsZE5vZGUpICYmICFzbGF0ZS5FZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlSW5JbnZhbGlkUG9zaXRpb24oZWRpdG9yLCBbY2hpbGROb2RlLCBjaGlsZFBhdGhdLCBwYXRoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzbGF0ZS5FZGl0b3IuaXNCbG9jayhlZGl0b3IsIGNoaWxkTm9kZSkgfHwgLy8gdGhlc2UgY2hlY2tzIGFyZSBpbXBsaWNpdCBpbiBFZGl0b3IuaXNCbG9ja1xuICAgICAgICAgIC8vIGJ1dCB0aGF0IGlzbid0IGVuY29kZWQgaW4gdHlwZXMgc28gdGhlc2Ugd2lsbCBtYWtlIFRTIGhhcHB5XG4gICAgICAgICAgY2hpbGROb2RlLnR5cGUgPT09ICdsaW5rJyB8fCBjaGlsZE5vZGUudHlwZSA9PT0gJ3JlbGF0aW9uc2hpcCcpIHtcbiAgICAgICAgICAgIHNsYXRlLlRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICB0eXBlOiBpbmZvLmJsb2NrVG9XcmFwSW5saW5lc0luLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbmZvLmFsbG93ZWRDaGlsZHJlbi5oYXMoY2hpbGROb2RlLnR5cGUpKSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlSW5JbnZhbGlkUG9zaXRpb24oZWRpdG9yLCBbY2hpbGROb2RlLCBjaGlsZFBhdGhdLCBwYXRoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVOb2RlKFtub2RlLCBwYXRoXSk7XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTm9kZUluSW52YWxpZFBvc2l0aW9uKGVkaXRvciwgW25vZGUsIHBhdGhdLCBwYXJlbnRQYXRoKSB7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuICBjb25zdCBjaGlsZE5vZGVJbmZvID0gZWRpdG9yU2NoZW1hW25vZGVUeXBlXTtcblxuICBpZiAoIWNoaWxkTm9kZUluZm8gfHwgY2hpbGROb2RlSW5mby5pbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlID09PSAndW53cmFwJykge1xuICAgIHNsYXRlLlRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyB0aGUgcGFyZW50IG9mIGEgYmxvY2sgd2lsbCBuZXZlciBiZSBhbiBpbmxpbmUgc28gdGhpcyBjYXN0aW5nIGlzIG9rYXlcblxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBzbGF0ZS5Ob2RlLmdldChlZGl0b3IsIHBhcmVudFBhdGgpO1xuICBjb25zdCBpbmZvID0gZWRpdG9yU2NoZW1hW3BhcmVudE5vZGUudHlwZSB8fCAnZWRpdG9yJ107XG5cbiAgaWYgKChpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8ua2luZCkgPT09ICdibG9ja3MnICYmIGluZm8uYWxsb3dlZENoaWxkcmVuLmhhcyhub2RlVHlwZSkpIHtcbiAgICBpZiAocGFyZW50UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHNsYXRlLlRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIHRvOiBzbGF0ZS5QYXRoLm5leHQocGFyZW50UGF0aClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzbGF0ZS5FZGl0b3IuaXNFZGl0b3IocGFyZW50Tm9kZSkpIHtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICBzbGF0ZS5UcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBoYW5kbGVOb2RlSW5JbnZhbGlkUG9zaXRpb24oZWRpdG9yLCBbbm9kZSwgcGF0aF0sIHBhcmVudFBhdGguc2xpY2UoMCwgLTEpKTtcbn0gLy8gdG8gcHJpbnQgdGhlIGVkaXRvciBzY2hlbWEgaW4gR3JhcGh2aXogaWYgeW91IHdhbnQgdG8gdmlzdWFsaXplIGl0XG4vLyBmdW5jdGlvbiBwcmludEVkaXRvclNjaGVtYShlZGl0b3JTY2hlbWE6IEVkaXRvclNjaGVtYSkge1xuLy8gICByZXR1cm4gYGRpZ3JhcGggRyB7XG4vLyAgIGNvbmNlbnRyYXRlPXRydWU7XG4vLyAgICR7T2JqZWN0LmtleXMoZWRpdG9yU2NoZW1hKVxuLy8gICAgIC5tYXAoa2V5ID0+IHtcbi8vICAgICAgIGxldCB2YWwgPSBlZGl0b3JTY2hlbWFba2V5XTtcbi8vICAgICAgIGlmICh2YWwua2luZCA9PT0gJ2lubGluZXMnKSB7XG4vLyAgICAgICAgIHJldHVybiBgXCIke2tleX1cIiAtPiBpbmxpbmVzYDtcbi8vICAgICAgIH1cbi8vICAgICAgIGlmICh2YWwua2luZCA9PT0gJ2Jsb2NrcycpIHtcbi8vICAgICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiIC0+IHske1suLi52YWwuYWxsb3dlZENoaWxkcmVuXS5tYXAoeCA9PiBKU09OLnN0cmluZ2lmeSh4KSkuam9pbignICcpfX1gO1xuLy8gICAgICAgfVxuLy8gICAgIH0pXG4vLyAgICAgLmpvaW4oJ1xcbiAgJyl9XG4vLyB9YDtcbi8vIH1cblxuZXhwb3J0cy5Eb2N1bWVudEVkaXRvciA9IERvY3VtZW50RWRpdG9yO1xuZXhwb3J0cy5Gb3JjZVZhbGlkYXRpb25Qcm92aWRlciA9IEZvcmNlVmFsaWRhdGlvblByb3ZpZGVyO1xuZXhwb3J0cy5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuZXhwb3J0cy5jbGllbnRTaWRlVmFsaWRhdGVQcm9wID0gY2xpZW50U2lkZVZhbGlkYXRlUHJvcDtcbmV4cG9ydHMuY3JlYXRlRG9jdW1lbnRFZGl0b3IgPSBjcmVhdGVEb2N1bWVudEVkaXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG52YXIgX29iamVjdFNwcmVhZCA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMicpO1xudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wiaXNSZWxhdGl2ZVwiXTtcbmNvbnN0IElubGluZURpYWxvZyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICBpc1JlbGF0aXZlXG4gIH0gPSBfcmVmLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuXG4gIGNvbnN0IHtcbiAgICByYWRpaSxcbiAgICBzcGFjaW5nXG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIGNvbnN0IHJlbGF0aXZlU3R5bGVzID0gaXNSZWxhdGl2ZSA/IHtcbiAgICBsZWZ0OiAnNTAlJyxcbiAgICBtYXJnaW46IHNwYWNpbmcuc21hbGwsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSdcbiAgfSA6IHt9O1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgY3NzOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGJhY2tncm91bmQ6ICd3aGl0ZScsXG4gICAgICBib3JkZXJSYWRpdXM6IHJhZGlpLnNtYWxsLFxuICAgICAgYm94U2hhZG93OiBgcmdiYSg5LCAzMCwgNjYsIDAuMzEpIDBweCAwcHggMXB4LCByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweGAsXG4gICAgICBwYWRkaW5nOiBzcGFjaW5nLnNtYWxsLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9LCByZWxhdGl2ZVN0eWxlcylcbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcImRpcmVjdGlvblwiXSxcbiAgICAgIF9leGNsdWRlZDIgPSBbXCJhc1wiLCBcImlzRGlzYWJsZWRcIiwgXCJpc1ByZXNzZWRcIiwgXCJpc1NlbGVjdGVkXCIsIFwidmFyaWFudFwiXTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBUb29sYmFyU3BhY2VyID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgc3BhY2luZ1xuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgd2lkdGg6IHNwYWNpbmcubGFyZ2VcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IFRvb2xiYXJTZXBhcmF0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZ1xuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGFsaWduU2VsZjogJ3N0cmV0Y2gnLFxuICAgICAgYmFja2dyb3VuZDogY29sb3JzLmJvcmRlcixcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogc3BhY2luZy54c21hbGwsXG4gICAgICBtYXJnaW5SaWdodDogc3BhY2luZy54c21hbGwsXG4gICAgICB3aWR0aDogMVxuICAgIH1cbiAgfSk7XG59OyAvLyBHcm91cHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhdXRvRmxvd0RpcmVjdGlvbiA9IHtcbiAgY29sdW1uOiAncm93JyxcbiAgcm93OiAnY29sdW1uJ1xufTtcbmNvbnN0IFRvb2xiYXJHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGRpcmVjdGlvbjogJ3Jvdydcbn0pO1xuXG5jb25zdCB1c2VUb29sYmFyR3JvdXBDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChUb29sYmFyR3JvdXBDb250ZXh0KTtcblxuY29uc3QgVG9vbGJhckdyb3VwID0gY29yZS5mb3J3YXJkUmVmV2l0aEFzKChfcmVmLCByZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkaXJlY3Rpb24gPSAncm93J1xuICB9ID0gX3JlZixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgY29uc3Qge1xuICAgIHNwYWNpbmdcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgcmV0dXJuIGNvcmUuanN4KFRvb2xiYXJHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgZGlyZWN0aW9uXG4gICAgfVxuICB9LCBjb3JlLmpzeChjb3JlLkJveCwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIGNzczoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ncmlkJyxcbiAgICAgIGdhcDogc3BhY2luZy54eHNtYWxsLFxuICAgICAgZ3JpZEF1dG9GbG93OiBhdXRvRmxvd0RpcmVjdGlvbltkaXJlY3Rpb25dXG4gICAgfVxuICB9LCBwcm9wcyksIGNoaWxkcmVuKSk7XG59KTsgLy8gQnV0dG9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFRvb2xiYXJCdXR0b24gPSBjb3JlLmZvcndhcmRSZWZXaXRoQXMoZnVuY3Rpb24gVG9vbGJhckJ1dHRvbihfcmVmMiwgcmVmKSB7XG4gIGxldCB7XG4gICAgYXM6IFRhZyA9ICdidXR0b24nLFxuICAgIGlzRGlzYWJsZWQsXG4gICAgaXNQcmVzc2VkLFxuICAgIGlzU2VsZWN0ZWQsXG4gICAgdmFyaWFudCA9ICdkZWZhdWx0J1xuICB9ID0gX3JlZjIsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgX2V4Y2x1ZGVkMik7XG5cbiAgY29uc3QgZXh0cmFQcm9wcyA9IHt9O1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uOiBncm91cERpcmVjdGlvblxuICB9ID0gdXNlVG9vbGJhckdyb3VwQ29udGV4dCgpO1xuICBjb25zdCB7XG4gICAgY29sb3JzLFxuICAgIHBhbGV0dGUsXG4gICAgcmFkaWksXG4gICAgc2l6aW5nLFxuICAgIHNwYWNpbmcsXG4gICAgdHlwb2dyYXBoeVxuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuXG4gIGlmIChUYWcgPT09ICdidXR0b24nKSB7XG4gICAgZXh0cmFQcm9wcy50eXBlID0gJ2J1dHRvbic7XG4gIH1cblxuICBjb25zdCB2YXJpYW50cyA9IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBiZ0hvdmVyOiBwYWxldHRlLm5ldXRyYWwyMDAsXG4gICAgICBiZ0FjdGl2ZTogcGFsZXR0ZS5uZXV0cmFsMzAwLFxuICAgICAgZmc6IHBhbGV0dGUubmV1dHJhbDgwMFxuICAgIH0sXG4gICAgYWN0aW9uOiB7XG4gICAgICBiZ0hvdmVyOiBwYWxldHRlLmJsdWU1MCxcbiAgICAgIGJnQWN0aXZlOiBwYWxldHRlLmJsdWUxMDAsXG4gICAgICBmZzogcGFsZXR0ZS5ibHVlNjAwXG4gICAgfSxcbiAgICBkZXN0cnVjdGl2ZToge1xuICAgICAgYmdIb3ZlcjogcGFsZXR0ZS5yZWQ1MCxcbiAgICAgIGJnQWN0aXZlOiBwYWxldHRlLnJlZDEwMCxcbiAgICAgIGZnOiBwYWxldHRlLnJlZDYwMFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3R5bGUgPSB2YXJpYW50c1t2YXJpYW50XTtcbiAgcmV0dXJuIGNvcmUuanN4KFRhZywgX2V4dGVuZHMoe30sIGV4dHJhUHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICBcImRhdGEtcHJlc3NlZFwiOiBpc1ByZXNzZWQsXG4gICAgXCJkYXRhLXNlbGVjdGVkXCI6IGlzU2VsZWN0ZWQsXG4gICAgXCJkYXRhLWRpc3BsYXktbW9kZVwiOiBncm91cERpcmVjdGlvbixcbiAgICBjc3M6IHtcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGJvcmRlclJhZGl1czogcmFkaWkueHNtYWxsLFxuICAgICAgY29sb3I6IHN0eWxlLmZnLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmb250U2l6ZTogdHlwb2dyYXBoeS5mb250U2l6ZS5zbWFsbCxcbiAgICAgIGZvbnRXZWlnaHQ6IHR5cG9ncmFwaHkuZm9udFdlaWdodC5tZWRpdW0sXG4gICAgICBoZWlnaHQ6IHNpemluZy5tZWRpdW0sXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHN0eWxlLmJnSG92ZXJcbiAgICAgIH0sXG4gICAgICAnOmFjdGl2ZSc6IHtcbiAgICAgICAgYmFja2dyb3VuZDogc3R5bGUuYmdBY3RpdmVcbiAgICAgIH0sXG4gICAgICAnJjpkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IGNvbG9ycy5mb3JlZ3JvdW5kRGlzYWJsZWQsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSxcbiAgICAgICcmW2RhdGEtcHJlc3NlZD10cnVlXSc6IHtcbiAgICAgICAgYmFja2dyb3VuZDogc3R5bGUuYmdBY3RpdmVcbiAgICAgIH0sXG4gICAgICAnJltkYXRhLXNlbGVjdGVkPXRydWVdJzoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcnMuZm9yZWdyb3VuZE11dGVkLFxuICAgICAgICBjb2xvcjogY29sb3JzLmJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICAvLyBhbHRlcm5hdGUgc3R5bGVzIHdpdGhpbiBidXR0b24gZ3JvdXBcbiAgICAgICcmW2RhdGEtZGlzcGxheS1tb2RlPXJvd10nOiB7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nLnNtYWxsLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHNwYWNpbmcuc21hbGxcbiAgICAgIH0sXG4gICAgICAnJltkYXRhLWRpc3BsYXktbW9kZT1jb2x1bW5dJzoge1xuICAgICAgICBwYWRkaW5nTGVmdDogc3BhY2luZy5tZWRpdW0sXG4gICAgICAgIHBhZGRpbmdSaWdodDogc3BhY2luZy5tZWRpdW1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHByb3BzKSk7XG59KTtcbmZ1bmN0aW9uIEtleWJvYXJkSW5Ub29sdGlwKHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgdGhlbWUgPSBjb3JlLnVzZVRoZW1lKCk7XG4gIHJldHVybiBjb3JlLmpzeChcImtiZFwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBtYXJnaW46IDIsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nLnh4c21hbGwsXG4gICAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5mb3JlZ3JvdW5kLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5yYWRpaS54c21hbGwsXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLmJhY2tncm91bmQsXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlJ1xuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5leHBvcnRzLklubGluZURpYWxvZyA9IElubGluZURpYWxvZztcbmV4cG9ydHMuS2V5Ym9hcmRJblRvb2x0aXAgPSBLZXlib2FyZEluVG9vbHRpcDtcbmV4cG9ydHMuVG9vbGJhckJ1dHRvbiA9IFRvb2xiYXJCdXR0b247XG5leHBvcnRzLlRvb2xiYXJHcm91cCA9IFRvb2xiYXJHcm91cDtcbmV4cG9ydHMuVG9vbGJhclNlcGFyYXRvciA9IFRvb2xiYXJTZXBhcmF0b3I7XG5leHBvcnRzLlRvb2xiYXJTcGFjZXIgPSBUb29sYmFyU3BhY2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIHNsYXRlID0gcmVxdWlyZSgnc2xhdGUnKTtcbnZhciB3ZWFrTWVtb2l6ZSA9IHJlcXVpcmUoJ0BlbW90aW9uL3dlYWstbWVtb2l6ZScpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnLi4vLi4vZGlzdC9pbmRleC05YmEyZTVmMi5janMuZGV2LmpzJyk7XG52YXIgYXBpID0gcmVxdWlyZSgnLi4vLi4vZGlzdC9hcGktOTM0MzYwMjUuY2pzLmRldi5qcycpO1xucmVxdWlyZSgncmVhY3QnKTtcbnJlcXVpcmUoJ2lzLWhvdGtleScpO1xucmVxdWlyZSgnc2xhdGUtcmVhY3QnKTtcbnJlcXVpcmUoJ3NsYXRlLWhpc3RvcnknKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3BvcG92ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b29sdGlwJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTGlua0ljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9UcmFzaDJJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvRXh0ZXJuYWxMaW5rSWNvbicpO1xucmVxdWlyZSgnLi4vLi4vZGlzdC90b29sYmFyLTI3MDBkOTdjLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMicpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xucmVxdWlyZSgnQGtleXN0b25lLW5leHQva2V5c3RvbmUvYWRtaW4tdWkvY29udGV4dCcpO1xucmVxdWlyZSgnQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3JlbGF0aW9uc2hpcC92aWV3cy9SZWxhdGlvbnNoaXBTZWxlY3QnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9idXR0b24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Db2x1bW5zSWNvbicpO1xucmVxdWlyZSgnYXBwbHktcmVmJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQm9sZEljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9JdGFsaWNJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvUGx1c0ljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uRG93bkljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9NYXhpbWl6ZTJJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTWluaW1pemUySWNvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01vcmVIb3Jpem9udGFsSWNvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0NvZGVJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25MZWZ0SWNvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsaWduUmlnaHRJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25DZW50ZXJJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTWludXNJY29uJyk7XG5yZXF1aXJlKCdtYXRjaC1zb3J0ZXInKTtcbnJlcXVpcmUoJ3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkJyk7XG5yZXF1aXJlKCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKTtcbnJlcXVpcmUoJ21kYXN0LXV0aWwtZ2ZtLWF1dG9saW5rLWxpdGVyYWwvZnJvbS1tYXJrZG93bicpO1xucmVxdWlyZSgnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbCcpO1xucmVxdWlyZSgnbWRhc3QtdXRpbC1nZm0tc3RyaWtldGhyb3VnaC9mcm9tLW1hcmtkb3duJyk7XG5yZXF1aXJlKCdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoJyk7XG5yZXF1aXJlKCdtZGFzdC11dGlsLWRlZmluaXRpb25zJyk7XG5yZXF1aXJlKCdAYnJhaW50cmVlL3Nhbml0aXplLXVybCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIHdlYWtNZW1vaXplX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdCh3ZWFrTWVtb2l6ZSk7XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5jb25zdCBGaWVsZCA9ICh7XG4gIGZpZWxkLFxuICB2YWx1ZSxcbiAgb25DaGFuZ2UsXG4gIGF1dG9Gb2N1cyxcbiAgZm9yY2VWYWxpZGF0aW9uXG59KSA9PiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGNvcmUuanN4KGluZGV4LkZvcmNlVmFsaWRhdGlvblByb3ZpZGVyLCB7XG4gIHZhbHVlOiAhIWZvcmNlVmFsaWRhdGlvblxufSwgY29yZS5qc3goaW5kZXguRG9jdW1lbnRFZGl0b3IsIHtcbiAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gIHZhbHVlOiB2YWx1ZSxcbiAgb25DaGFuZ2U6IG9uQ2hhbmdlLFxuICBjb21wb25lbnRCbG9ja3M6IGZpZWxkLmNvbXBvbmVudEJsb2NrcyxcbiAgcmVsYXRpb25zaGlwczogZmllbGQucmVsYXRpb25zaGlwcyxcbiAgZG9jdW1lbnRGZWF0dXJlczogZmllbGQuZG9jdW1lbnRGZWF0dXJlc1xufSkpKTtcbmNvbnN0IENlbGwgPSAoKSA9PiB7XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGNvcmUuanN4KFwicHJlXCIsIG51bGwsIEpTT04uc3RyaW5naWZ5KGl0ZW1bZmllbGQucGF0aF0sIG51bGwsIDIpKSk7XG59O1xuY29uc3QgYWxsb3dlZEV4cG9ydHNPbkN1c3RvbVZpZXdzID0gWydjb21wb25lbnRCbG9ja3MnXTtcbmNvbnN0IGNvbnRyb2xsZXIgPSBjb25maWcgPT4ge1xuICBjb25zdCBtZW1vaXplZElzQ29tcG9uZW50QmxvY2tWYWxpZCA9IHdlYWtNZW1vaXplX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjb21wb25lbnRCbG9jayA9PiB3ZWFrTWVtb2l6ZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ocHJvcHMgPT4gaW5kZXguY2xpZW50U2lkZVZhbGlkYXRlUHJvcCh7XG4gICAga2luZDogJ29iamVjdCcsXG4gICAgdmFsdWU6IGNvbXBvbmVudEJsb2NrLnByb3BzXG4gIH0sIHByb3BzKSkpO1xuICBjb25zdCBjb21wb25lbnRCbG9ja3MgPSBjb25maWcuY3VzdG9tVmlld3MuY29tcG9uZW50QmxvY2tzIHx8IHt9O1xuICBjb25zdCBzZXJ2ZXJTaWRlQ29tcG9uZW50QmxvY2tzU2V0ID0gbmV3IFNldChjb25maWcuZmllbGRNZXRhLmNvbXBvbmVudEJsb2Nrc1Bhc3NlZE9uU2VydmVyKTtcbiAgY29uc3QgY29tcG9uZW50QmxvY2tzT25seUJlaW5nUGFzc2VkT25UaGVDbGllbnQgPSBPYmplY3Qua2V5cyhjb21wb25lbnRCbG9ja3MpLmZpbHRlcih4ID0+ICFzZXJ2ZXJTaWRlQ29tcG9uZW50QmxvY2tzU2V0Lmhhcyh4KSk7XG5cbiAgaWYgKGNvbXBvbmVudEJsb2Nrc09ubHlCZWluZ1Bhc3NlZE9uVGhlQ2xpZW50Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgKCR7Y29uZmlnLmxpc3RLZXl9OiR7Y29uZmlnLnBhdGh9KSBUaGUgZm9sbG93aW5nIGNvbXBvbmVudCBibG9ja3MgYXJlIGJlaW5nIHBhc3NlZCBpbiB0aGUgY3VzdG9tIHZpZXcgYnV0IG5vdCBpbiB0aGUgc2VydmVyLXNpZGUgZmllbGQgY29uZmlnOiAke0pTT04uc3RyaW5naWZ5KGNvbXBvbmVudEJsb2Nrc09ubHlCZWluZ1Bhc3NlZE9uVGhlQ2xpZW50KX1gKTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudFNpZGVDb21wb25lbnRCbG9ja3NTZXQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGNvbXBvbmVudEJsb2NrcykpO1xuICBjb25zdCBjb21wb25lbnRCbG9ja3NPbmx5QmVpbmdQYXNzZWRPblRoZVNlcnZlciA9IGNvbmZpZy5maWVsZE1ldGEuY29tcG9uZW50QmxvY2tzUGFzc2VkT25TZXJ2ZXIuZmlsdGVyKHggPT4gIWNsaWVudFNpZGVDb21wb25lbnRCbG9ja3NTZXQuaGFzKHgpKTtcblxuICBpZiAoY29tcG9uZW50QmxvY2tzT25seUJlaW5nUGFzc2VkT25UaGVTZXJ2ZXIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAoJHtjb25maWcubGlzdEtleX06JHtjb25maWcucGF0aH0pIFRoZSBmb2xsb3dpbmcgY29tcG9uZW50IGJsb2NrcyBhcmUgYmVpbmcgcGFzc2VkIGluIHRoZSBzZXJ2ZXItc2lkZSBmaWVsZCBjb25maWcgYnV0IG5vdCBpbiB0aGUgY3VzdG9tIHZpZXc6ICR7SlNPTi5zdHJpbmdpZnkoY29tcG9uZW50QmxvY2tzT25seUJlaW5nUGFzc2VkT25UaGVTZXJ2ZXIpfWApO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVOb2RlID0gd2Vha01lbW9pemVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKG5vZGUgPT4ge1xuICAgIGlmIChzbGF0ZS5UZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gY29tcG9uZW50QmxvY2tzW25vZGUuY29tcG9uZW50XTtcblxuICAgICAgaWYgKGNvbXBvbmVudEJsb2NrKSB7XG4gICAgICAgIGlmICghbWVtb2l6ZWRJc0NvbXBvbmVudEJsb2NrVmFsaWQoY29tcG9uZW50QmxvY2spKG5vZGUucHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnICYmICh0eXBlb2Ygbm9kZS5ocmVmICE9PSAnc3RyaW5nJyB8fCAhYXBpLmlzVmFsaWRVUkwobm9kZS5ocmVmKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5ldmVyeShub2RlID0+IHZhbGlkYXRlTm9kZShub2RlKSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgIGxhYmVsOiBjb25maWcubGFiZWwsXG4gICAgZ3JhcGhxbFNlbGVjdGlvbjogYCR7Y29uZmlnLnBhdGh9IHtkb2N1bWVudChoeWRyYXRlUmVsYXRpb25zaGlwczogdHJ1ZSl9YCxcbiAgICBjb21wb25lbnRCbG9ja3M6IGNvbmZpZy5jdXN0b21WaWV3cy5jb21wb25lbnRCbG9ja3MgfHwge30sXG4gICAgZG9jdW1lbnRGZWF0dXJlczogY29uZmlnLmZpZWxkTWV0YS5kb2N1bWVudEZlYXR1cmVzLFxuICAgIHJlbGF0aW9uc2hpcHM6IGNvbmZpZy5maWVsZE1ldGEucmVsYXRpb25zaGlwcyxcbiAgICBkZWZhdWx0VmFsdWU6IFt7XG4gICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfV1cbiAgICB9XSxcbiAgICBkZXNlcmlhbGl6ZTogZGF0YSA9PiB7XG4gICAgICB2YXIgX2RhdGEkY29uZmlnJHBhdGg7XG5cbiAgICAgIHJldHVybiAoKF9kYXRhJGNvbmZpZyRwYXRoID0gZGF0YVtjb25maWcucGF0aF0pID09PSBudWxsIHx8IF9kYXRhJGNvbmZpZyRwYXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRjb25maWckcGF0aC5kb2N1bWVudCkgfHwgW3tcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9XTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogdmFsdWUgPT4gKHtcbiAgICAgIFtjb25maWcucGF0aF06IHZhbHVlXG4gICAgfSksXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KG5vZGUgPT4gdmFsaWRhdGVOb2RlKG5vZGUpKTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbmV4cG9ydHMuQ2FyZFZhbHVlID0gQ2FyZFZhbHVlO1xuZXhwb3J0cy5DZWxsID0gQ2VsbDtcbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmV4cG9ydHMuYWxsb3dlZEV4cG9ydHNPbkN1c3RvbVZpZXdzID0gYWxsb3dlZEV4cG9ydHNPbkN1c3RvbVZpZXdzO1xuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQtZmllbGRzLWRvY3VtZW50LXZpZXdzLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZXlzdG9uZS1uZXh0LWZpZWxkcy1kb2N1bWVudC12aWV3cy5janMuZGV2LmpzXCIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIENlbGxDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9kaXN0L0NlbGxDb250YWluZXItNDUzMjU0YjUuY2pzLmRldi5qcycpO1xudmFyIENlbGxMaW5rID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZGlzdC9DZWxsTGluay1kYzQxYzg3Ny5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5Jyk7XG5yZXF1aXJlKCdyZWFjdCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2J1dHRvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsZXJ0VHJpYW5nbGVJY29uJyk7XG5yZXF1aXJlKCduZXh0L2xpbmsnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b2FzdCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9tb2RhbHMnKTtcbnJlcXVpcmUoJ2Fwb2xsby11cGxvYWQtY2xpZW50Jyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnJlcXVpcmUoJ0BlbW90aW9uL2hhc2gnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2Rpc3Qvc3FsaXRlLWFmOWU1MTQ4LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2Rpc3QvZ3JhcGhxbC10cy1zY2hlbWEtZmNlN2E2YTguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2Rpc3QvYWRtaW4tbWV0YS1ncmFwaHFsLTlmOWE5YzExLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpO1xucmVxdWlyZSgnbmV4dC9yb3V0ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9wb3BvdmVyJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTW9yZUhvcml6b250YWxJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ2hldnJvblJpZ2h0SWNvbicpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vZGlzdC9TaWdub3V0QnV0dG9uLWFjZGIxNTU0LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL25vdGljZScpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vYWRtaW4tdWkvcm91dGVyL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1hZG1pbi11aS1yb3V0ZXIuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnZGVjaW1hbC5qcycpO1xucmVxdWlyZSgnQGdyYXBocWwtdG9vbHMvc2NoZW1hJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGhvdXQtY29udGV4dCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hJyk7XG5yZXF1aXJlKCdncmFwaHFsLXR5cGUtanNvbicpO1xucmVxdWlyZSgnZ3JhcGhxbC11cGxvYWQvcHVibGljL0dyYXBoUUxVcGxvYWQuanMnKTtcbnJlcXVpcmUoJ2dyYXBocWwnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aC1jb250ZXh0Jyk7XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5jb25zdCBGaWVsZCA9ICgpID0+IG51bGw7XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGQsXG4gIGxpbmtUb1xufSkgPT4ge1xuICBsZXQgdmFsdWUgPSBpdGVtW2ZpZWxkLnBhdGhdICsgJyc7XG4gIHJldHVybiBsaW5rVG8gPyBjb3JlLmpzeChDZWxsTGluay5DZWxsTGluaywgbGlua1RvLCB2YWx1ZSkgOiBjb3JlLmpzeChDZWxsQ29udGFpbmVyLkNlbGxDb250YWluZXIsIG51bGwsIHZhbHVlKTtcbn07XG5DZWxsLnN1cHBvcnRzTGlua1RvID0gdHJ1ZTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGl0ZW1bZmllbGQucGF0aF0pO1xufTtcbmNvbnN0IGNvbnRyb2xsZXIgPSBjb25maWcgPT4ge1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgIGxhYmVsOiBjb25maWcubGFiZWwsXG4gICAgZ3JhcGhxbFNlbGVjdGlvbjogY29uZmlnLnBhdGgsXG4gICAgaWRGaWVsZEtpbmQ6IGNvbmZpZy5maWVsZE1ldGEua2luZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZXNlcmlhbGl6ZTogKCkgPT4ge30sXG4gICAgc2VyaWFsaXplOiAoKSA9PiAoe30pLFxuICAgIGZpbHRlcjoge1xuICAgICAgRmlsdGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmpzeChmaWVsZHMuVGV4dElucHV0LCB7XG4gICAgICAgICAgb25DaGFuZ2U6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICAgICAgYXV0b0ZvY3VzOiBwcm9wcy5hdXRvRm9jdXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBncmFwaHFsOiAoe1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ25vdCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgICBub3Q6IHtcbiAgICAgICAgICAgICAgICBlcXVhbHM6IHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWVXaXRob3V0V2hpdGVzcGFjZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGUgPT09ICdpcycgPyAnZXF1YWxzJyA6IHR5cGUgPT09ICdub3RfaW4nID8gJ25vdEluJyA6IHR5cGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgW2tleV06IFsnaW4nLCAnbm90X2luJ10uaW5jbHVkZXModHlwZSkgPyB2YWx1ZVdpdGhvdXRXaGl0ZXNwYWNlLnNwbGl0KCcsJykgOiB2YWx1ZVdpdGhvdXRXaGl0ZXNwYWNlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgTGFiZWwoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGVcbiAgICAgIH0pIHtcbiAgICAgICAgbGV0IHJlbmRlcmVkVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgICAgIGlmIChbJ2luJywgJ25vdF9pbiddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IHZhbHVlLnNwbGl0KCcsJykuam9pbignLCAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHtsYWJlbC50b0xvd2VyQ2FzZSgpfTogJHtyZW5kZXJlZFZhbHVlfWA7XG4gICAgICB9LFxuXG4gICAgICB0eXBlczoge1xuICAgICAgICBpczoge1xuICAgICAgICAgIGxhYmVsOiAnSXMgZXhhY3RseScsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBub3Q6IHtcbiAgICAgICAgICBsYWJlbDogJ0lzIG5vdCBleGFjdGx5JyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIGd0OiB7XG4gICAgICAgICAgbGFiZWw6ICdJcyBncmVhdGVyIHRoYW4nLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgbHQ6IHtcbiAgICAgICAgICBsYWJlbDogJ0lzIGxlc3MgdGhhbicsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBndGU6IHtcbiAgICAgICAgICBsYWJlbDogJ0lzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bycsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBsdGU6IHtcbiAgICAgICAgICBsYWJlbDogJ0lzIGxlc3MgdGhhbiBvciBlcXVhbCB0bycsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBpbjoge1xuICAgICAgICAgIGxhYmVsOiAnSXMgb25lIG9mJyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG5vdF9pbjoge1xuICAgICAgICAgIGxhYmVsOiAnSXMgbm90IG9uZSBvZicsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5DYXJkVmFsdWUgPSBDYXJkVmFsdWU7XG5leHBvcnRzLkNlbGwgPSBDZWxsO1xuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoLWFkbWluLXVpLWlkLWZpZWxkLXZpZXcuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoLWFkbWluLXVpLWlkLWZpZWxkLXZpZXcuY2pzLmRldi5qc1wiKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjb3JlJDEgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvY29yZScpO1xudmFyIHRvYXN0ID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL3RvYXN0Jyk7XG52YXIgbG9hZGluZyA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9sb2FkaW5nJyk7XG52YXIgbW9kYWxzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL21vZGFscycpO1xudmFyIGFwb2xsb1VwbG9hZENsaWVudCA9IHJlcXVpcmUoJ2Fwb2xsby11cGxvYWQtY2xpZW50Jyk7XG52YXIgX29iamVjdFNwcmVhZCA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMicpO1xudmFyIGhhc2hTdHJpbmcgPSByZXF1aXJlKCdAZW1vdGlvbi9oYXNoJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Rpc3QvY29yZS1jOGVjY2UyMy5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi9kaXN0L3NxbGl0ZS1hZjllNTE0OC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi9kaXN0L2dyYXBocWwtdHMtc2NoZW1hLWZjZTdhNmE4LmNqcy5kZXYuanMnKTtcbnZhciBjbGllbnQgPSByZXF1aXJlKCdAYXBvbGxvL2NsaWVudCcpO1xudmFyIGFkbWluTWV0YUdyYXBocWwgPSByZXF1aXJlKCcuLi8uLi8uLi9kaXN0L2FkbWluLW1ldGEtZ3JhcGhxbC05ZjlhOWMxMS5janMuZGV2LmpzJyk7XG52YXIgZGF0YUdldHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Rpc3QvZGF0YUdldHRlci05ZmJlMmY4ZS5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10b29scy9zY2hlbWEnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0Jyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEnKTtcbnJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG5yZXF1aXJlKCdncmFwaHFsLXVwbG9hZC9wdWJsaWMvR3JhcGhRTFVwbG9hZC5qcycpO1xucmVxdWlyZSgnZ3JhcGhxbCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIGhhc2hTdHJpbmdfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGhhc2hTdHJpbmcpO1xuXG5jb25zdCBleHBlY3RlZEV4cG9ydHMgPSBuZXcgU2V0KFsnQ2VsbCcsICdGaWVsZCcsICdjb250cm9sbGVyJywgJ0NhcmRWYWx1ZSddKTtcbmNvbnN0IGFkbWluTWV0YUxvY2FsU3RvcmFnZUtleSA9ICdrZXlzdG9uZS5hZG1pbk1ldGEnO1xubGV0IF9tdXN0UmVuZGVyU2VydmVyUmVzdWx0ID0gdHJ1ZTtcblxuZnVuY3Rpb24gdXNlTXVzdFJlbmRlclNlcnZlclJlc3VsdCgpIHtcbiAgbGV0IFssIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIF9tdXN0UmVuZGVyU2VydmVyUmVzdWx0ID0gZmFsc2U7XG4gICAgZm9yY2VVcGRhdGUoMSk7XG4gIH0sIFtdKTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfbXVzdFJlbmRlclNlcnZlclJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlQWRtaW5NZXRhKGFkbWluTWV0YUhhc2gsIGZpZWxkVmlld3MpIHtcbiAgY29uc3QgYWRtaW5NZXRhRnJvbUxvY2FsU3RvcmFnZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhZG1pbk1ldGFMb2NhbFN0b3JhZ2VLZXkpO1xuXG4gICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHBhcnNlZCA9IEpTT04ucGFyc2UoaXRlbSk7XG5cbiAgICAgIGlmIChwYXJzZWQuaGFzaCA9PT0gYWRtaW5NZXRhSGFzaCkge1xuICAgICAgICByZXR1cm4gcGFyc2VkLm1ldGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LCBbYWRtaW5NZXRhSGFzaF0pOyAvLyBpdCBzZWVtcyBsaWtlIEFwb2xsbyBkb2Vzbid0IHNraXAgdGhlIGZpcnN0IGZldGNoIHdoZW4gdXNpbmcgc2tpcDogdHJ1ZSBzbyB3ZSdyZSB1c2luZyB1c2VMYXp5UXVlcnkgaW5zdGVhZFxuXG4gIGNvbnN0IFtmZXRjaFN0YXRpY0FkbWluTWV0YSwge1xuICAgIGRhdGEsXG4gICAgZXJyb3IsXG4gICAgY2FsbGVkXG4gIH1dID0gY2xpZW50LnVzZUxhenlRdWVyeShhZG1pbk1ldGFHcmFwaHFsLnN0YXRpY0FkbWluTWV0YVF1ZXJ5LCB7XG4gICAgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknXG4gIH0pO1xuICBsZXQgc2hvdWxkRmV0Y2hBZG1pbk1ldGEgPSBhZG1pbk1ldGFGcm9tTG9jYWxTdG9yYWdlID09PSB1bmRlZmluZWQgJiYgIWNhbGxlZDtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkRmV0Y2hBZG1pbk1ldGEpIHtcbiAgICAgIGZldGNoU3RhdGljQWRtaW5NZXRhKCk7XG4gICAgfVxuICB9LCBbc2hvdWxkRmV0Y2hBZG1pbk1ldGEsIGZldGNoU3RhdGljQWRtaW5NZXRhXSk7XG4gIGNvbnN0IHJ1bnRpbWVBZG1pbk1ldGEgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoKCFkYXRhIHx8IGVycm9yKSAmJiAhYWRtaW5NZXRhRnJvbUxvY2FsU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBhZG1pbk1ldGEgPSBhZG1pbk1ldGFGcm9tTG9jYWxTdG9yYWdlID8gYWRtaW5NZXRhRnJvbUxvY2FsU3RvcmFnZSA6IGRhdGEua2V5c3RvbmUuYWRtaW5NZXRhO1xuICAgIGNvbnN0IHJ1bnRpbWVBZG1pbk1ldGEgPSB7XG4gICAgICBlbmFibGVTZXNzaW9uSXRlbTogYWRtaW5NZXRhLmVuYWJsZVNlc3Npb25JdGVtLFxuICAgICAgZW5hYmxlU2lnbm91dDogYWRtaW5NZXRhLmVuYWJsZVNpZ25vdXQsXG4gICAgICBsaXN0czoge31cbiAgICB9O1xuICAgIGFkbWluTWV0YS5saXN0cy5mb3JFYWNoKGxpc3QgPT4ge1xuICAgICAgcnVudGltZUFkbWluTWV0YS5saXN0c1tsaXN0LmtleV0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxpc3QpLCB7fSwge1xuICAgICAgICBncWxOYW1lczogY29yZS5nZXRHcWxOYW1lcyh7XG4gICAgICAgICAgbGlzdEtleTogbGlzdC5rZXksXG4gICAgICAgICAgcGx1cmFsR3JhcGhRTE5hbWU6IGxpc3QubGlzdFF1ZXJ5TmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgZmllbGRzOiB7fVxuICAgICAgfSk7XG4gICAgICBsaXN0LmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgdmFyIF9maWVsZCRpdGVtVmlldyRmaWVsZCwgX2ZpZWxkJGl0ZW1WaWV3O1xuXG4gICAgICAgIGV4cGVjdGVkRXhwb3J0cy5mb3JFYWNoKGV4cG9ydE5hbWUgPT4ge1xuICAgICAgICAgIGlmIChmaWVsZFZpZXdzW2ZpZWxkLnZpZXdzSW5kZXhdW2V4cG9ydE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZpZXcgZm9yIHRoZSBmaWVsZCBhdCAke2xpc3Qua2V5fS4ke2ZpZWxkLnBhdGh9IGlzIG1pc3NpbmcgdGhlICR7ZXhwb3J0TmFtZX0gZXhwb3J0YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMoZmllbGRWaWV3c1tmaWVsZC52aWV3c0luZGV4XSkuZm9yRWFjaChleHBvcnROYW1lID0+IHtcbiAgICAgICAgICBpZiAoIWV4cGVjdGVkRXhwb3J0cy5oYXMoZXhwb3J0TmFtZSkgJiYgZXhwb3J0TmFtZSAhPT0gJ2FsbG93ZWRFeHBvcnRzT25DdXN0b21WaWV3cycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBleHBvcnQgbmFtZWQgJHtleHBvcnROYW1lfSBmcm9tIHRoZSB2aWV3IGZyb20gdGhlIGZpZWxkIGF0ICR7bGlzdC5rZXl9LiR7ZmllbGQucGF0aH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZpZXdzID0gX29iamVjdFNwcmVhZCh7fSwgZmllbGRWaWV3c1tmaWVsZC52aWV3c0luZGV4XSk7XG5cbiAgICAgICAgY29uc3QgY3VzdG9tVmlld3MgPSB7fTtcblxuICAgICAgICBpZiAoZmllbGQuY3VzdG9tVmlld3NJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGN1c3RvbVZpZXdzU291cmNlID0gZmllbGRWaWV3c1tmaWVsZC5jdXN0b21WaWV3c0luZGV4XTtcbiAgICAgICAgICBjb25zdCBhbGxvd2VkRXhwb3J0c09uQ3VzdG9tVmlld3MgPSBuZXcgU2V0KHZpZXdzLmFsbG93ZWRFeHBvcnRzT25DdXN0b21WaWV3cyk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoY3VzdG9tVmlld3NTb3VyY2UpLmZvckVhY2goZXhwb3J0TmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZEV4cG9ydHNPbkN1c3RvbVZpZXdzLmhhcyhleHBvcnROYW1lKSkge1xuICAgICAgICAgICAgICBjdXN0b21WaWV3c1tleHBvcnROYW1lXSA9IGN1c3RvbVZpZXdzU291cmNlW2V4cG9ydE5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZEV4cG9ydHMuaGFzKGV4cG9ydE5hbWUpKSB7XG4gICAgICAgICAgICAgIHZpZXdzW2V4cG9ydE5hbWVdID0gY3VzdG9tVmlld3NTb3VyY2VbZXhwb3J0TmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXhwb3J0IG5hbWVkICR7ZXhwb3J0TmFtZX0gZnJvbSB0aGUgY3VzdG9tIHZpZXcgZnJvbSBmaWVsZCBhdCAke2xpc3Qua2V5fS4ke2ZpZWxkLnBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBydW50aW1lQWRtaW5NZXRhLmxpc3RzW2xpc3Qua2V5XS5maWVsZHNbZmllbGQucGF0aF0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGZpZWxkKSwge30sIHtcbiAgICAgICAgICBpdGVtVmlldzoge1xuICAgICAgICAgICAgZmllbGRNb2RlOiAoX2ZpZWxkJGl0ZW1WaWV3JGZpZWxkID0gKF9maWVsZCRpdGVtVmlldyA9IGZpZWxkLml0ZW1WaWV3KSA9PT0gbnVsbCB8fCBfZmllbGQkaXRlbVZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maWVsZCRpdGVtVmlldy5maWVsZE1vZGUpICE9PSBudWxsICYmIF9maWVsZCRpdGVtVmlldyRmaWVsZCAhPT0gdm9pZCAwID8gX2ZpZWxkJGl0ZW1WaWV3JGZpZWxkIDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmlld3MsXG4gICAgICAgICAgY29udHJvbGxlcjogZmllbGRWaWV3c1tmaWVsZC52aWV3c0luZGV4XS5jb250cm9sbGVyKHtcbiAgICAgICAgICAgIGxpc3RLZXk6IGxpc3Qua2V5LFxuICAgICAgICAgICAgZmllbGRNZXRhOiBmaWVsZC5maWVsZE1ldGEsXG4gICAgICAgICAgICBsYWJlbDogZmllbGQubGFiZWwsXG4gICAgICAgICAgICBwYXRoOiBmaWVsZC5wYXRoLFxuICAgICAgICAgICAgY3VzdG9tVmlld3NcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFhZG1pbk1ldGFGcm9tTG9jYWxTdG9yYWdlKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhZG1pbk1ldGFMb2NhbFN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgaGFzaDogaGFzaFN0cmluZ19fZGVmYXVsdFtcImRlZmF1bHRcIl0oSlNPTi5zdHJpbmdpZnkoYWRtaW5NZXRhKSksXG4gICAgICAgIG1ldGE6IGFkbWluTWV0YVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBydW50aW1lQWRtaW5NZXRhO1xuICB9LCBbZGF0YSwgZXJyb3IsIGFkbWluTWV0YUZyb21Mb2NhbFN0b3JhZ2UsIGZpZWxkVmlld3NdKTtcbiAgY29uc3QgbXVzdFJlbmRlclNlcnZlclJlc3VsdCA9IHVzZU11c3RSZW5kZXJTZXJ2ZXJSZXN1bHQoKTtcblxuICBpZiAobXVzdFJlbmRlclNlcnZlclJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogJ2xvYWRpbmcnXG4gICAgfTtcbiAgfVxuXG4gIGlmIChydW50aW1lQWRtaW5NZXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiAnbG9hZGVkJyxcbiAgICAgIHZhbHVlOiBydW50aW1lQWRtaW5NZXRhXG4gICAgfTtcbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogJ2Vycm9yJyxcbiAgICAgIGVycm9yLFxuICAgICAgcmVmZXRjaDogKCkgPT4ge1xuICAgICAgICBmZXRjaFN0YXRpY0FkbWluTWV0YSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiAnbG9hZGluZydcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTGF6eU1ldGFkYXRhKHF1ZXJ5KSB7XG4gIGxldCByZXN1bHQgPSBjbGllbnQudXNlUXVlcnkocXVlcnksIHtcbiAgICBlcnJvclBvbGljeTogJ2FsbCcsXG4gICAgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknXG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9yZXN1bHQkZXJyb3IsIF9yZXN1bHQkZXJyb3IkbmV0d29yaywgX3Jlc3VsdCRlcnJvcjIsIF9yZXN1bHQkZXJyb3IkbmV0d29yazIsIF9yZXN1bHQkZXJyb3IzLCBfcmVzdWx0JGVycm9yJG5ldHdvcmszLCBfcmVzdWx0JGVycm9yNDtcblxuICAgIGxldCByZWZldGNoID0gKCkgPT4ge1xuICAgICAgcmVzdWx0LnJlZmV0Y2goKTtcbiAgICB9O1xuXG4gICAgbGV0IGRhdGFHZXR0ZXIkMSA9IGRhdGFHZXR0ZXIubWFrZURhdGFHZXR0ZXIocmVzdWx0LmRhdGEsIChfcmVzdWx0JGVycm9yID0gcmVzdWx0LmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzdWx0JGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzdWx0JGVycm9yLmdyYXBoUUxFcnJvcnMpO1xuICAgIGNvbnN0IGF1dGhlbnRpY2F0ZWRJdGVtR2V0dGVyID0gZGF0YUdldHRlciQxLmdldCgnYXV0aGVudGljYXRlZEl0ZW0nKTtcbiAgICBjb25zdCBrZXlzdG9uZU1ldGFHZXR0ZXIgPSBkYXRhR2V0dGVyJDEuZ2V0KCdrZXlzdG9uZScpO1xuICAgIHJldHVybiB7XG4gICAgICByZWZldGNoLFxuICAgICAgYXV0aGVudGljYXRlZEl0ZW06IGdldEF1dGhlbnRpY2F0ZWRJdGVtKHJlc3VsdCwgYXV0aGVudGljYXRlZEl0ZW1HZXR0ZXIuZXJyb3JzIHx8ICgoX3Jlc3VsdCRlcnJvciRuZXR3b3JrID0gKF9yZXN1bHQkZXJyb3IyID0gcmVzdWx0LmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzdWx0JGVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Jlc3VsdCRlcnJvcjIubmV0d29ya0Vycm9yKSAhPT0gbnVsbCAmJiBfcmVzdWx0JGVycm9yJG5ldHdvcmsgIT09IHZvaWQgMCA/IF9yZXN1bHQkZXJyb3IkbmV0d29yayA6IHVuZGVmaW5lZCkpLFxuICAgICAgdmlzaWJsZUxpc3RzOiBnZXRWaXNpYmxlTGlzdHMocmVzdWx0LCBrZXlzdG9uZU1ldGFHZXR0ZXIuZXJyb3JzIHx8ICgoX3Jlc3VsdCRlcnJvciRuZXR3b3JrMiA9IChfcmVzdWx0JGVycm9yMyA9IHJlc3VsdC5lcnJvcikgPT09IG51bGwgfHwgX3Jlc3VsdCRlcnJvcjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXN1bHQkZXJyb3IzLm5ldHdvcmtFcnJvcikgIT09IG51bGwgJiYgX3Jlc3VsdCRlcnJvciRuZXR3b3JrMiAhPT0gdm9pZCAwID8gX3Jlc3VsdCRlcnJvciRuZXR3b3JrMiA6IHVuZGVmaW5lZCkpLFxuICAgICAgY3JlYXRlVmlld0ZpZWxkTW9kZXM6IGdldENyZWF0ZVZpZXdGaWVsZE1vZGVzKHJlc3VsdCwga2V5c3RvbmVNZXRhR2V0dGVyLmVycm9ycyB8fCAoKF9yZXN1bHQkZXJyb3IkbmV0d29yazMgPSAoX3Jlc3VsdCRlcnJvcjQgPSByZXN1bHQuZXJyb3IpID09PSBudWxsIHx8IF9yZXN1bHQkZXJyb3I0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzdWx0JGVycm9yNC5uZXR3b3JrRXJyb3IpICE9PSBudWxsICYmIF9yZXN1bHQkZXJyb3IkbmV0d29yazMgIT09IHZvaWQgMCA/IF9yZXN1bHQkZXJyb3IkbmV0d29yazMgOiB1bmRlZmluZWQpKVxuICAgIH07XG4gIH0sIFtyZXN1bHRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlYXRlVmlld0ZpZWxkTW9kZXMoe1xuICBkYXRhXG59LCBlcnJvcikge1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6ICdlcnJvcicsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxpc3RzID0ge307XG4gICAgZGF0YS5rZXlzdG9uZS5hZG1pbk1ldGEubGlzdHMuZm9yRWFjaChsaXN0ID0+IHtcbiAgICAgIGxpc3RzW2xpc3Qua2V5XSA9IHt9O1xuICAgICAgbGlzdC5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgIGxpc3RzW2xpc3Qua2V5XVtmaWVsZC5wYXRoXSA9IGZpZWxkLmNyZWF0ZVZpZXcuZmllbGRNb2RlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiAnbG9hZGVkJyxcbiAgICAgIGxpc3RzXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6ICdsb2FkaW5nJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaXNpYmxlTGlzdHMoe1xuICBkYXRhXG59LCBlcnJvcikge1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6ICdlcnJvcicsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxpc3RzID0gbmV3IFNldCgpO1xuICAgIGRhdGEua2V5c3RvbmUuYWRtaW5NZXRhLmxpc3RzLmZvckVhY2gobGlzdCA9PiB7XG4gICAgICBpZiAoIWxpc3QuaXNIaWRkZW4pIHtcbiAgICAgICAgbGlzdHMuYWRkKGxpc3Qua2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6ICdsb2FkZWQnLFxuICAgICAgbGlzdHNcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZTogJ2xvYWRpbmcnXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEF1dGhlbnRpY2F0ZWRJdGVtKHtcbiAgZGF0YVxufSwgZXJyb3IpIHtcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiAnZXJyb3InLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuYXV0aGVudGljYXRlZEl0ZW0gfHwgLy8gdGhpcyBpcyBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgYSBuZXcgdHlwZVxuICAgIC8vIGluIHRoZSBBdXRoZW50aWNhdGVkSXRlbSB1bmlvbiBhbmQgdGhlIHF1ZXJ5XG4gICAgLy8gdGhhdCB0aGUgYWRtaW4gdWkgaGFzIGRvZXNuJ3QgZ2V0IHRoZSBpZFxuICAgIC8vICh5ZXMsIHVuZGVmaW5lZCBpcyB2ZXJ5IHNwZWNpZmljIGFuZCB2ZXJ5IGludGVudGlvbmFsLCBpdCBzaG91bGQgbm90IGJlIGNoZWNraW5nIGZvciBudWxsKVxuICAgIGRhdGEuYXV0aGVudGljYXRlZEl0ZW0uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGU6ICd1bmF1dGhlbnRpY2F0ZWQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsRmllbGQgPSBPYmplY3Qua2V5cyhkYXRhLmF1dGhlbnRpY2F0ZWRJdGVtKS5maWx0ZXIoeCA9PiB4ICE9PSAnX190eXBlbmFtZScgJiYgeCAhPT0gJ2lkJylbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiAnYXV0aGVudGljYXRlZCcsXG4gICAgICBpZDogZGF0YS5hdXRoZW50aWNhdGVkSXRlbS5pZCxcbiAgICAgIGxhYmVsOiBkYXRhLmF1dGhlbnRpY2F0ZWRJdGVtW2xhYmVsRmllbGRdIHx8IGRhdGEuYXV0aGVudGljYXRlZEl0ZW0uaWQsXG4gICAgICBsaXN0S2V5OiBkYXRhLmF1dGhlbnRpY2F0ZWRJdGVtLl9fdHlwZW5hbWVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZTogJ2xvYWRpbmcnXG4gIH07XG59XG5cbmNvbnN0IEtleXN0b25lQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIEludGVybmFsS2V5c3RvbmVQcm92aWRlcih7XG4gIGFkbWluQ29uZmlnLFxuICBmaWVsZFZpZXdzLFxuICBhZG1pbk1ldGFIYXNoLFxuICBjaGlsZHJlbixcbiAgbGF6eU1ldGFkYXRhUXVlcnksXG4gIGFwaVBhdGhcbn0pIHtcbiAgY29uc3QgYWRtaW5NZXRhID0gdXNlQWRtaW5NZXRhKGFkbWluTWV0YUhhc2gsIGZpZWxkVmlld3MpO1xuICBjb25zdCB7XG4gICAgYXV0aGVudGljYXRlZEl0ZW0sXG4gICAgdmlzaWJsZUxpc3RzLFxuICAgIGNyZWF0ZVZpZXdGaWVsZE1vZGVzLFxuICAgIHJlZmV0Y2hcbiAgfSA9IHVzZUxhenlNZXRhZGF0YShsYXp5TWV0YWRhdGFRdWVyeSk7XG5cbiAgY29uc3QgcmVpbml0Q29udGV4dCA9ICgpID0+IHtcbiAgICB2YXIgX2FkbWluTWV0YSRyZWZldGNoO1xuXG4gICAgYWRtaW5NZXRhID09PSBudWxsIHx8IGFkbWluTWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9hZG1pbk1ldGEkcmVmZXRjaCA9IGFkbWluTWV0YS5yZWZldGNoKSA9PT0gbnVsbCB8fCBfYWRtaW5NZXRhJHJlZmV0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hZG1pbk1ldGEkcmVmZXRjaC5jYWxsKGFkbWluTWV0YSk7XG4gICAgcmVmZXRjaCgpO1xuICB9O1xuXG4gIGlmIChhZG1pbk1ldGEuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoY29yZSQxLkNlbnRlciwge1xuICAgICAgZmlsbFZpZXc6IHRydWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQobG9hZGluZy5Mb2FkaW5nRG90cywge1xuICAgICAgbGFiZWw6IFwiTG9hZGluZyBBZG1pbiBNZXRhZGF0YVwiLFxuICAgICAgc2l6ZTogXCJsYXJnZVwiXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudCh0b2FzdC5Ub2FzdFByb3ZpZGVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQobW9kYWxzLkRyYXdlclByb3ZpZGVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoS2V5c3RvbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIGFkbWluQ29uZmlnLFxuICAgICAgYWRtaW5NZXRhLFxuICAgICAgZmllbGRWaWV3cyxcbiAgICAgIGF1dGhlbnRpY2F0ZWRJdGVtLFxuICAgICAgcmVpbml0Q29udGV4dCxcbiAgICAgIHZpc2libGVMaXN0cyxcbiAgICAgIGNyZWF0ZVZpZXdGaWVsZE1vZGVzLFxuICAgICAgYXBpUGF0aFxuICAgIH1cbiAgfSwgY2hpbGRyZW4pKSk7XG59XG5cbmNvbnN0IEtleXN0b25lUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGFwb2xsb0NsaWVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gbmV3IGNsaWVudC5BcG9sbG9DbGllbnQoe1xuICAgIGNhY2hlOiBuZXcgY2xpZW50LkluTWVtb3J5Q2FjaGUoKSxcbiAgICBsaW5rOiBhcG9sbG9VcGxvYWRDbGllbnQuY3JlYXRlVXBsb2FkTGluayh7XG4gICAgICB1cmk6IHByb3BzLmFwaVBhdGhcbiAgICB9KVxuICB9KSwgW3Byb3BzLmFwaVBhdGhdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChjbGllbnQuQXBvbGxvUHJvdmlkZXIsIHtcbiAgICBjbGllbnQ6IGFwb2xsb0NsaWVudFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxLZXlzdG9uZVByb3ZpZGVyLCBwcm9wcykpO1xufTtcbmNvbnN0IHVzZUtleXN0b25lID0gKCkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoS2V5c3RvbmVDb250ZXh0KTtcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VLZXlzdG9uZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgYSBLZXlzdG9uZVByb3ZpZGVyIGNvbXBvbmVudCcpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmFkbWluTWV0YS5zdGF0ZSA9PT0gJ2Vycm9yJykge1xuICAgIC8vIElmIHdlIGdldCBhbiBcIkFjY2VzcyBkZW5pZWRcIiBlcnJvciwgaXQgcHJvYmFibHkgbWVhbnMgdGhlIHVzZXIgZG9lc24ndCBoYXZlIGFjY2VzcyB0byB0aGVcbiAgICAvLyBhZG1pbk1ldGEgYnV0IGhhcyBuYXZpZ2F0ZWQgKHByb2JhYmx5IGNsaWVudC1zaWRlKSB0byBhIHBhZ2UgdGhhdCByZXF1aXJlcyBpdC4gV2UgcmVsb2FkXG4gICAgLy8gdGhlIHBhZ2Ugc28gdGhlIHNlcnZlci1zaWRlIGFjY2VzcyBjb250cm9sIGNhbiBydW4gd2hpY2ggc2hvdWxkIGJvdW5jZSB0aGVtIHRvIHRoZSByaWdodFxuICAgIC8vIHBsYWNlIChvciBkaXNwbGF5IHRoZSBuby1hY2Nlc3MgcGFnZSlcbiAgICBpZiAodmFsdWUuYWRtaW5NZXRhLmVycm9yLm1lc3NhZ2UgPT09ICdBY2Nlc3MgZGVuaWVkJykge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBsb2FkaW5nIEFkbWluIE1ldGFkYXRhJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkbWluQ29uZmlnOiB2YWx1ZS5hZG1pbkNvbmZpZyxcbiAgICBhZG1pbk1ldGE6IHZhbHVlLmFkbWluTWV0YS52YWx1ZSxcbiAgICBhdXRoZW50aWNhdGVkSXRlbTogdmFsdWUuYXV0aGVudGljYXRlZEl0ZW0sXG4gICAgdmlzaWJsZUxpc3RzOiB2YWx1ZS52aXNpYmxlTGlzdHMsXG4gICAgY3JlYXRlVmlld0ZpZWxkTW9kZXM6IHZhbHVlLmNyZWF0ZVZpZXdGaWVsZE1vZGVzLFxuICAgIGFwaVBhdGg6IHZhbHVlLmFwaVBhdGhcbiAgfTtcbn07XG5jb25zdCB1c2VSZWluaXRDb250ZXh0ID0gKCkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoS2V5c3RvbmVDb250ZXh0KTtcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VSZWluaXRDb250ZXh0IG11c3QgYmUgY2FsbGVkIGluc2lkZSBhIEtleXN0b25lUHJvdmlkZXIgY29tcG9uZW50Jyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUucmVpbml0Q29udGV4dDtcbn07XG5jb25zdCB1c2VSYXdLZXlzdG9uZSA9ICgpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEtleXN0b25lQ29udGV4dCk7XG5cbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlUmF3S2V5c3RvbmUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIGEgS2V5c3RvbmVQcm92aWRlciBjb21wb25lbnQnKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCB1c2VMaXN0ID0ga2V5ID0+IHtcbiAgY29uc3Qge1xuICAgIGFkbWluTWV0YToge1xuICAgICAgbGlzdHNcbiAgICB9XG4gIH0gPSB1c2VLZXlzdG9uZSgpO1xuXG4gIGlmIChsaXN0c1trZXldKSB7XG4gICAgcmV0dXJuIGxpc3RzW2tleV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxpc3Qga2V5IHByb3ZpZGVkIHRvIHVzZUxpc3Q6ICR7a2V5fWApO1xuICB9XG59O1xuXG5leHBvcnRzLktleXN0b25lUHJvdmlkZXIgPSBLZXlzdG9uZVByb3ZpZGVyO1xuZXhwb3J0cy51c2VLZXlzdG9uZSA9IHVzZUtleXN0b25lO1xuZXhwb3J0cy51c2VMaXN0ID0gdXNlTGlzdDtcbmV4cG9ydHMudXNlUmF3S2V5c3RvbmUgPSB1c2VSYXdLZXlzdG9uZTtcbmV4cG9ydHMudXNlUmVpbml0Q29udGV4dCA9IHVzZVJlaW5pdENvbnRleHQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG52YXIgcm91dGVyID0gcmVxdWlyZSgnbmV4dC9yb3V0ZXInKTtcbnZhciBMaW5rJDEgPSByZXF1aXJlKCduZXh0L2xpbmsnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgTGlua19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoTGluayQxKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVhY3QpO1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJocmVmXCIsIFwiYXNcIiwgXCJyZXBsYWNlXCIsIFwic2Nyb2xsXCIsIFwic2hhbGxvd1wiLCBcInByZWZldGNoXCJdO1xuY29uc3QgTGluayA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGhyZWYsXG4gICAgYXMsXG4gICAgcmVwbGFjZSxcbiAgICBzY3JvbGwsXG4gICAgc2hhbGxvdyxcbiAgICBwcmVmZXRjaFxuICB9ID0gX3JlZixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMaW5rX19kZWZhdWx0W1wiZGVmYXVsdFwiXSwge1xuICAgIGhyZWY6IGhyZWYsXG4gICAgYXM6IGFzLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgc2Nyb2xsOiBzY3JvbGwsXG4gICAgc2hhbGxvdzogc2hhbGxvdyxcbiAgICBwcmVmZXRjaDogcHJlZmV0Y2hcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYVwiLCBwcm9wcykpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSb3V0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLlJvdXRlcjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuY3JlYXRlUm91dGVyOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5tYWtlUHVibGljUm91dGVySW5zdGFuY2U7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSb3V0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVzZVJvdXRlcjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3dpdGhSb3V0ZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLndpdGhSb3V0ZXI7IH1cbn0pO1xuZXhwb3J0cy5MaW5rID0gTGluaztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvY29yZScpO1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiXTtcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tcG9uZW50IHlvdSBzaG91bGQgdXNlIHdoZW4geW91IHdhbnQgdGhlIHN0YW5kYXJkIHBhZGRpbmcgYXJvdW5kIGEgY2VsbCB2YWx1ZVxuICovXG5cbmNvbnN0IENlbGxDb250YWluZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgY29uc3Qge1xuICAgIHNwYWNpbmdcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgcmV0dXJuIGNvcmUuanN4KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjc3M6IHtcbiAgICAgIHBhZGRpbmc6IHNwYWNpbmcuc21hbGxcbiAgICB9XG4gIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xufTtcblxuZXhwb3J0cy5DZWxsQ29udGFpbmVyID0gQ2VsbENvbnRhaW5lcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgYWRtaW5VaV9yb3V0ZXJfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlSb3V0ZXIgPSByZXF1aXJlKCcuLi9hZG1pbi11aS9yb3V0ZXIvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWFkbWluLXVpLXJvdXRlci5janMuZGV2LmpzJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tcG9uZW50IHlvdSBzaG91bGQgdXNlIHdoZW4gbGlua2luZyBhIENlbGwgdG8gYW4gaXRlbSAoaS5lIHdoZW4gdGhlIENlbGwgc3VwcG9ydHNcbiAqIHRoZSBsaW5rVG8gcHJvcClcbiAqL1xuXG5jb25zdCBDZWxsTGluayA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbG9ycyxcbiAgICBzcGFjaW5nXG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIHJldHVybiBjb3JlLmpzeChhZG1pblVpX3JvdXRlcl9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaVJvdXRlci5MaW5rLCBfZXh0ZW5kcyh7XG4gICAgY3NzOiB7XG4gICAgICBjb2xvcjogY29sb3JzLmZvcmVncm91bmQsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgcGFkZGluZzogc3BhY2luZy5zbWFsbCxcbiAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAnOmhvdmVyJzoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSdcbiAgICAgIH1cbiAgICB9XG4gIH0sIHByb3BzKSk7XG59O1xuXG5leHBvcnRzLkNlbGxMaW5rID0gQ2VsbExpbms7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaXNEZWVwRXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBtb2RhbHMgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvbW9kYWxzJyk7XG52YXIgdG9hc3QgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvdG9hc3QnKTtcbnZhciBsb2FkaW5nID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnZhciBjbGllbnQgPSByZXF1aXJlKCdAYXBvbGxvL2NsaWVudCcpO1xudmFyIGFkbWluVWlfY29udGV4dF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaUNvbnRleHQgPSByZXF1aXJlKCcuLi9hZG1pbi11aS9jb250ZXh0L2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1hZG1pbi11aS1jb250ZXh0LmNqcy5kZXYuanMnKTtcbnZhciBGaWVsZHMgPSByZXF1aXJlKCcuL0ZpZWxkcy00YWZiMzhmMC5janMuZGV2LmpzJyk7XG52YXIgR3JhcGhRTEVycm9yTm90aWNlID0gcmVxdWlyZSgnLi9HcmFwaFFMRXJyb3JOb3RpY2UtNzZmZjk2ZGQuY2pzLmRldi5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGlzRGVlcEVxdWFsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChpc0RlZXBFcXVhbCk7XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5mdW5jdGlvbiBDcmVhdGVJdGVtRHJhd2VyKHtcbiAgbGlzdEtleSxcbiAgb25DbG9zZSxcbiAgb25DcmVhdGVcbn0pIHtcbiAgY29uc3Qge1xuICAgIGNyZWF0ZVZpZXdGaWVsZE1vZGVzXG4gIH0gPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUtleXN0b25lKCk7XG4gIGNvbnN0IGxpc3QgPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUxpc3QobGlzdEtleSk7XG4gIGNvbnN0IHRvYXN0cyA9IHRvYXN0LnVzZVRvYXN0cygpO1xuICBjb25zdCBbY3JlYXRlSXRlbSwge1xuICAgIGxvYWRpbmc6IGxvYWRpbmckMSxcbiAgICBlcnJvclxuICB9XSA9IGNsaWVudC51c2VNdXRhdGlvbihjbGllbnQuZ3FsYG11dGF0aW9uKCRkYXRhOiAke2xpc3QuZ3FsTmFtZXMuY3JlYXRlSW5wdXROYW1lfSEpIHtcbiAgICAgIGl0ZW06ICR7bGlzdC5ncWxOYW1lcy5jcmVhdGVNdXRhdGlvbk5hbWV9KGRhdGE6ICRkYXRhKSB7XG4gICAgICAgIGlkXG4gICAgICAgIGxhYmVsOiAke2xpc3QubGFiZWxGaWVsZH1cbiAgICB9XG4gIH1gKTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhsaXN0LmZpZWxkcykuZm9yRWFjaChmaWVsZFBhdGggPT4ge1xuICAgICAgdmFsdWVbZmllbGRQYXRoXSA9IHtcbiAgICAgICAga2luZDogJ3ZhbHVlJyxcbiAgICAgICAgdmFsdWU6IGxpc3QuZmllbGRzW2ZpZWxkUGF0aF0uY29udHJvbGxlci5kZWZhdWx0VmFsdWVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbiAgY29uc3QgaW52YWxpZEZpZWxkcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGludmFsaWRGaWVsZHMgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZmllbGRQYXRoID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2ZpZWxkUGF0aF0udmFsdWU7XG4gICAgICBjb25zdCB2YWxpZGF0ZUZuID0gbGlzdC5maWVsZHNbZmllbGRQYXRoXS5jb250cm9sbGVyLnZhbGlkYXRlO1xuXG4gICAgICBpZiAodmFsaWRhdGVGbikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUZuKHZhbCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpbnZhbGlkRmllbGRzLmFkZChmaWVsZFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGludmFsaWRGaWVsZHM7XG4gIH0sIFtsaXN0LCB2YWx1ZV0pO1xuICBjb25zdCBbZm9yY2VWYWxpZGF0aW9uLCBzZXRGb3JjZVZhbGlkYXRpb25dID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICByZXR1cm4gY29yZS5qc3gobW9kYWxzLkRyYXdlciwge1xuICAgIHRpdGxlOiBgQ3JlYXRlICR7bGlzdC5zaW5ndWxhcn1gLFxuICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICBhY3Rpb25zOiB7XG4gICAgICBjb25maXJtOiB7XG4gICAgICAgIGxhYmVsOiBgQ3JlYXRlICR7bGlzdC5zaW5ndWxhcn1gLFxuICAgICAgICBsb2FkaW5nOiBsb2FkaW5nJDEsXG4gICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0ZvcmNlVmFsaWRhdGlvbiA9IGludmFsaWRGaWVsZHMuc2l6ZSAhPT0gMDtcbiAgICAgICAgICBzZXRGb3JjZVZhbGlkYXRpb24obmV3Rm9yY2VWYWxpZGF0aW9uKTtcbiAgICAgICAgICBpZiAobmV3Rm9yY2VWYWxpZGF0aW9uKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKGxpc3QuZmllbGRzKS5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH0gPSBsaXN0LmZpZWxkc1tmaWVsZFBhdGhdO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGNvbnRyb2xsZXIuc2VyaWFsaXplKHZhbHVlW2ZpZWxkUGF0aF0udmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShzZXJpYWxpemVkLCBjb250cm9sbGVyLnNlcmlhbGl6ZShjb250cm9sbGVyLmRlZmF1bHRWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgc2VyaWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3JlYXRlSXRlbSh7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnRoZW4oKHtcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRhdGEuaXRlbS5sYWJlbCB8fCBkYXRhLml0ZW0uaWQ7XG4gICAgICAgICAgICBvbkNyZWF0ZSh7XG4gICAgICAgICAgICAgIGlkOiBkYXRhLml0ZW0uaWQsXG4gICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvYXN0cy5hZGRUb2FzdCh7XG4gICAgICAgICAgICAgIHRpdGxlOiBsYWJlbCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0NyZWF0ZWQgU3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgICAgICAgdG9uZTogJ3Bvc2l0aXZlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiB7XG4gICAgICAgIGxhYmVsOiAnQ2FuY2VsJyxcbiAgICAgICAgYWN0aW9uOiBvbkNsb3NlXG4gICAgICB9XG4gICAgfVxuICB9LCBjcmVhdGVWaWV3RmllbGRNb2Rlcy5zdGF0ZSA9PT0gJ2Vycm9yJyAmJiBjb3JlLmpzeChHcmFwaFFMRXJyb3JOb3RpY2UuR3JhcGhRTEVycm9yTm90aWNlLCB7XG4gICAgbmV0d29ya0Vycm9yOiBjcmVhdGVWaWV3RmllbGRNb2Rlcy5lcnJvciBpbnN0YW5jZW9mIEVycm9yID8gY3JlYXRlVmlld0ZpZWxkTW9kZXMuZXJyb3IgOiB1bmRlZmluZWQsXG4gICAgZXJyb3JzOiBjcmVhdGVWaWV3RmllbGRNb2Rlcy5lcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdW5kZWZpbmVkIDogY3JlYXRlVmlld0ZpZWxkTW9kZXMuZXJyb3JcbiAgfSksIGNyZWF0ZVZpZXdGaWVsZE1vZGVzLnN0YXRlID09PSAnbG9hZGluZycgJiYgY29yZS5qc3gobG9hZGluZy5Mb2FkaW5nRG90cywge1xuICAgIGxhYmVsOiBcIkxvYWRpbmcgY3JlYXRlIGZvcm1cIlxuICB9KSwgZXJyb3IgJiYgY29yZS5qc3goR3JhcGhRTEVycm9yTm90aWNlLkdyYXBoUUxFcnJvck5vdGljZSwge1xuICAgIG5ldHdvcmtFcnJvcjogZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm5ldHdvcmtFcnJvcixcbiAgICBlcnJvcnM6IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5ncmFwaFFMRXJyb3JzXG4gIH0pLCBjb3JlLmpzeChjb3JlLkJveCwge1xuICAgIHBhZGRpbmdZOiBcInhsYXJnZVwiXG4gIH0sIGNvcmUuanN4KEZpZWxkcy5GaWVsZHMsIHtcbiAgICBmaWVsZHM6IGxpc3QuZmllbGRzLFxuICAgIGZpZWxkTW9kZXM6IGNyZWF0ZVZpZXdGaWVsZE1vZGVzLnN0YXRlID09PSAnbG9hZGVkJyA/IGNyZWF0ZVZpZXdGaWVsZE1vZGVzLmxpc3RzW2xpc3Qua2V5XSA6IG51bGwsXG4gICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24sXG4gICAgaW52YWxpZEZpZWxkczogaW52YWxpZEZpZWxkcyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb25DaGFuZ2U6IFJlYWN0LnVzZUNhbGxiYWNrKGdldE5ld1ZhbHVlID0+IHtcbiAgICAgIHNldFZhbHVlKG9sZFZhbHVlcyA9PiBnZXROZXdWYWx1ZShvbGRWYWx1ZXMpKTtcbiAgICB9LCBbXSlcbiAgfSkpKTtcbn1cblxuZXhwb3J0cy5DcmVhdGVJdGVtRHJhd2VyID0gQ3JlYXRlSXRlbURyYXdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9vYmplY3RTcHJlYWQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmNvbnN0IFJlbmRlckZpZWxkID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gUmVuZGVyRmllbGQoe1xuICBmaWVsZCxcbiAgdmFsdWUsXG4gIGF1dG9Gb2N1cyxcbiAgZm9yY2VWYWxpZGF0aW9uLFxuICBvbkNoYW5nZVxufSkge1xuICByZXR1cm4gY29yZS5qc3goZmllbGQudmlld3MuRmllbGQsIHtcbiAgICBmaWVsZDogZmllbGQuY29udHJvbGxlcixcbiAgICBvbkNoYW5nZTogUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICBpZiAob25DaGFuZ2UgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICAgIG9uQ2hhbmdlKHZhbCA9PiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbCksIHt9LCB7XG4gICAgICAgICAgW2ZpZWxkLmNvbnRyb2xsZXIucGF0aF06IHtcbiAgICAgICAgICAgIGtpbmQ6ICd2YWx1ZScsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9LCBbb25DaGFuZ2UsIGZpZWxkLmNvbnRyb2xsZXIucGF0aF0pLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBmb3JjZVZhbGlkYXRpb246IGZvcmNlVmFsaWRhdGlvblxuICB9KTtcbn0pO1xuZnVuY3Rpb24gRmllbGRzKHtcbiAgZmllbGRzLFxuICB2YWx1ZSxcbiAgZmllbGRNb2RlcyxcbiAgZm9yY2VWYWxpZGF0aW9uLFxuICBpbnZhbGlkRmllbGRzLFxuICBvbkNoYW5nZVxufSkge1xuICBjb25zdCByZW5kZXJlZEZpZWxkcyA9IE9iamVjdC5rZXlzKGZpZWxkcykuZmlsdGVyKGZpZWxkUGF0aCA9PiBmaWVsZE1vZGVzID09PSBudWxsIHx8IGZpZWxkTW9kZXNbZmllbGRQYXRoXSAhPT0gJ2hpZGRlbicpLm1hcCgoZmllbGRQYXRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ZpZWxkUGF0aF07XG4gICAgY29uc3QgdmFsID0gdmFsdWVbZmllbGRQYXRoXTtcbiAgICBjb25zdCBmaWVsZE1vZGUgPSBmaWVsZE1vZGVzID09PSBudWxsID8gJ2VkaXQnIDogZmllbGRNb2Rlc1tmaWVsZFBhdGhdO1xuXG4gICAgaWYgKHZhbC5raW5kID09PSAnZXJyb3InKSB7XG4gICAgICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwgbnVsbCwgZmllbGQubGFiZWwsIFwiOiBcIiwgY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgY29sb3I6ICdyZWQnXG4gICAgICAgIH1cbiAgICAgIH0sIHZhbC5lcnJvcnNbMF0ubWVzc2FnZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3JlLmpzeChSZW5kZXJGaWVsZCwge1xuICAgICAga2V5OiBmaWVsZFBhdGgsXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICB2YWx1ZTogdmFsLnZhbHVlLFxuICAgICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24gJiYgaW52YWxpZEZpZWxkcy5oYXMoZmllbGRQYXRoKSxcbiAgICAgIG9uQ2hhbmdlOiBmaWVsZE1vZGUgPT09ICdlZGl0JyA/IG9uQ2hhbmdlIDogdW5kZWZpbmVkLFxuICAgICAgYXV0b0ZvY3VzOiBpbmRleCA9PT0gMFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwieGxhcmdlXCJcbiAgfSwgcmVuZGVyZWRGaWVsZHMsIHJlbmRlcmVkRmllbGRzLmxlbmd0aCA9PT0gMCAmJiAnVGhlcmUgYXJlIG5vIGZpZWxkcyB0aGF0IHlvdSBjYW4gcmVhZCBvciBlZGl0Jyk7XG59XG5cbmV4cG9ydHMuRmllbGRzID0gRmllbGRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgbm90aWNlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL25vdGljZScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVhY3QpO1xuXG5mdW5jdGlvbiBHcmFwaFFMRXJyb3JOb3RpY2Uoe1xuICBlcnJvcnMsXG4gIG5ldHdvcmtFcnJvclxufSkge1xuICBpZiAobmV0d29ya0Vycm9yKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChub3RpY2UuTm90aWNlLCB7XG4gICAgICB0b25lOiBcIm5lZ2F0aXZlXCIsXG4gICAgICBtYXJnaW5Cb3R0b206IFwibGFyZ2VcIlxuICAgIH0sIG5ldHdvcmtFcnJvci5tZXNzYWdlKTtcbiAgfVxuXG4gIGlmIChlcnJvcnMgIT09IG51bGwgJiYgZXJyb3JzICE9PSB2b2lkIDAgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoY29yZS5TdGFjaywge1xuICAgICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgICBtYXJnaW5Cb3R0b206IFwibGFyZ2VcIlxuICAgIH0sIGVycm9ycy5tYXAoZXJyID0+IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChub3RpY2UuTm90aWNlLCB7XG4gICAgICB0b25lOiBcIm5lZ2F0aXZlXCJcbiAgICB9LCBlcnIubWVzc2FnZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLkdyYXBoUUxFcnJvck5vdGljZSA9IEdyYXBoUUxFcnJvck5vdGljZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmUgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvY29yZScpO1xudmFyIGJ1dHRvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9idXR0b24nKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY2xpZW50ID0gcmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcblxuLyoqIEBqc3hSdW50aW1lIGNsYXNzaWMgKi9cbmNvbnN0IEVORF9TRVNTSU9OID0gY2xpZW50LmdxbGBcbiAgbXV0YXRpb24gRW5kU2Vzc2lvbiB7XG4gICAgZW5kU2Vzc2lvblxuICB9XG5gO1xuXG5jb25zdCBTaWdub3V0QnV0dG9uID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3QgW2VuZFNlc3Npb24sIHtcbiAgICBsb2FkaW5nLFxuICAgIGRhdGFcbiAgfV0gPSBjbGllbnQudXNlTXV0YXRpb24oRU5EX1NFU1NJT04pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCAmJiBkYXRhLmVuZFNlc3Npb24pIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gIH0sIFtkYXRhXSk7XG4gIHJldHVybiBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGlzTG9hZGluZzogbG9hZGluZyxcbiAgICBvbkNsaWNrOiAoKSA9PiBlbmRTZXNzaW9uKClcbiAgfSwgY2hpbGRyZW4gfHwgJ1NpZ24gb3V0Jyk7XG59O1xuXG5leHBvcnRzLlNpZ25vdXRCdXR0b24gPSBTaWdub3V0QnV0dG9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xpZW50ID0gcmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcblxuY29uc3Qgc3RhdGljQWRtaW5NZXRhUXVlcnkgPSBjbGllbnQuZ3FsYFxuICBxdWVyeSBTdGF0aWNBZG1pbk1ldGEge1xuICAgIGtleXN0b25lIHtcbiAgICAgIF9fdHlwZW5hbWVcbiAgICAgIGFkbWluTWV0YSB7XG4gICAgICAgIF9fdHlwZW5hbWVcbiAgICAgICAgZW5hYmxlU2lnbm91dFxuICAgICAgICBlbmFibGVTZXNzaW9uSXRlbVxuICAgICAgICBsaXN0cyB7XG4gICAgICAgICAgX190eXBlbmFtZVxuICAgICAgICAgIGtleVxuICAgICAgICAgIGl0ZW1RdWVyeU5hbWVcbiAgICAgICAgICBsaXN0UXVlcnlOYW1lXG4gICAgICAgICAgaW5pdGlhbFNvcnQge1xuICAgICAgICAgICAgX190eXBlbmFtZVxuICAgICAgICAgICAgZmllbGRcbiAgICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoXG4gICAgICAgICAgbGFiZWxcbiAgICAgICAgICBzaW5ndWxhclxuICAgICAgICAgIHBsdXJhbFxuICAgICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICAgICAgaW5pdGlhbENvbHVtbnNcbiAgICAgICAgICBwYWdlU2l6ZVxuICAgICAgICAgIGxhYmVsRmllbGRcbiAgICAgICAgICBmaWVsZHMge1xuICAgICAgICAgICAgX190eXBlbmFtZVxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICAgIGZpZWxkTWV0YVxuICAgICAgICAgICAgdmlld3NJbmRleFxuICAgICAgICAgICAgY3VzdG9tVmlld3NJbmRleFxuICAgICAgICAgICAgc2VhcmNoXG4gICAgICAgICAgICBpdGVtVmlldyB7XG4gICAgICAgICAgICAgIGZpZWxkTW9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDsgLy8gZ2VuZXJhdGVkIGJ5IGh0dHBzOi8vZ3JhcGhxbC1jb2RlLWdlbmVyYXRvci5jb20gd2l0aCB0aGVzZSBvcHRpb25zOlxuLy8gZ2VuZXJhdGVzOlxuLy8gICB0eXBlcy50czpcbi8vICAgICBwbHVnaW5zOlxuLy8gICAgICAgLSB0eXBlc2NyaXB0LW9wZXJhdGlvbnM6XG4vLyAgICAgICAgICAgbmFtaW5nQ29udmVudGlvbjoga2VlcFxuLy8gICAgICAgLSB0eXBlc2NyaXB0OlxuLy8gICAgICAgICAgIGVudW1zQXNUeXBlczogdHJ1ZVxuLy8gICAgICAgICAgIG5vbk9wdGlvbmFsVHlwZW5hbWU6IHRydWVcbi8vICAgICAgICAgICBuYW1pbmdDb252ZW50aW9uOiBrZWVwXG4vLyAgICAgICAgICAgbm9FeHBvcnQ6IHRydWVcbi8vICAgICAgICAgICBhdm9pZE9wdGlvbmFsczogdHJ1ZVxuLy8gICAgICAgICAgIHNjYWxhcnM6XG4vLyAgICAgICAgICAgICBKU09OOiBKU09OVmFsdWVcblxuZXhwb3J0cy5zdGF0aWNBZG1pbk1ldGFRdWVyeSA9IHN0YXRpY0FkbWluTWV0YVF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBkb24ndCBkdXBsaWNhdGUgdGhpcyBiZXR3ZWVuIGhlcmUgYW5kIHBhY2thZ2VzL2tleXN0b25lL0xpc3RUeXBlcy9saXN0LmpzXG5mdW5jdGlvbiBnZXRHcWxOYW1lcyh7XG4gIGxpc3RLZXksXG4gIHBsdXJhbEdyYXBoUUxOYW1lXG59KSB7XG4gIGNvbnN0IGxvd2VyUGx1cmFsTmFtZSA9IHBsdXJhbEdyYXBoUUxOYW1lLnNsaWNlKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBwbHVyYWxHcmFwaFFMTmFtZS5zbGljZSgxKTtcbiAgY29uc3QgbG93ZXJTaW5ndWxhck5hbWUgPSBsaXN0S2V5LnNsaWNlKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBsaXN0S2V5LnNsaWNlKDEpO1xuICByZXR1cm4ge1xuICAgIG91dHB1dFR5cGVOYW1lOiBsaXN0S2V5LFxuICAgIGl0ZW1RdWVyeU5hbWU6IGxvd2VyU2luZ3VsYXJOYW1lLFxuICAgIGxpc3RRdWVyeU5hbWU6IGxvd2VyUGx1cmFsTmFtZSxcbiAgICBsaXN0UXVlcnlDb3VudE5hbWU6IGAke2xvd2VyUGx1cmFsTmFtZX1Db3VudGAsXG4gICAgbGlzdE9yZGVyTmFtZTogYCR7bGlzdEtleX1PcmRlckJ5SW5wdXRgLFxuICAgIGRlbGV0ZU11dGF0aW9uTmFtZTogYGRlbGV0ZSR7bGlzdEtleX1gLFxuICAgIHVwZGF0ZU11dGF0aW9uTmFtZTogYHVwZGF0ZSR7bGlzdEtleX1gLFxuICAgIGNyZWF0ZU11dGF0aW9uTmFtZTogYGNyZWF0ZSR7bGlzdEtleX1gLFxuICAgIGRlbGV0ZU1hbnlNdXRhdGlvbk5hbWU6IGBkZWxldGUke3BsdXJhbEdyYXBoUUxOYW1lfWAsXG4gICAgdXBkYXRlTWFueU11dGF0aW9uTmFtZTogYHVwZGF0ZSR7cGx1cmFsR3JhcGhRTE5hbWV9YCxcbiAgICBjcmVhdGVNYW55TXV0YXRpb25OYW1lOiBgY3JlYXRlJHtwbHVyYWxHcmFwaFFMTmFtZX1gLFxuICAgIHdoZXJlSW5wdXROYW1lOiBgJHtsaXN0S2V5fVdoZXJlSW5wdXRgLFxuICAgIHdoZXJlVW5pcXVlSW5wdXROYW1lOiBgJHtsaXN0S2V5fVdoZXJlVW5pcXVlSW5wdXRgLFxuICAgIHVwZGF0ZUlucHV0TmFtZTogYCR7bGlzdEtleX1VcGRhdGVJbnB1dGAsXG4gICAgY3JlYXRlSW5wdXROYW1lOiBgJHtsaXN0S2V5fUNyZWF0ZUlucHV0YCxcbiAgICB1cGRhdGVNYW55SW5wdXROYW1lOiBgJHtsaXN0S2V5fVVwZGF0ZUFyZ3NgLFxuICAgIHJlbGF0ZVRvTWFueUZvckNyZWF0ZUlucHV0TmFtZTogYCR7bGlzdEtleX1SZWxhdGVUb01hbnlGb3JDcmVhdGVJbnB1dGAsXG4gICAgcmVsYXRlVG9NYW55Rm9yVXBkYXRlSW5wdXROYW1lOiBgJHtsaXN0S2V5fVJlbGF0ZVRvTWFueUZvclVwZGF0ZUlucHV0YCxcbiAgICByZWxhdGVUb09uZUZvckNyZWF0ZUlucHV0TmFtZTogYCR7bGlzdEtleX1SZWxhdGVUb09uZUZvckNyZWF0ZUlucHV0YCxcbiAgICByZWxhdGVUb09uZUZvclVwZGF0ZUlucHV0TmFtZTogYCR7bGlzdEtleX1SZWxhdGVUb09uZUZvclVwZGF0ZUlucHV0YFxuICB9O1xufVxuXG5leHBvcnRzLmdldEdxbE5hbWVzID0gZ2V0R3FsTmFtZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRhdGFHZXR0ZXJXaXRoTm9FcnJvcnMoZGF0YSwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgcGF0aCxcblxuICAgIGdldChmaWVsZCkge1xuICAgICAgdmFyIF9kYXRhJGZpZWxkO1xuXG4gICAgICByZXR1cm4gZGF0YUdldHRlcldpdGhOb0Vycm9ycygoX2RhdGEkZmllbGQgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFbZmllbGRdKSAhPT0gbnVsbCAmJiBfZGF0YSRmaWVsZCAhPT0gdm9pZCAwID8gX2RhdGEkZmllbGQgOiBudWxsLCBwYXRoLmNvbmNhdChmaWVsZCkpO1xuICAgIH1cblxuICB9O1xufVxuXG5mdW5jdGlvbiBkYXRhR2V0dGVyV2l0aEVycm9ycyhkYXRhLCBlcnJvcnMsIHBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGVycm9ycyxcbiAgICBwYXRoLFxuXG4gICAgZ2V0KGZpZWxkKSB7XG4gICAgICB2YXIgX2RhdGEkZmllbGQyO1xuXG4gICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5jb25jYXQoZmllbGQpO1xuICAgICAgY29uc3QgbmV3SXRlbSA9IChfZGF0YSRmaWVsZDIgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFbZmllbGRdKSAhPT0gbnVsbCAmJiBfZGF0YSRmaWVsZDIgIT09IHZvaWQgMCA/IF9kYXRhJGZpZWxkMiA6IG51bGw7XG4gICAgICBsZXQgZXJyb3JzRm9yRmllbGQgPSBlcnJvcnMuZmlsdGVyKGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yLnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JQYXRoID0gZXJyb3IucGF0aDtcbiAgICAgICAgcmV0dXJuIG5ld1BhdGguZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gZXJyb3JQYXRoW2luZGV4XSA9PT0gdW5kZWZpbmVkIHx8IGVycm9yUGF0aFtpbmRleF0gPT09IHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3JzRm9yRmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkYXRhR2V0dGVyV2l0aEVycm9ycyhuZXdJdGVtLCBlcnJvcnMsIG5ld1BhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YUdldHRlcldpdGhOb0Vycm9ycyhuZXdJdGVtLCBuZXdQYXRoKTtcbiAgICB9XG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZURhdGFHZXR0ZXIoZGF0YSwgZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMgIT09IG51bGwgJiYgZXJyb3JzICE9PSB2b2lkIDAgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgIHJldHVybiBkYXRhR2V0dGVyV2l0aEVycm9ycyhkYXRhLCBlcnJvcnMsIFtdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhR2V0dGVyV2l0aE5vRXJyb3JzKGRhdGEsIFtdKTtcbn1cblxuZXhwb3J0cy5tYWtlRGF0YUdldHRlciA9IG1ha2VEYXRhR2V0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2Vha01lbW9pemUgPSByZXF1aXJlKCdAZW1vdGlvbi93ZWFrLW1lbW9pemUnKTtcbnZhciBncmFwaHFsID0gcmVxdWlyZSgnZ3JhcGhxbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIHdlYWtNZW1vaXplX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdCh3ZWFrTWVtb2l6ZSk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RSb290RmllbGRzKHNlbGVjdGVkRmllbGRzLCBzZWxlY3Rpb25TZXQpIHtcbiAgc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4ge1xuICAgIGlmIChzZWxlY3Rpb24ua2luZCA9PT0gJ0ZpZWxkJykge1xuICAgICAgc2VsZWN0ZWRGaWVsZHMuYWRkKHNlbGVjdGlvbi5hbGlhcyA/IHNlbGVjdGlvbi5hbGlhcy52YWx1ZSA6IHNlbGVjdGlvbi5uYW1lLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uLmtpbmQgPT09ICdJbmxpbmVGcmFnbWVudCcpIHtcbiAgICAgIGV4dHJhY3RSb290RmllbGRzKHNlbGVjdGVkRmllbGRzLCBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KTtcbiAgICB9IC8vIEZyYWdtZW50U3ByZWFkIHdpbGwgbmV2ZXIgaGFwcGVuIGZvciB0aGUgdXNlIGNhc2VzIG9mIGdldFJvb3RGaWVsZHNGcm9tU2VsZWN0aW9uXG5cbiAgfSk7XG59XG5cbmNvbnN0IGdldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlciA9IHdlYWtNZW1vaXplX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjb250cm9sbGVyID0+IHtcbiAgY29uc3QgYXN0ID0gZ3JhcGhxbC5wYXJzZShgZnJhZ21lbnQgWCBvbiBZIHtcbiAgaWRcbiAgJHtjb250cm9sbGVyLmdyYXBocWxTZWxlY3Rpb259XG4gIH1gKTtcbiAgY29uc3Qgc2VsZWN0ZWRGaWVsZHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGZyYWdtZW50Tm9kZSA9IGFzdC5kZWZpbml0aW9uc1swXTtcbiAgZXh0cmFjdFJvb3RGaWVsZHMoc2VsZWN0ZWRGaWVsZHMsIGZyYWdtZW50Tm9kZS5zZWxlY3Rpb25TZXQpO1xuICByZXR1cm4gWy4uLnNlbGVjdGVkRmllbGRzXTtcbn0pO1xuXG5leHBvcnRzLmdldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlciA9IGdldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdyYXBocWxUc1NjaGVtYSA9IHJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYScpO1xudmFyIGdyYXBocWxUeXBlSnNvbiA9IHJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG52YXIgR3JhcGhRTFVwbG9hZCA9IHJlcXVpcmUoJ2dyYXBocWwtdXBsb2FkL3B1YmxpYy9HcmFwaFFMVXBsb2FkLmpzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcbnZhciBEZWNpbWFsJDEgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG52YXIgYXBpV2l0aG91dENvbnRleHQgPSByZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGhvdXQtY29udGV4dCcpO1xudmFyIGFwaVdpdGhDb250ZXh0ID0gcmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBncmFwaHFsVHNTY2hlbWFfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShncmFwaHFsVHNTY2hlbWEpO1xudmFyIEdyYXBoUUxVcGxvYWRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KEdyYXBoUUxVcGxvYWQpO1xuXG5jb25zdCBKU09OID0gZ3JhcGhxbFRzU2NoZW1hX19uYW1lc3BhY2UuZ3JhcGhxbC5zY2FsYXIoZ3JhcGhxbFR5cGVKc29uLkdyYXBoUUxKU09OKTtcbmNvbnN0IFVwbG9hZCA9IGdyYXBocWxUc1NjaGVtYV9fbmFtZXNwYWNlLmdyYXBocWwuc2NhbGFyKEdyYXBoUUxVcGxvYWRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKTsgLy8gLSBEZWNpbWFsLmpzIHRocm93cyBvbiBpbnZhbGlkIGlucHV0c1xuLy8gLSBEZWNpbWFsLmpzIGNhbiByZXByZXNlbnQgK0luZmluaXR5IGFuZCAtSW5maW5pdHksIHRoZXNlIGFyZW4ndCB2YWx1ZXMgaW4gUG9zdGdyZXMnIGRlY2ltYWwsXG4vLyAgIE5hTiBpcyBidXQgUHJpc21hIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuLy8gICAuaXNGaW5pdGUgcmVmZXJzIHRvICtJbmZpbml0eSwgLUluZmluaXR5IGFuZCBOYU5cblxuY29uc3QgRGVjaW1hbCA9IGdyYXBocWxUc1NjaGVtYV9fbmFtZXNwYWNlLmdyYXBocWwuc2NhbGFyKG5ldyBncmFwaHFsLkdyYXBoUUxTY2FsYXJUeXBlKHtcbiAgbmFtZTogJ0RlY2ltYWwnLFxuXG4gIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICghRGVjaW1hbCQxLkRlY2ltYWwuaXNEZWNpbWFsKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKGB1bmV4cGVjdGVkIHZhbHVlIHByb3ZpZGVkIHRvIERlY2ltYWwgc2NhbGFyOiAke3ZhbHVlfWApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5zY2FsZVRvUHJpbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQodmFsdWUuc2NhbGVUb1ByaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfSxcblxuICBwYXJzZUxpdGVyYWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUua2luZCAhPT0gJ1N0cmluZ1ZhbHVlJykge1xuICAgICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKCdEZWNpbWFsIG9ubHkgYWNjZXB0cyB2YWx1ZXMgYXMgc3RyaW5ncycpO1xuICAgIH1cblxuICAgIGxldCBkZWNpbWFsID0gbmV3IERlY2ltYWwkMS5EZWNpbWFsKHZhbHVlLnZhbHVlKTtcblxuICAgIGlmICghZGVjaW1hbC5pc0Zpbml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgZ3JhcGhxbC5HcmFwaFFMRXJyb3IoJ0RlY2ltYWwgdmFsdWVzIG11c3QgYmUgZmluaXRlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2ltYWw7XG4gIH0sXG5cbiAgcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChEZWNpbWFsJDEuRGVjaW1hbC5pc0RlY2ltYWwodmFsdWUpKSB7XG4gICAgICBpZiAoIXZhbHVlLmlzRmluaXRlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKCdEZWNpbWFsIHZhbHVlcyBtdXN0IGJlIGZpbml0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBncmFwaHFsLkdyYXBoUUxFcnJvcignRGVjaW1hbCBvbmx5IGFjY2VwdHMgdmFsdWVzIGFzIHN0cmluZ3MnKTtcbiAgICB9XG5cbiAgICBsZXQgZGVjaW1hbCA9IG5ldyBEZWNpbWFsJDEuRGVjaW1hbCh2YWx1ZSk7XG5cbiAgICBpZiAoIWRlY2ltYWwuaXNGaW5pdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKCdEZWNpbWFsIHZhbHVlcyBtdXN0IGJlIGZpbml0ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNpbWFsO1xuICB9XG5cbn0pKTsgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXhjaXRlbWVudC1lbmdpbmVlci9ncmFwaHFsLWlzby1kYXRlL2Jsb2IvbWFzdGVyL3NyYy91dGlscy92YWxpZGF0b3IuanMjTDEyMVxuLy8gdGhpcyBpcyBhbHNvIHdoYXQgcHJpc21hIHVzZXMgaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvYmxvYi8yMGI1OGZlNjVkNTgxYmNiNDNjMGQ1YzI4ZDRiODljYWJjMmQ5OWIyL3BhY2thZ2VzL2NsaWVudC9zcmMvcnVudGltZS91dGlscy9jb21tb24udHMjTDEyNi1MMTI4XG5cbmNvbnN0IFJGQ18zMzM5X1JFR0VYID0gL14oXFxkezR9LSgwWzEtOV18MVswMTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlUKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkpKFxcLlxcZHsxLH0pPygoW1pdKXwoWyt8LV0oWzAxXVswLTldfDJbMC0zXSk6WzAtNV1bMC05XSkpJC87XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShpbnB1dCkge1xuICBpZiAoIVJGQ18zMzM5X1JFR0VYLnRlc3QoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKCdEYXRlVGltZSBzY2FsYXJzIG11c3QgYmUgaW4gdGhlIGZvcm0gb2YgYSBmdWxsIElTTyA4NjAxIGRhdGUtdGltZSBzdGlybmcnKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBEYXRlKGlucHV0KTtcblxuICBpZiAoaXNOYU4ocGFyc2VkLnZhbHVlT2YoKSkpIHtcbiAgICB0aHJvdyBuZXcgZ3JhcGhxbC5HcmFwaFFMRXJyb3IoJ0RhdGVUaW1lIHNjYWxhcnMgbXVzdCBiZSBpbiB0aGUgZm9ybSBvZiBhIGZ1bGwgSVNPIDg2MDEgZGF0ZS10aW1lIHN0aXJuZycpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuY29uc3QgRGF0ZVRpbWUgPSBncmFwaHFsVHNTY2hlbWFfX25hbWVzcGFjZS5ncmFwaHFsLnNjYWxhcihuZXcgZ3JhcGhxbC5HcmFwaFFMU2NhbGFyVHlwZSh7XG4gIG5hbWU6ICdEYXRlVGltZScsXG4gIHNwZWNpZmllZEJ5VXJsOiAnaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42JyxcblxuICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHx8IGlzTmFOKHZhbHVlLnZhbHVlT2YoKSkpIHtcbiAgICAgIHRocm93IG5ldyBncmFwaHFsLkdyYXBoUUxFcnJvcihgdW5leHBlY3RlZCB2YWx1ZSBwcm92aWRlZCB0byBEYXRlVGltZSBzY2FsYXI6ICR7dmFsdWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gIH0sXG5cbiAgcGFyc2VMaXRlcmFsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmtpbmQgIT09ICdTdHJpbmdWYWx1ZScpIHtcbiAgICAgIHRocm93IG5ldyBncmFwaHFsLkdyYXBoUUxFcnJvcignRGF0ZVRpbWUgb25seSBhY2NlcHRzIHZhbHVlcyBhcyBzdHJpbmdzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRGF0ZSh2YWx1ZS52YWx1ZSk7XG4gIH0sXG5cbiAgcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IGdyYXBocWwuR3JhcGhRTEVycm9yKCdEYXRlVGltZSBvbmx5IGFjY2VwdHMgdmFsdWVzIGFzIHN0cmluZ3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VEYXRlKHZhbHVlKTtcbiAgfVxuXG59KSk7XG5cbnZhciBncmFwaHFsQm91bmRUb0tleXN0b25lQ29udGV4dCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBKU09OOiBKU09OLFxuICBVcGxvYWQ6IFVwbG9hZCxcbiAgRGVjaW1hbDogRGVjaW1hbCxcbiAgRGF0ZVRpbWU6IERhdGVUaW1lLFxuICBCb29sZWFuOiBhcGlXaXRob3V0Q29udGV4dC5Cb29sZWFuLFxuICBGbG9hdDogYXBpV2l0aG91dENvbnRleHQuRmxvYXQsXG4gIElEOiBhcGlXaXRob3V0Q29udGV4dC5JRCxcbiAgSW50OiBhcGlXaXRob3V0Q29udGV4dC5JbnQsXG4gIFN0cmluZzogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nLFxuICAnZW51bSc6IGFwaVdpdGhvdXRDb250ZXh0W1wiZW51bVwiXSxcbiAgZW51bVZhbHVlczogYXBpV2l0aG91dENvbnRleHQuZW51bVZhbHVlcyxcbiAgYXJnOiBhcGlXaXRob3V0Q29udGV4dC5hcmcsXG4gIGlucHV0T2JqZWN0OiBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCxcbiAgbGlzdDogYXBpV2l0aG91dENvbnRleHQubGlzdCxcbiAgbm9uTnVsbDogYXBpV2l0aG91dENvbnRleHQubm9uTnVsbCxcbiAgc2NhbGFyOiBhcGlXaXRob3V0Q29udGV4dC5zY2FsYXIsXG4gIGJpbmRHcmFwaFFMU2NoZW1hQVBJVG9Db250ZXh0OiBncmFwaHFsVHNTY2hlbWEuYmluZEdyYXBoUUxTY2hlbWFBUElUb0NvbnRleHQsXG4gIGZpZWxkOiBhcGlXaXRoQ29udGV4dC5maWVsZCxcbiAgZmllbGRzOiBhcGlXaXRoQ29udGV4dC5maWVsZHMsXG4gICdpbnRlcmZhY2UnOiBhcGlXaXRoQ29udGV4dFtcImludGVyZmFjZVwiXSxcbiAgaW50ZXJmYWNlRmllbGQ6IGFwaVdpdGhDb250ZXh0LmludGVyZmFjZUZpZWxkLFxuICBvYmplY3Q6IGFwaVdpdGhDb250ZXh0Lm9iamVjdCxcbiAgdW5pb246IGFwaVdpdGhDb250ZXh0LnVuaW9uXG59KTtcblxuZXhwb3J0cy5EYXRlVGltZSA9IERhdGVUaW1lO1xuZXhwb3J0cy5EZWNpbWFsID0gRGVjaW1hbDtcbmV4cG9ydHMuSlNPTiA9IEpTT047XG5leHBvcnRzLlVwbG9hZCA9IFVwbG9hZDtcbmV4cG9ydHMuZ3JhcGhxbEJvdW5kVG9LZXlzdG9uZUNvbnRleHQgPSBncmFwaHFsQm91bmRUb0tleXN0b25lQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdyYXBocWxUc1NjaGVtYSA9IHJlcXVpcmUoJy4vZ3JhcGhxbC10cy1zY2hlbWEtZmNlN2E2YTguY2pzLmRldi5qcycpO1xudmFyIF9vYmplY3RTcHJlYWQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRvb2xzL3NjaGVtYScpO1xudmFyIGFwaVdpdGhvdXRDb250ZXh0ID0gcmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRob3V0LWNvbnRleHQnKTtcblxuY29uc3Qgb3JkZXJEaXJlY3Rpb25FbnVtID0gYXBpV2l0aG91dENvbnRleHRbXCJlbnVtXCJdKHtcbiAgbmFtZTogJ09yZGVyRGlyZWN0aW9uJyxcbiAgdmFsdWVzOiBhcGlXaXRob3V0Q29udGV4dC5lbnVtVmFsdWVzKFsnYXNjJywgJ2Rlc2MnXSlcbn0pO1xuY29uc3QgUXVlcnlNb2RlID0gYXBpV2l0aG91dENvbnRleHRbXCJlbnVtXCJdKHtcbiAgbmFtZTogJ1F1ZXJ5TW9kZScsXG4gIHZhbHVlczogYXBpV2l0aG91dENvbnRleHQuZW51bVZhbHVlcyhbJ2RlZmF1bHQnLCAnaW5zZW5zaXRpdmUnXSlcbn0pO1xuLy8gZmllbGRUeXBlKGRiRmllbGQpKGZpZWxkSW5mbykgPT4geyAuLi5maWVsZEluZm8sIGRiRmllbGQgfTtcbmZ1bmN0aW9uIGZpZWxkVHlwZShkYkZpZWxkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZ3JhcGhRTEluZm8pIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBncmFwaFFMSW5mbyksIHt9LCB7XG4gICAgICBkYkZpZWxkXG4gICAgfSk7XG4gIH07XG59XG5cbi8vIChldmVuIHRob3VnaCwgeWVzLCBoYXZpbmcgRW51bUZpbHRlciBieSBkZWZpbmVkIGFzIEVudW1OdWxsYWJsZUZpbHRlcjxFbnVtPiwgd291bGQgYmUgdGhlIHNhbWUgdHlwZSBidXQgbmFtZXMgd291bGQgc2hvdyB1cCBkaWZmZXJlbnRseSBpbiBlZGl0b3JzIGZvciBleGFtcGxlKVxuXG5mdW5jdGlvbiBlbnVtRmlsdGVycyhlbnVtVHlwZSkge1xuICBjb25zdCBvcHRpb25hbCA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgICBuYW1lOiBgJHtlbnVtVHlwZS5ncmFwaFFMVHlwZS5uYW1lfU51bGxhYmxlRmlsdGVyYCxcbiAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICAgIHR5cGU6IGVudW1UeXBlXG4gICAgICB9KSxcbiAgICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZW51bVR5cGUpKVxuICAgICAgfSksXG4gICAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGVudW1UeXBlKSlcbiAgICAgIH0pLFxuICAgICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgICB0eXBlOiBvcHRpb25hbFxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbiAgY29uc3QgcmVxdWlyZWQgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gICAgbmFtZTogYCR7ZW51bVR5cGUuZ3JhcGhRTFR5cGUubmFtZX1GaWx0ZXJgLFxuICAgIGZpZWxkczogKCkgPT4gKHtcbiAgICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgICAgdHlwZTogZW51bVR5cGVcbiAgICAgIH0pLFxuICAgICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChlbnVtVHlwZSkpXG4gICAgICB9KSxcbiAgICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZW51bVR5cGUpKVxuICAgICAgfSksXG4gICAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICAgIHR5cGU6IG9wdGlvbmFsXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xuICBjb25zdCBtYW55ID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICAgIG5hbWU6IGAke2VudW1UeXBlLmdyYXBoUUxUeXBlLm5hbWV9TnVsbGFibGVMaXN0RmlsdGVyYCxcbiAgICBmaWVsZHM6ICgpID0+ICh7XG4gICAgICAvLyBjYW4gYmUgbnVsbFxuICAgICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZW51bVR5cGUpKVxuICAgICAgfSksXG4gICAgICAvLyBjYW4gYmUgbnVsbFxuICAgICAgaGFzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgICB0eXBlOiBlbnVtVHlwZVxuICAgICAgfSksXG4gICAgICBoYXNFdmVyeTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGVudW1UeXBlKSlcbiAgICAgIH0pLFxuICAgICAgaGFzU29tZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGVudW1UeXBlKSlcbiAgICAgIH0pLFxuICAgICAgaXNFbXB0eTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgICAgdHlwZTogZW51bVR5cGVcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb3B0aW9uYWwsXG4gICAgcmVxdWlyZWQsXG4gICAgbWFueVxuICB9O1xufVxuXG4vLyBEbyBub3QgbWFudWFsbHkgbW9kaWZ5IHRoaXMgZmlsZSwgaXQgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIHBhY2thZ2UgYXQgL3ByaXNtYS11dGlscyBpbiB0aGlzIHJlcG8uXG5jb25zdCBTdHJpbmdOdWxsYWJsZUZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnU3RyaW5nTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBjb250YWluczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIHN0YXJ0c1dpdGg6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBlbmRzV2l0aDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIG1vZGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBRdWVyeU1vZGVcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IE5lc3RlZFN0cmluZ051bGxhYmxlRmlsdGVyJDFcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBOZXN0ZWRTdHJpbmdOdWxsYWJsZUZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnTmVzdGVkU3RyaW5nTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBjb250YWluczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIHN0YXJ0c1dpdGg6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBlbmRzV2l0aDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogTmVzdGVkU3RyaW5nTnVsbGFibGVGaWx0ZXIkMVxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IFN0cmluZ0ZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnU3RyaW5nRmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuU3RyaW5nKSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgY29udGFpbnM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBzdGFydHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZW5kc1dpdGg6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBtb2RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogUXVlcnlNb2RlXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogTmVzdGVkU3RyaW5nRmlsdGVyJDFcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBOZXN0ZWRTdHJpbmdGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ05lc3RlZFN0cmluZ0ZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGNvbnRhaW5zOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgc3RhcnRzV2l0aDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGVuZHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogTmVzdGVkU3RyaW5nRmlsdGVyJDFcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBTdHJpbmdOdWxsYWJsZUxpc3RGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdTdHJpbmdOdWxsYWJsZUxpc3RGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuU3RyaW5nKSlcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGhhczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGhhc0V2ZXJ5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgaGFzU29tZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIGlzRW1wdHk6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5Cb29sZWFuXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgQm9vbE51bGxhYmxlRmlsdGVyJDEgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdCb29sZWFuTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5Cb29sZWFuXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBCb29sTnVsbGFibGVGaWx0ZXIkMVxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IEJvb2xGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0Jvb2xlYW5GaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuQm9vbGVhblxuICAgIH0pLFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IEJvb2xGaWx0ZXIkMVxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IEJvb2xOdWxsYWJsZUxpc3RGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdCb29sZWFuTnVsbGFibGVMaXN0RmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkJvb2xlYW4pKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaGFzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuQm9vbGVhblxuICAgIH0pLFxuICAgIGhhc0V2ZXJ5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkJvb2xlYW4pKVxuICAgIH0pLFxuICAgIGhhc1NvbWU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuQm9vbGVhbikpXG4gICAgfSksXG4gICAgaXNFbXB0eTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkJvb2xlYW5cbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBJbnROdWxsYWJsZUZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnSW50TnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkludCkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5JbnQpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IEludE51bGxhYmxlRmlsdGVyJDFcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBJbnRGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0ludEZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5JbnQpKVxuICAgIH0pLFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkludCkpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkludFxuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkludFxuICAgIH0pLFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IEludEZpbHRlciQxXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgSW50TnVsbGFibGVMaXN0RmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnSW50TnVsbGFibGVMaXN0RmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkludCkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBoYXM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBoYXNFdmVyeTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5JbnQpKVxuICAgIH0pLFxuICAgIGhhc1NvbWU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuSW50KSlcbiAgICB9KSxcbiAgICBpc0VtcHR5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuQm9vbGVhblxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IEZsb2F0TnVsbGFibGVGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0Zsb2F0TnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogRmxvYXROdWxsYWJsZUZpbHRlciQxXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRmxvYXRGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0Zsb2F0RmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0XG4gICAgfSksXG4gICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0KSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0XG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0XG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBGbG9hdEZpbHRlciQxXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRmxvYXROdWxsYWJsZUxpc3RGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdGbG9hdE51bGxhYmxlTGlzdEZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5GbG9hdCkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBoYXM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIGhhc0V2ZXJ5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0KSlcbiAgICB9KSxcbiAgICBoYXNTb21lOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkZsb2F0KSlcbiAgICB9KSxcbiAgICBpc0VtcHR5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuQm9vbGVhblxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IERhdGVUaW1lTnVsbGFibGVGaWx0ZXIkMSA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RhdGVUaW1lTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZSkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWUpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IERhdGVUaW1lTnVsbGFibGVGaWx0ZXIkMVxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IERhdGVUaW1lRmlsdGVyJDEgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdEYXRlVGltZUZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWUpKVxuICAgIH0pLFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZSkpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZVxuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZVxuICAgIH0pLFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IERhdGVUaW1lRmlsdGVyJDFcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBEYXRlVGltZU51bGxhYmxlTGlzdEZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RhdGVUaW1lTnVsbGFibGVMaXN0RmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZSkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBoYXM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBoYXNFdmVyeTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWUpKVxuICAgIH0pLFxuICAgIGhhc1NvbWU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lKSlcbiAgICB9KSxcbiAgICBpc0VtcHR5OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuQm9vbGVhblxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IERlY2ltYWxOdWxsYWJsZUZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnRGVjaW1hbE51bGxhYmxlRmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsKSlcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsKSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsXG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsXG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IERlY2ltYWxOdWxsYWJsZUZpbHRlciQxXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRGVjaW1hbEZpbHRlciQxID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnRGVjaW1hbEZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsKSlcbiAgICB9KSxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGVjaW1hbCkpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsXG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EZWNpbWFsXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogRGVjaW1hbEZpbHRlciQxXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRGVjaW1hbE51bGxhYmxlTGlzdEZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RlY2ltYWxOdWxsYWJsZUxpc3RGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWwpKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaGFzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBoYXNFdmVyeTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGVjaW1hbCkpXG4gICAgfSksXG4gICAgaGFzU29tZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGVjaW1hbCkpXG4gICAgfSksXG4gICAgaXNFbXB0eTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkJvb2xlYW5cbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBTdHJpbmckMSA9IHtcbiAgb3B0aW9uYWw6IFN0cmluZ051bGxhYmxlRmlsdGVyJDEsXG4gIHJlcXVpcmVkOiBTdHJpbmdGaWx0ZXIkMSxcbiAgbWFueTogU3RyaW5nTnVsbGFibGVMaXN0RmlsdGVyXG59O1xuY29uc3QgQm9vbGVhbiQxID0ge1xuICBvcHRpb25hbDogQm9vbE51bGxhYmxlRmlsdGVyJDEsXG4gIHJlcXVpcmVkOiBCb29sRmlsdGVyJDEsXG4gIG1hbnk6IEJvb2xOdWxsYWJsZUxpc3RGaWx0ZXJcbn07XG5jb25zdCBJbnQkMSA9IHtcbiAgb3B0aW9uYWw6IEludE51bGxhYmxlRmlsdGVyJDEsXG4gIHJlcXVpcmVkOiBJbnRGaWx0ZXIkMSxcbiAgbWFueTogSW50TnVsbGFibGVMaXN0RmlsdGVyXG59O1xuY29uc3QgRmxvYXQkMSA9IHtcbiAgb3B0aW9uYWw6IEZsb2F0TnVsbGFibGVGaWx0ZXIkMSxcbiAgcmVxdWlyZWQ6IEZsb2F0RmlsdGVyJDEsXG4gIG1hbnk6IEZsb2F0TnVsbGFibGVMaXN0RmlsdGVyXG59O1xuY29uc3QgRGF0ZVRpbWUkMSA9IHtcbiAgb3B0aW9uYWw6IERhdGVUaW1lTnVsbGFibGVGaWx0ZXIkMSxcbiAgcmVxdWlyZWQ6IERhdGVUaW1lRmlsdGVyJDEsXG4gIG1hbnk6IERhdGVUaW1lTnVsbGFibGVMaXN0RmlsdGVyXG59O1xuY29uc3QgRGVjaW1hbCQxID0ge1xuICBvcHRpb25hbDogRGVjaW1hbE51bGxhYmxlRmlsdGVyJDEsXG4gIHJlcXVpcmVkOiBEZWNpbWFsRmlsdGVyJDEsXG4gIG1hbnk6IERlY2ltYWxOdWxsYWJsZUxpc3RGaWx0ZXJcbn07XG5cbnZhciBwb3N0Z3Jlc3FsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFN0cmluZzogU3RyaW5nJDEsXG4gIEJvb2xlYW46IEJvb2xlYW4kMSxcbiAgSW50OiBJbnQkMSxcbiAgRmxvYXQ6IEZsb2F0JDEsXG4gIERhdGVUaW1lOiBEYXRlVGltZSQxLFxuICBEZWNpbWFsOiBEZWNpbWFsJDEsXG4gICdlbnVtJzogZW51bUZpbHRlcnNcbn0pO1xuXG4vLyBEbyBub3QgbWFudWFsbHkgbW9kaWZ5IHRoaXMgZmlsZSwgaXQgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIHBhY2thZ2UgYXQgL3ByaXNtYS11dGlscyBpbiB0aGlzIHJlcG8uXG5jb25zdCBTdHJpbmdOdWxsYWJsZUZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ1N0cmluZ051bGxhYmxlRmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuU3RyaW5nKSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgY29udGFpbnM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBzdGFydHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZW5kc1dpdGg6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IE5lc3RlZFN0cmluZ051bGxhYmxlRmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgTmVzdGVkU3RyaW5nTnVsbGFibGVGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdOZXN0ZWRTdHJpbmdOdWxsYWJsZUZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuU3RyaW5nKSlcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGNvbnRhaW5zOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgc3RhcnRzV2l0aDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGVuZHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBOZXN0ZWRTdHJpbmdOdWxsYWJsZUZpbHRlclxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IFN0cmluZ0ZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ1N0cmluZ0ZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5TdHJpbmcpKVxuICAgIH0pLFxuICAgIG5vdEluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgbHQ6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBndDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGNvbnRhaW5zOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgc3RhcnRzV2l0aDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGVuZHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogTmVzdGVkU3RyaW5nRmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgTmVzdGVkU3RyaW5nRmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnTmVzdGVkU3RyaW5nRmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZykpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuU3RyaW5nKSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LlN0cmluZ1xuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgY29udGFpbnM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBzdGFydHNXaXRoOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuU3RyaW5nXG4gICAgfSksXG4gICAgZW5kc1dpdGg6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5TdHJpbmdcbiAgICB9KSxcbiAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBOZXN0ZWRTdHJpbmdGaWx0ZXJcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBCb29sTnVsbGFibGVGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdCb29sZWFuTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5Cb29sZWFuXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBCb29sTnVsbGFibGVGaWx0ZXJcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBCb29sRmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnQm9vbGVhbkZpbHRlcicsXG4gIGZpZWxkczogKCkgPT4gKHtcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5Cb29sZWFuXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogQm9vbEZpbHRlclxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IEludE51bGxhYmxlRmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnSW50TnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkludCkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5JbnQpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5JbnRcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IEludE51bGxhYmxlRmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgSW50RmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnSW50RmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkludFxuICAgIH0pLFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGFwaVdpdGhvdXRDb250ZXh0LkludCkpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuSW50KSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkludFxuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0LkludFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuSW50XG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogSW50RmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRmxvYXROdWxsYWJsZUZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0Zsb2F0TnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogRmxvYXROdWxsYWJsZUZpbHRlclxuICAgIH0pXG4gIH0pXG59KTtcbmNvbnN0IEZsb2F0RmlsdGVyID0gYXBpV2l0aG91dENvbnRleHQuaW5wdXRPYmplY3Qoe1xuICBuYW1lOiAnRmxvYXRGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChhcGlXaXRob3V0Q29udGV4dC5GbG9hdCkpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoYXBpV2l0aG91dENvbnRleHQuRmxvYXQpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQuRmxvYXRcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5GbG9hdFxuICAgIH0pLFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IEZsb2F0RmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRGF0ZVRpbWVOdWxsYWJsZUZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RhdGVUaW1lTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZSkpXG4gICAgfSksXG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBub3RJbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWUpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgbHRlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgZ3Q6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGF0ZVRpbWVcbiAgICB9KSxcbiAgICAvLyBjYW4gYmUgbnVsbFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IERhdGVUaW1lTnVsbGFibGVGaWx0ZXJcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBEYXRlVGltZUZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RhdGVUaW1lRmlsdGVyJyxcbiAgZmllbGRzOiAoKSA9PiAoe1xuICAgIGVxdWFsczogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZVxuICAgIH0pLFxuICAgIGluOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogYXBpV2l0aG91dENvbnRleHQubGlzdChhcGlXaXRob3V0Q29udGV4dC5ub25OdWxsKGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZSkpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lKSlcbiAgICB9KSxcbiAgICBsdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZVxuICAgIH0pLFxuICAgIGx0ZTogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGdyYXBocWxUc1NjaGVtYS5EYXRlVGltZVxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgZ3RlOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRhdGVUaW1lXG4gICAgfSksXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogRGF0ZVRpbWVGaWx0ZXJcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBEZWNpbWFsTnVsbGFibGVGaWx0ZXIgPSBhcGlXaXRob3V0Q29udGV4dC5pbnB1dE9iamVjdCh7XG4gIG5hbWU6ICdEZWNpbWFsTnVsbGFibGVGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgLy8gY2FuIGJlIG51bGxcbiAgICBlcXVhbHM6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgaW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWwpKVxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWwpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIC8vIGNhbiBiZSBudWxsXG4gICAgbm90OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogRGVjaW1hbE51bGxhYmxlRmlsdGVyXG4gICAgfSlcbiAgfSlcbn0pO1xuY29uc3QgRGVjaW1hbEZpbHRlciA9IGFwaVdpdGhvdXRDb250ZXh0LmlucHV0T2JqZWN0KHtcbiAgbmFtZTogJ0RlY2ltYWxGaWx0ZXInLFxuICBmaWVsZHM6ICgpID0+ICh7XG4gICAgZXF1YWxzOiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBpbjogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IGFwaVdpdGhvdXRDb250ZXh0Lmxpc3QoYXBpV2l0aG91dENvbnRleHQubm9uTnVsbChncmFwaHFsVHNTY2hlbWEuRGVjaW1hbCkpXG4gICAgfSksXG4gICAgbm90SW46IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBhcGlXaXRob3V0Q29udGV4dC5saXN0KGFwaVdpdGhvdXRDb250ZXh0Lm5vbk51bGwoZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWwpKVxuICAgIH0pLFxuICAgIGx0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBsdGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIGd0OiBhcGlXaXRob3V0Q29udGV4dC5hcmcoe1xuICAgICAgdHlwZTogZ3JhcGhxbFRzU2NoZW1hLkRlY2ltYWxcbiAgICB9KSxcbiAgICBndGU6IGFwaVdpdGhvdXRDb250ZXh0LmFyZyh7XG4gICAgICB0eXBlOiBncmFwaHFsVHNTY2hlbWEuRGVjaW1hbFxuICAgIH0pLFxuICAgIG5vdDogYXBpV2l0aG91dENvbnRleHQuYXJnKHtcbiAgICAgIHR5cGU6IERlY2ltYWxGaWx0ZXJcbiAgICB9KVxuICB9KVxufSk7XG5jb25zdCBTdHJpbmcgPSB7XG4gIG9wdGlvbmFsOiBTdHJpbmdOdWxsYWJsZUZpbHRlcixcbiAgcmVxdWlyZWQ6IFN0cmluZ0ZpbHRlclxufTtcbmNvbnN0IEJvb2xlYW4gPSB7XG4gIG9wdGlvbmFsOiBCb29sTnVsbGFibGVGaWx0ZXIsXG4gIHJlcXVpcmVkOiBCb29sRmlsdGVyXG59O1xuY29uc3QgSW50ID0ge1xuICBvcHRpb25hbDogSW50TnVsbGFibGVGaWx0ZXIsXG4gIHJlcXVpcmVkOiBJbnRGaWx0ZXJcbn07XG5jb25zdCBGbG9hdCA9IHtcbiAgb3B0aW9uYWw6IEZsb2F0TnVsbGFibGVGaWx0ZXIsXG4gIHJlcXVpcmVkOiBGbG9hdEZpbHRlclxufTtcbmNvbnN0IERhdGVUaW1lID0ge1xuICBvcHRpb25hbDogRGF0ZVRpbWVOdWxsYWJsZUZpbHRlcixcbiAgcmVxdWlyZWQ6IERhdGVUaW1lRmlsdGVyXG59O1xuY29uc3QgRGVjaW1hbCA9IHtcbiAgb3B0aW9uYWw6IERlY2ltYWxOdWxsYWJsZUZpbHRlcixcbiAgcmVxdWlyZWQ6IERlY2ltYWxGaWx0ZXJcbn07XG5cbnZhciBzcWxpdGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU3RyaW5nOiBTdHJpbmcsXG4gIEJvb2xlYW46IEJvb2xlYW4sXG4gIEludDogSW50LFxuICBGbG9hdDogRmxvYXQsXG4gIERhdGVUaW1lOiBEYXRlVGltZSxcbiAgRGVjaW1hbDogRGVjaW1hbCxcbiAgJ2VudW0nOiBlbnVtRmlsdGVyc1xufSk7XG5cbmV4cG9ydHMuUXVlcnlNb2RlID0gUXVlcnlNb2RlO1xuZXhwb3J0cy5maWVsZFR5cGUgPSBmaWVsZFR5cGU7XG5leHBvcnRzLm9yZGVyRGlyZWN0aW9uRW51bSA9IG9yZGVyRGlyZWN0aW9uRW51bTtcbmV4cG9ydHMucG9zdGdyZXNxbCA9IHBvc3RncmVzcWw7XG5leHBvcnRzLnNxbGl0ZSA9IHNxbGl0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpc0RlZXBFcXVhbCA9IHJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpO1xudmFyIGdldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vZ2V0Um9vdEdyYXBoUUxGaWVsZHNGcm9tRmllbGRDb250cm9sbGVyLTQ3Njk5YTBkLmNqcy5kZXYuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBpc0RlZXBFcXVhbF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoaXNEZWVwRXF1YWwpO1xuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKGZpZWxkcywgaXRlbUdldHRlcikge1xuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goZmllbGRLZXkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ZpZWxkS2V5XTtcbiAgICBjb25zdCBpdGVtRm9yRmllbGQgPSB7fTtcbiAgICBjb25zdCBlcnJvcnMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IGdyYXBocWxGaWVsZCBvZiBnZXRSb290R3JhcGhRTEZpZWxkc0Zyb21GaWVsZENvbnRyb2xsZXIuZ2V0Um9vdEdyYXBoUUxGaWVsZHNGcm9tRmllbGRDb250cm9sbGVyKGZpZWxkLmNvbnRyb2xsZXIpKSB7XG4gICAgICBjb25zdCBmaWVsZEdldHRlciA9IGl0ZW1HZXR0ZXIuZ2V0KGdyYXBocWxGaWVsZCk7XG5cbiAgICAgIGlmIChmaWVsZEdldHRlci5lcnJvcnMpIHtcbiAgICAgICAgZmllbGRHZXR0ZXIuZXJyb3JzLmZvckVhY2goZXJyb3IgPT4ge1xuICAgICAgICAgIGVycm9ycy5hZGQoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaXRlbUZvckZpZWxkW2dyYXBocWxGaWVsZF0gPSBmaWVsZEdldHRlci5kYXRhO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMuc2l6ZSkge1xuICAgICAgdmFsdWVbZmllbGRLZXldID0ge1xuICAgICAgICBraW5kOiAnZXJyb3InLFxuICAgICAgICBlcnJvcnM6IFsuLi5lcnJvcnNdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVtmaWVsZEtleV0gPSB7XG4gICAgICAgIGtpbmQ6ICd2YWx1ZScsXG4gICAgICAgIHZhbHVlOiBmaWVsZC5jb250cm9sbGVyLmRlc2VyaWFsaXplKGl0ZW1Gb3JGaWVsZClcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVmFsdWVUb09iakJ5RmllbGRLZXkoZmllbGRzLCB2YWx1ZSkge1xuICBjb25zdCBvYmogPSB7fTtcbiAgT2JqZWN0LmtleXMoZmllbGRzKS5tYXAoZmllbGRLZXkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHZhbHVlW2ZpZWxkS2V5XTtcblxuICAgIGlmICh2YWwua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgb2JqW2ZpZWxkS2V5XSA9IGZpZWxkc1tmaWVsZEtleV0uY29udHJvbGxlci5zZXJpYWxpemUodmFsLnZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB1c2VDaGFuZ2VkRmllbGRzQW5kRGF0YUZvclVwZGF0ZShmaWVsZHMsIGl0ZW1HZXR0ZXIsIHZhbHVlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZXNGcm9tSXRlbSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZGVzZXJpYWxpemVWYWx1ZShmaWVsZHMsIGl0ZW1HZXR0ZXIpO1xuICAgIHJldHVybiBzZXJpYWxpemVWYWx1ZVRvT2JqQnlGaWVsZEtleShmaWVsZHMsIHZhbHVlKTtcbiAgfSwgW2ZpZWxkcywgaXRlbUdldHRlcl0pO1xuICBjb25zdCBzZXJpYWxpemVkRmllbGRWYWx1ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gc2VyaWFsaXplVmFsdWVUb09iakJ5RmllbGRLZXkoZmllbGRzLCB2YWx1ZSk7XG4gIH0sIFt2YWx1ZSwgZmllbGRzXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgY2hhbmdlZEZpZWxkcyA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3Qua2V5cyhzZXJpYWxpemVkRmllbGRWYWx1ZXMpLmZvckVhY2goZmllbGRLZXkgPT4ge1xuICAgICAgbGV0IGlzRXF1YWwgPSBpc0RlZXBFcXVhbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oc2VyaWFsaXplZEZpZWxkVmFsdWVzW2ZpZWxkS2V5XSwgc2VyaWFsaXplZFZhbHVlc0Zyb21JdGVtW2ZpZWxkS2V5XSk7XG5cbiAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICBjaGFuZ2VkRmllbGRzLmFkZChmaWVsZEtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YUZvclVwZGF0ZSA9IHt9O1xuICAgIGNoYW5nZWRGaWVsZHMuZm9yRWFjaChmaWVsZEtleSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFGb3JVcGRhdGUsIHNlcmlhbGl6ZWRGaWVsZFZhbHVlc1tmaWVsZEtleV0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjaGFuZ2VkRmllbGRzOiBjaGFuZ2VkRmllbGRzLFxuICAgICAgZGF0YUZvclVwZGF0ZVxuICAgIH07XG4gIH0sIFtzZXJpYWxpemVkRmllbGRWYWx1ZXMsIHNlcmlhbGl6ZWRWYWx1ZXNGcm9tSXRlbV0pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnZhbGlkRmllbGRzKGZpZWxkcywgdmFsdWUpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGludmFsaWRGaWVsZHMgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZmllbGRQYXRoID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2ZpZWxkUGF0aF07XG5cbiAgICAgIGlmICh2YWwua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUZuID0gZmllbGRzW2ZpZWxkUGF0aF0uY29udHJvbGxlci52YWxpZGF0ZTtcblxuICAgICAgICBpZiAodmFsaWRhdGVGbikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlRm4odmFsLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpbnZhbGlkRmllbGRzLmFkZChmaWVsZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbnZhbGlkRmllbGRzO1xuICB9LCBbZmllbGRzLCB2YWx1ZV0pO1xufVxuXG5leHBvcnRzLmRlc2VyaWFsaXplVmFsdWUgPSBkZXNlcmlhbGl6ZVZhbHVlO1xuZXhwb3J0cy5zZXJpYWxpemVWYWx1ZVRvT2JqQnlGaWVsZEtleSA9IHNlcmlhbGl6ZVZhbHVlVG9PYmpCeUZpZWxkS2V5O1xuZXhwb3J0cy51c2VDaGFuZ2VkRmllbGRzQW5kRGF0YUZvclVwZGF0ZSA9IHVzZUNoYW5nZWRGaWVsZHNBbmREYXRhRm9yVXBkYXRlO1xuZXhwb3J0cy51c2VJbnZhbGlkRmllbGRzID0gdXNlSW52YWxpZEZpZWxkcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gdXNlRm9ybWF0dGVkSW5wdXQoY29uZmlnLCB7XG4gIHZhbHVlLFxuICBvbkNoYW5nZSxcbiAgb25CbHVyLFxuICBvbkZvY3VzXG59KSB7XG4gIC8vIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgaW1wbGllcyB0aGUgdW5wYXJzZWQgZm9ybVxuICAvLyB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIGltcGxpZXMgdGhlIHBhcnNlZCBmb3JtXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjb25maWcucGFyc2UodmFsdWUpICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWQgdmFsdWVzIG11c3QgYmUgcGFzc2VkIGluIGFzIGEgcGFyc2VkIHZhbHVlLCBub3QgYSByYXcgdmFsdWUuIFRoZSB2YWx1ZSB5b3UgcGFzc2VkIHdhcyBcXGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXGAsIHlvdSBzaG91bGQgcGFzcyBcXGAke0pTT04uc3RyaW5naWZ5KGNvbmZpZy5wYXJzZSh2YWx1ZSkpfVxcYCBpbnN0ZWFkYCk7XG4gIH1cblxuICBsZXQgW2ludGVybmFsVmFsdWVTdGF0ZSwgc2V0SW50ZXJuYWxWYWx1ZVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IGNvbmZpZy5mb3JtYXQodmFsdWUpKTtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSAhPT0gaW50ZXJuYWxWYWx1ZVN0YXRlKSB7XG4gICAgc2V0SW50ZXJuYWxWYWx1ZVN0YXRlKHZhbHVlKTtcbiAgfSAvLyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLCB3ZSBrbm93IGl0J3MgaW4gdGhlIHBhcnNlZCBmb3JtXG5cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGNvbmZpZy5mb3JtYXQodmFsdWUpOyAvLyBXaGVuIHRoZSBpbnB1dCBpcyBibHVycmVkLCB3ZSB3YW50IHRvIHNob3cgYWx3YXlzIHNob3cgdGhlIGZvcm1hdHRlZFxuICAgIC8vIHZlcnNpb24gc28gaWYgd2UncmUgbm90IGZvY3Vzc2VkIGFuZCB0aGUgZm9ybWF0dGVkIHZlcnNpb24gaXMgZGlmZmVyZW50XG4gICAgLy8gdG8gdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2UgbmVlZCB0byB1cGRhdGUgaXQuXG5cbiAgICBpZiAoIWlzRm9jdXNlZCAmJiBmb3JtYXR0ZWQgIT09IGludGVybmFsVmFsdWVTdGF0ZSkge1xuICAgICAgc2V0SW50ZXJuYWxWYWx1ZVN0YXRlKGZvcm1hdHRlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkSW50ZXJuYWwgPSBjb25maWcucGFyc2UoaW50ZXJuYWxWYWx1ZVN0YXRlKTsgLy8gV2UgdXBkYXRpbmcgdGhlIGludGVybmFsIHZhbHVlIGhlcmUgYmVjYXVzZSB0aGVcbiAgICAvLyBleHRlcm5hbCB2YWx1ZSBoYXMgY2hhbmdlZC5cblxuICAgIGlmICh0eXBlb2YgcGFyc2VkSW50ZXJuYWwgIT09ICdzdHJpbmcnICYmIGNvbmZpZy5mb3JtYXQocGFyc2VkSW50ZXJuYWwpICE9PSBmb3JtYXR0ZWQpIHtcbiAgICAgIHNldEludGVybmFsVmFsdWVTdGF0ZShmb3JtYXR0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGludGVybmFsVmFsdWVTdGF0ZSxcblxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IGNvbmZpZy5wYXJzZSh2YWx1ZSk7XG4gICAgICBvbkNoYW5nZShwYXJzZWQpO1xuICAgICAgc2V0SW50ZXJuYWxWYWx1ZVN0YXRlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgb25Gb2N1cyhldmVudCkge1xuICAgICAgb25Gb2N1cyA9PT0gbnVsbCB8fCBvbkZvY3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkZvY3VzKGV2ZW50KTtcbiAgICAgIHNldElzRm9jdXNlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICBvbkJsdXIgPT09IG51bGwgfHwgb25CbHVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkJsdXIoZXZlbnQpO1xuICAgICAgc2V0SXNGb2N1c2VkKGZhbHNlKTsgLy8gdGhpcyBpc24ndCBzdHJpY3RseSBuZWNlc3Nhcnkgc2luY2Ugd2UgYWxyZWFkeSBkbyB0aGlzIGluIHJlbmRlclxuICAgICAgLy8gdGhpcyBqdXN0IHNhdmVzIGFub3RoZXIgcmVyZW5kZXIgYWZ0ZXIgc2V0SXNGb2N1c2VkKGZhbHNlKVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzZXRJbnRlcm5hbFZhbHVlU3RhdGUoY29uZmlnLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xufVxuXG5leHBvcnRzLnVzZUZvcm1hdHRlZElucHV0ID0gdXNlRm9ybWF0dGVkSW5wdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBmaWVsZHMgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvZmllbGRzJyk7XG52YXIgQ2VsbENvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvQ2VsbENvbnRhaW5lci00NTMyNTRiNS5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJ25leHQvcm91dGVyJyk7XG5yZXF1aXJlKCduZXh0L2xpbmsnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5Jyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvYnV0dG9uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxlcnRUcmlhbmdsZUljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b2FzdCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9tb2RhbHMnKTtcbnJlcXVpcmUoJ2Fwb2xsby11cGxvYWQtY2xpZW50Jyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnJlcXVpcmUoJ0BlbW90aW9uL2hhc2gnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3Qvc3FsaXRlLWFmOWU1MTQ4LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvZ3JhcGhxbC10cy1zY2hlbWEtZmNlN2E2YTguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvYWRtaW4tbWV0YS1ncmFwaHFsLTlmOWE5YzExLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9wb3BvdmVyJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTW9yZUhvcml6b250YWxJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ2hldnJvblJpZ2h0SWNvbicpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9TaWdub3V0QnV0dG9uLWFjZGIxNTU0LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL25vdGljZScpO1xucmVxdWlyZSgnZGVjaW1hbC5qcycpO1xucmVxdWlyZSgnQGdyYXBocWwtdG9vbHMvc2NoZW1hJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGhvdXQtY29udGV4dCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hJyk7XG5yZXF1aXJlKCdncmFwaHFsLXR5cGUtanNvbicpO1xucmVxdWlyZSgnZ3JhcGhxbC11cGxvYWQvcHVibGljL0dyYXBoUUxVcGxvYWQuanMnKTtcbnJlcXVpcmUoJ2dyYXBocWwnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aC1jb250ZXh0Jyk7XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5jb25zdCBGaWVsZCA9ICh7XG4gIGZpZWxkLFxuICB2YWx1ZSxcbiAgb25DaGFuZ2UsXG4gIGF1dG9Gb2N1c1xufSkgPT4ge1xuICBjb25zdCB7XG4gICAgZmllbGRzOiBmaWVsZHMkMSxcbiAgICB0eXBvZ3JhcGh5XG4gIH0gPSBjb3JlLnVzZVRoZW1lKCk7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5DaGVja2JveCwge1xuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIGRpc2FibGVkOiBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiB7XG4gICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogdmFsdWVcbiAgfSwgY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGZvbnRXZWlnaHQ6IHR5cG9ncmFwaHkuZm9udFdlaWdodC5zZW1pYm9sZCxcbiAgICAgIGNvbG9yOiBmaWVsZHMkMS5sYWJlbENvbG9yXG4gICAgfVxuICB9LCBmaWVsZC5sYWJlbCkpKTtcbn07XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGRcbn0pID0+IHtcbiAgY29uc3QgdmFsdWUgPSAhIWl0ZW1bZmllbGQucGF0aF07XG4gIHJldHVybiBjb3JlLmpzeChDZWxsQ29udGFpbmVyLkNlbGxDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5DaGVja2JveCwge1xuICAgIGRpc2FibGVkOiB0cnVlLFxuICAgIGNoZWNrZWQ6IHZhbHVlLFxuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCBjb3JlLmpzeChcInNwYW5cIiwge1xuICAgIGNzczoge31cbiAgfSwgdmFsdWUgPyAnVHJ1ZScgOiAnRmFsc2UnKSkpO1xufTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGl0ZW1bZmllbGQucGF0aF0gKyAnJyk7XG59O1xuY29uc3QgY29udHJvbGxlciA9IGNvbmZpZyA9PiB7XG4gIHJldHVybiB7XG4gICAgcGF0aDogY29uZmlnLnBhdGgsXG4gICAgbGFiZWw6IGNvbmZpZy5sYWJlbCxcbiAgICBncmFwaHFsU2VsZWN0aW9uOiBjb25maWcucGF0aCxcbiAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZy5maWVsZE1ldGEuZGVmYXVsdFZhbHVlLFxuXG4gICAgZGVzZXJpYWxpemUoaXRlbSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2NvbmZpZy5wYXRoXTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IHZhbHVlIDogZmFsc2U7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGZpbHRlcjoge1xuICAgICAgRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGdyYXBocWwoe1xuICAgICAgICB0eXBlXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgZXF1YWxzOiB0eXBlID09PSAnaXMnXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgTGFiZWwoe1xuICAgICAgICBsYWJlbFxuICAgICAgfSkge1xuICAgICAgICByZXR1cm4gbGFiZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0sXG5cbiAgICAgIHR5cGVzOiB7XG4gICAgICAgIGlzOiB7XG4gICAgICAgICAgbGFiZWw6ICdpcycsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG5vdDoge1xuICAgICAgICAgIGxhYmVsOiAnaXMgbm90JyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydHMuQ2FyZFZhbHVlID0gQ2FyZFZhbHVlO1xuZXhwb3J0cy5DZWxsID0gQ2VsbDtcbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmV4cG9ydHMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy1jaGVja2JveC12aWV3cy5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtY2hlY2tib3gtdmlld3MuY2pzLmRldi5qc1wiKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgSU1BR0VSRUdFWCA9IC9eKGxvY2FsfGtleXN0b25lLWNsb3VkKTppbWFnZTooW15cXFxcXFwvOlxcbl0rKVxcLihnaWZ8anBnfHBuZ3x3ZWJwKSQvO1xuY29uc3QgZ2V0SW1hZ2VSZWYgPSAobW9kZSwgaWQsIGV4dGVuc2lvbikgPT4gYCR7bW9kZX06aW1hZ2U6JHtpZH0uJHtleHRlbnNpb259YDtcbmNvbnN0IFNVUFBPUlRFRF9JTUFHRV9FWFRFTlNJT05TID0gWydqcGcnLCAncG5nJywgJ3dlYnAnLCAnZ2lmJ107XG5jb25zdCBwYXJzZUltYWdlUmVmID0gcmVmID0+IHtcbiAgY29uc3QgbWF0Y2ggPSByZWYubWF0Y2goSU1BR0VSRUdFWCk7XG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgWywgbW9kZSwgaWQsIGV4dF0gPSBtYXRjaDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGlkLFxuICAgICAgZXh0ZW5zaW9uOiBleHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydHMuU1VQUE9SVEVEX0lNQUdFX0VYVEVOU0lPTlMgPSBTVVBQT1JURURfSU1BR0VfRVhURU5TSU9OUztcbmV4cG9ydHMuZ2V0SW1hZ2VSZWYgPSBnZXRJbWFnZVJlZjtcbmV4cG9ydHMucGFyc2VJbWFnZVJlZiA9IHBhcnNlSW1hZ2VSZWY7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBmaWVsZHMgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvZmllbGRzJyk7XG52YXIgY29weSA9IHJlcXVpcmUoJ2NvcHktdG8tY2xpcGJvYXJkJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCdieXRlcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB0b2FzdCA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b2FzdCcpO1xudmFyIHBpbGwgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvcGlsbCcpO1xudmFyIGJ1dHRvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9idXR0b24nKTtcbnZhciBmaWVsZHNfdHlwZXNfaW1hZ2VfdXRpbHNfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUZpZWxkc1R5cGVzSW1hZ2VVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Rpc3Qva2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtaW1hZ2UtdXRpbHMuY2pzLmRldi5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGNvcHlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGNvcHkpO1xudmFyIGJ5dGVzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChieXRlcyk7XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5cbmZ1bmN0aW9uIHVzZU9iamVjdFVSTChmaWxlRGF0YSkge1xuICBsZXQgW29iamVjdFVSTCwgc2V0T2JqZWN0VVJMXSA9IFJlYWN0LnVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZpbGVEYXRhKSB7XG4gICAgICBsZXQgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlRGF0YSk7XG4gICAgICBzZXRPYmplY3RVUkwodXJsKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZmlsZURhdGFdKTtcbiAgcmV0dXJuIG9iamVjdFVSTDtcbn1cblxuY29uc3QgUmVmVmlldyA9ICh7XG4gIGZpZWxkLFxuICBvbkNoYW5nZSxcbiAgb25DYW5jZWwsXG4gIGVycm9yXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29yZS5qc3goY29yZS5WaXN1YWxseUhpZGRlbiwge1xuICAgIGh0bWxGb3I6IGAke2ZpZWxkLnBhdGh9LS1yZWYtaW5wdXRgLFxuICAgIGFzOiBcImxhYmVsXCJcbiAgfSwgJ1Bhc3RlIHRoZSBpbWFnZSByZWYgaGVyZScpLCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgYWNyb3NzOiB0cnVlLFxuICAgIGNzczoge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAnZGl2OmZpcnN0LW9mLXR5cGUnOiB7XG4gICAgICAgIGZsZXg6ICcyJ1xuICAgICAgfVxuICAgIH1cbiAgfSwgY29yZS5qc3goZmllbGRzLlRleHRJbnB1dCwge1xuICAgIGlkOiBgJHtmaWVsZC5wYXRofS0tcmVmLWlucHV0YCxcbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgcGxhY2Vob2xkZXI6IFwiUGFzdGUgdGhlIGltYWdlIHJlZiBoZXJlXCIsXG4gICAgb25DaGFuZ2U6IGV2ZW50ID0+IHtcbiAgICAgIG9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSxcbiAgICBjc3M6IHtcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9XG4gIH0pLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgdG9uZTogXCJwYXNzaXZlXCIsXG4gICAgb25DbGljazogb25DYW5jZWxcbiAgfSwgXCJDYW5jZWxcIiksIGVycm9yID8gY29yZS5qc3gocGlsbC5QaWxsLCB7XG4gICAgd2VpZ2h0OiBcImxpZ2h0XCIsXG4gICAgdG9uZTogXCJuZWdhdGl2ZVwiXG4gIH0sIGVycm9yKSA6IG51bGwpKTtcbn07XG5cbmZ1bmN0aW9uIEZpZWxkKHtcbiAgYXV0b0ZvY3VzLFxuICBmaWVsZCxcbiAgdmFsdWUsXG4gIGZvcmNlVmFsaWRhdGlvbixcbiAgb25DaGFuZ2Vcbn0pIHtcbiAgY29uc3QgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGNyZWF0ZUVycm9yTWVzc2FnZSh2YWx1ZSwgZm9yY2VWYWxpZGF0aW9uKTtcblxuICBjb25zdCBvblVwbG9hZENoYW5nZSA9ICh7XG4gICAgY3VycmVudFRhcmdldDoge1xuICAgICAgdmFsaWRpdHksXG4gICAgICBmaWxlc1xuICAgIH1cbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlcyA9PT0gbnVsbCB8fCBmaWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZXNbMF07XG4gICAgaWYgKCFmaWxlKSByZXR1cm47IC8vIGJhaWwgaWYgdGhlIHVzZXIgY2FuY2VscyBmcm9tIHRoZSBmaWxlIGJyb3dzZXJcblxuICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZSh7XG4gICAgICBraW5kOiAndXBsb2FkJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgdmFsaWRpdHlcbiAgICAgIH0sXG4gICAgICBwcmV2aW91czogdmFsdWVcbiAgICB9KTtcbiAgfTsgLy8gR2VuZXJhdGUgYSByYW5kb20gaW5wdXQga2V5IHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMsIHRvIGVuc3VyZSB0aGUgZmlsZSBpbnB1dCBpcyB1bm1vdW50ZWQgYW5kXG4gIC8vIHJlbW91bnRlZCAodGhpcyBpcyB0aGUgb25seSB3YXkgdG8gcmVzZXQgaXRzIHZhbHVlIGFuZCBlbnN1cmUgb25DaGFuZ2Ugd2lsbCBmaXJlIGFnYWluIGlmXG4gIC8vIHRoZSB1c2VyIHNlbGVjdHMgdGhlIHNhbWUgZmlsZSBhZ2FpbilcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG5cbiAgY29uc3QgaW5wdXRLZXkgPSBSZWFjdC51c2VNZW1vKCgpID0+IE1hdGgucmFuZG9tKCksIFt2YWx1ZV0pO1xuICByZXR1cm4gY29yZS5qc3goZmllbGRzLkZpZWxkQ29udGFpbmVyLCB7XG4gICAgYXM6IFwiZmllbGRzZXRcIlxuICB9LCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwge1xuICAgIGFzOiBcImxlZ2VuZFwiXG4gIH0sIGZpZWxkLmxhYmVsKSwgdmFsdWUua2luZCA9PT0gJ3JlZicgPyBjb3JlLmpzeChSZWZWaWV3LCB7XG4gICAgZmllbGQ6IGZpZWxkLFxuICAgIG9uQ2hhbmdlOiByZWYgPT4ge1xuICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHtcbiAgICAgICAga2luZDogJ3JlZicsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWZcbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IHZhbHVlLnByZXZpb3VzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVycm9yOiBmb3JjZVZhbGlkYXRpb24gJiYgZXJyb3JNZXNzYWdlID8gZXJyb3JNZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgIG9uQ2FuY2VsOiAoKSA9PiB7XG4gICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UodmFsdWUucHJldmlvdXMpO1xuICAgIH1cbiAgfSkgOiBjb3JlLmpzeChJbWdWaWV3LCB7XG4gICAgZXJyb3JNZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBmaWVsZDogZmllbGQsXG4gICAgaW5wdXRSZWY6IGlucHV0UmVmXG4gIH0pLCBjb3JlLmpzeChcImlucHV0XCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0sXG4gICAgYXV0b0NvbXBsZXRlOiBcIm9mZlwiLFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIHJlZjogaW5wdXRSZWYsXG4gICAga2V5OiBpbnB1dEtleSxcbiAgICBuYW1lOiBmaWVsZC5wYXRoLFxuICAgIG9uQ2hhbmdlOiBvblVwbG9hZENoYW5nZSxcbiAgICB0eXBlOiBcImZpbGVcIixcbiAgICBkaXNhYmxlZDogb25DaGFuZ2UgPT09IHVuZGVmaW5lZFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIEltZ1ZpZXcoe1xuICBlcnJvck1lc3NhZ2UsXG4gIHZhbHVlLFxuICBvbkNoYW5nZSxcbiAgZmllbGQsXG4gIGlucHV0UmVmXG59KSB7XG4gIGNvbnN0IHtcbiAgICBhZGRUb2FzdFxuICB9ID0gdG9hc3QudXNlVG9hc3RzKCk7XG4gIGNvbnN0IGltYWdlUGF0aEZyb21VcGxvYWQgPSB1c2VPYmplY3RVUkwoZXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQgJiYgdmFsdWUua2luZCA9PT0gJ3VwbG9hZCcgPyB2YWx1ZS5kYXRhLmZpbGUgOiB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IG9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICBhZGRUb2FzdCh7XG4gICAgICB0aXRsZTogJ0NvcGllZCBpbWFnZSByZWYgdG8gY2xpcGJvYXJkJyxcbiAgICAgIHRvbmU6ICdwb3NpdGl2ZSdcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBvbkZhaWx1cmUgPSAoKSA9PiB7XG4gICAgYWRkVG9hc3Qoe1xuICAgICAgdGl0bGU6ICdGYWlsZWQgdG8gY29weSBpbWFnZSByZWYgdG8gY2xpcGJvYXJkJyxcbiAgICAgIHRvbmU6ICduZWdhdGl2ZSdcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBjb3B5UmVmID0gKCkgPT4ge1xuICAgIGlmICh2YWx1ZS5raW5kICE9PSAnZnJvbS1zZXJ2ZXInKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgLy8gdXNlIHRoZSBuZXcgbmF2aWdhdG9yLmNsaXBib2FyZCBBUEkgaWYgaXQgZXhpc3RzXG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZGF0YS5yZWYpLnRoZW4ob25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBhIGxpYnJhcnkgdGhhdCBsZXZlcmFnZXMgZG9jdW1lbnQuZXhlY0NvbW1hbmRcbiAgICAgIC8vIGZvciBicm93c2VyIHZlcnNpb25zIHRoYXQgZG9udCcgc3VwcG9ydCB0aGUgbmF2aWdhdG9yIG9iamVjdC5cbiAgICAgIC8vIEFzIGRvY3VtZW50LmV4ZWNDb21tYW5kXG4gICAgICB0cnkge1xuICAgICAgICBjb3B5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZGF0YS5yZWYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhZGRUb2FzdCh7XG4gICAgICAgICAgdGl0bGU6ICdGYWlsZCB0byBvb3B5IHRvIGNsaXBib2FyZCcsXG4gICAgICAgICAgdG9uZTogJ25lZ2F0aXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ2Zyb20tc2VydmVyJyB8fCB2YWx1ZS5raW5kID09PSAndXBsb2FkJyA/IGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwic21hbGxcIixcbiAgICBhY3Jvc3M6IHRydWUsXG4gICAgYWxpZ246IFwiY2VudGVyXCJcbiAgfSwgZXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQgPyB2YWx1ZS5raW5kID09PSAnZnJvbS1zZXJ2ZXInID8gY29yZS5qc3goSW1hZ2VXcmFwcGVyLCBudWxsLCBjb3JlLmpzeChcImltZ1wiLCB7XG4gICAgY3NzOiB7XG4gICAgICB3aWR0aDogJzEwMCUnXG4gICAgfSxcbiAgICBzcmM6IHZhbHVlLmRhdGEuc3JjLFxuICAgIGFsdDogZmllbGQucGF0aFxuICB9KSkgOiBjb3JlLmpzeChJbWFnZVdyYXBwZXIsIG51bGwsIGNvcmUuanN4KFwiaW1nXCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgbWF4V2lkdGg6ICcxMDAlJ1xuICAgIH0sXG4gICAgc3JjOiBpbWFnZVBhdGhGcm9tVXBsb2FkLFxuICAgIGFsdDogZmllbGQucGF0aFxuICB9KSkgOiBudWxsLCBvbkNoYW5nZSAmJiBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInNtYWxsXCJcbiAgfSwgdmFsdWUua2luZCA9PT0gJ2Zyb20tc2VydmVyJyAmJiBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgcGFkZGluZzogXCJ4eHNtYWxsXCIsXG4gICAgZ2FwOiBcInh4c21hbGxcIlxuICB9LCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgYWNyb3NzOiB0cnVlLFxuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGdhcDogXCJzbWFsbFwiXG4gIH0sIGNvcmUuanN4KGNvcmUuVGV4dCwge1xuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCBjb3JlLmpzeChcImFcIiwge1xuICAgIGhyZWY6IHZhbHVlLmRhdGEuc3JjLFxuICAgIHRhcmdldDogXCJfYmxhbmtcIlxuICB9LCBgJHt2YWx1ZS5kYXRhLmlkfS4ke3ZhbHVlLmRhdGEuZXh0ZW5zaW9ufWApKSwgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICB0b25lOiBcInBhc3NpdmVcIixcbiAgICBvbkNsaWNrOiBjb3B5UmVmXG4gIH0sIFwiQ29weSBSZWZcIikpLCBjb3JlLmpzeChjb3JlLlRleHQsIHtcbiAgICBzaXplOiBcInhzbWFsbFwiXG4gIH0sIGAke3ZhbHVlLmRhdGEud2lkdGh9IHggJHt2YWx1ZS5kYXRhLmhlaWdodH0gKCR7Ynl0ZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHZhbHVlLmRhdGEuZmlsZXNpemUpfSlgKSksIGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBhY3Jvc3M6IHRydWUsXG4gICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgYWxpZ246IFwiY2VudGVyXCJcbiAgfSwgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICB2YXIgX2lucHV0UmVmJGN1cnJlbnQ7XG5cbiAgICAgIChfaW5wdXRSZWYkY3VycmVudCA9IGlucHV0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9pbnB1dFJlZiRjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5wdXRSZWYkY3VycmVudC5jbGljaygpO1xuICAgIH1cbiAgfSwgXCJDaGFuZ2VcIiksIHZhbHVlLmtpbmQgIT09ICd1cGxvYWQnID8gY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICB0b25lOiBcInBhc3NpdmVcIixcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBvbkNoYW5nZSh7XG4gICAgICAgIGtpbmQ6ICdyZWYnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVmOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgXCJQYXN0ZSBSZWZcIikgOiBudWxsLCB2YWx1ZS5raW5kID09PSAnZnJvbS1zZXJ2ZXInICYmIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgdG9uZTogXCJuZWdhdGl2ZVwiLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAga2luZDogJ3JlbW92ZScsXG4gICAgICAgIHByZXZpb3VzOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBcIlJlbW92ZVwiKSwgdmFsdWUua2luZCA9PT0gJ3VwbG9hZCcgJiYgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICB0b25lOiBcIm5lZ2F0aXZlXCIsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25DaGFuZ2UodmFsdWUucHJldmlvdXMpO1xuICAgIH1cbiAgfSwgXCJDYW5jZWxcIiksIGVycm9yTWVzc2FnZSA/IGNvcmUuanN4KHBpbGwuUGlsbCwge1xuICAgIHRvbmU6IFwibmVnYXRpdmVcIixcbiAgICB3ZWlnaHQ6IFwibGlnaHRcIlxuICB9LCBlcnJvck1lc3NhZ2UpIDogdmFsdWUua2luZCA9PT0gJ3VwbG9hZCcgJiYgY29yZS5qc3gocGlsbC5QaWxsLCB7XG4gICAgd2VpZ2h0OiBcImxpZ2h0XCIsXG4gICAgdG9uZTogXCJwb3NpdGl2ZVwiXG4gIH0sIFwiU2F2ZSB0byB1cGxvYWQgdGhpcyBpbWFnZVwiKSkpKSA6IGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwic21hbGxcIlxuICB9LCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgY3NzOiB7XG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICAgIH0sXG4gICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgYWNyb3NzOiB0cnVlXG4gIH0sIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6IG9uQ2hhbmdlID09PSB1bmRlZmluZWQsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgdmFyIF9pbnB1dFJlZiRjdXJyZW50MjtcblxuICAgICAgKF9pbnB1dFJlZiRjdXJyZW50MiA9IGlucHV0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9pbnB1dFJlZiRjdXJyZW50MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2lucHV0UmVmJGN1cnJlbnQyLmNsaWNrKCk7XG4gICAgfSxcbiAgICB0b25lOiBcInBvc2l0aXZlXCJcbiAgfSwgXCJVcGxvYWQgSW1hZ2VcIiksIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgdG9uZTogXCJwYXNzaXZlXCIsXG4gICAgZGlzYWJsZWQ6IG9uQ2hhbmdlID09PSB1bmRlZmluZWQsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHtcbiAgICAgICAga2luZDogJ3JlZicsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWY6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZpb3VzOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBcIlBhc3RlIFJlZlwiKSwgdmFsdWUua2luZCA9PT0gJ3JlbW92ZScgJiYgdmFsdWUucHJldmlvdXMgJiYgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICB0b25lOiBcIm5lZ2F0aXZlXCIsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgaWYgKHZhbHVlLnByZXZpb3VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5wcmV2aW91cyk7XG4gICAgICB9XG4gICAgfVxuICB9LCBcIlVuZG8gcmVtb3ZhbFwiKSwgdmFsdWUua2luZCA9PT0gJ3JlbW92ZScgJiYgLy8gTk9URSAtLSBVWCBkZWNpc2lvbiBpcyB0byBub3QgZGlzcGxheSB0aGlzLCBJIHRoaW5rIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgLy8gZm9yIGRlbGV0aW5nIHVwbG9hZGVkIGltYWdlcyAoYW5kIHdlIGRvbid0IHN1cHBvcnQgdGhhdCB5ZXQpXG4gIC8vIDxQaWxsIHdlaWdodD1cImxpZ2h0XCIgdG9uZT1cIndhcm5pbmdcIj5cbiAgLy8gICBTYXZlIHRvIHJlbW92ZSB0aGlzIGltYWdlXG4gIC8vIDwvUGlsbD5cbiAgbnVsbCkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZih7XG4gIHJlZlxufSkge1xuICBpZiAoIWZpZWxkc190eXBlc19pbWFnZV91dGlsc19kaXN0X2tleXN0b25lTmV4dEtleXN0b25lRmllbGRzVHlwZXNJbWFnZVV0aWxzLnBhcnNlSW1hZ2VSZWYocmVmKSkge1xuICAgIHJldHVybiAnSW52YWxpZCByZWYnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWVzc2FnZSh2YWx1ZSwgZm9yY2VWYWxpZGF0aW9uKSB7XG4gIGlmICh2YWx1ZS5raW5kID09PSAndXBsb2FkJykge1xuICAgIHJldHVybiB2YWxpZGF0ZUltYWdlKHZhbHVlLmRhdGEpO1xuICB9IGVsc2UgaWYgKHZhbHVlLmtpbmQgPT09ICdyZWYnKSB7XG4gICAgcmV0dXJuIGZvcmNlVmFsaWRhdGlvbiA/IHZhbGlkYXRlUmVmKHZhbHVlLmRhdGEpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2Uoe1xuICBmaWxlLFxuICB2YWxpZGl0eVxufSkge1xuICBpZiAoIXZhbGlkaXR5LnZhbGlkKSB7XG4gICAgcmV0dXJuICdTb21ldGhpbmcgd2VudCB3cm9uZywgcGxlYXNlIHJlbG9hZCBhbmQgdHJ5IGFnYWluLic7XG4gIH0gLy8gY2hlY2sgaWYgdGhlIGZpbGUgaXMgYWN0dWFsbHkgYW4gaW1hZ2VcblxuXG4gIGlmICghZmlsZS50eXBlLmluY2x1ZGVzKCdpbWFnZScpKSB7XG4gICAgcmV0dXJuICdPbmx5IGltYWdlIGZpbGVzIGFyZSBhbGxvd2VkLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gIH1cbn0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTdHlsZWQgQ29tcG9uZW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IEltYWdlV3JhcHBlciA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gY29yZS51c2VUaGVtZSgpO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5yYWRpaS5tZWRpdW0sXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyfWAsXG4gICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIHBhZGRpbmc6IDQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICB3aWR0aDogJzEzMHB4JyAvLyAxMjBweCBpbWFnZSArIGNocm9tZVxuXG4gICAgfVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vKiogQGpzeFJ1bnRpbWUgY2xhc3NpYyAqL1xuY29uc3QgQ2VsbCA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIGNvbnN0IGRhdGEgPSBpdGVtW2ZpZWxkLnBhdGhdO1xuICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwge1xuICAgIGNzczoge1xuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBoZWlnaHQ6IDI0LFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIHdpZHRoOiAyNFxuICAgIH1cbiAgfSwgY29yZS5qc3goXCJpbWdcIiwge1xuICAgIGFsdDogZGF0YS5maWxlbmFtZSxcbiAgICBjc3M6IHtcbiAgICAgIG1heEhlaWdodDogJzEwMCUnLFxuICAgICAgbWF4V2lkdGg6ICcxMDAlJ1xuICAgIH0sXG4gICAgc3JjOiBkYXRhLnNyY1xuICB9KSk7XG59O1xuY29uc3QgQ2FyZFZhbHVlID0gKHtcbiAgaXRlbSxcbiAgZmllbGRcbn0pID0+IHtcbiAgY29uc3QgZGF0YSA9IGl0ZW1bZmllbGQucGF0aF07XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGRhdGEgJiYgY29yZS5qc3goSW1hZ2VXcmFwcGVyLCBudWxsLCBjb3JlLmpzeChcImltZ1wiLCB7XG4gICAgY3NzOiB7XG4gICAgICB3aWR0aDogJzEwMCUnXG4gICAgfSxcbiAgICBhbHQ6IGRhdGEuZmlsZW5hbWUsXG4gICAgc3JjOiBkYXRhLnNyY1xuICB9KSkpO1xufTtcbmNvbnN0IGNvbnRyb2xsZXIgPSBjb25maWcgPT4ge1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgIGxhYmVsOiBjb25maWcubGFiZWwsXG4gICAgZ3JhcGhxbFNlbGVjdGlvbjogYCR7Y29uZmlnLnBhdGh9IHtcbiAgICAgICAgc3JjXG4gICAgICAgIGlkXG4gICAgICAgIHJlZlxuICAgICAgICBleHRlbnNpb25cbiAgICAgICAgd2lkdGhcbiAgICAgICAgaGVpZ2h0XG4gICAgICAgIGZpbGVzaXplXG4gICAgICB9YCxcbiAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgIGtpbmQ6ICdlbXB0eSdcbiAgICB9LFxuXG4gICAgZGVzZXJpYWxpemUoaXRlbSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2NvbmZpZy5wYXRoXTtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICdlbXB0eSdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnZnJvbS1zZXJ2ZXInLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3JjOiB2YWx1ZS5zcmMsXG4gICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgIGV4dGVuc2lvbjogdmFsdWUuZXh0ZW5zaW9uLFxuICAgICAgICAgIHJlZjogdmFsdWUucmVmLFxuICAgICAgICAgIHdpZHRoOiB2YWx1ZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZhbHVlLmhlaWdodCxcbiAgICAgICAgICBmaWxlc2l6ZTogdmFsdWUuZmlsZXNpemVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5raW5kID09PSAncmVmJykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVSZWYodmFsdWUuZGF0YSkgPT09IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLmtpbmQgIT09ICd1cGxvYWQnIHx8IHZhbGlkYXRlSW1hZ2UodmFsdWUuZGF0YSkgPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUua2luZCA9PT0gJ3VwbG9hZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbY29uZmlnLnBhdGhdOiB7XG4gICAgICAgICAgICB1cGxvYWQ6IHZhbHVlLmRhdGEuZmlsZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmtpbmQgPT09ICdyZWYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgcmVmOiB2YWx1ZS5kYXRhLnJlZlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmtpbmQgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5leHBvcnRzLkNhcmRWYWx1ZSA9IENhcmRWYWx1ZTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtaW1hZ2Utdmlld3MuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWltYWdlLXZpZXdzLmNqcy5kZXYuanNcIik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2NvcmUnKTtcbnZhciBmaWVsZHMgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvZmllbGRzJyk7XG52YXIgQ2VsbENvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvQ2VsbENvbnRhaW5lci00NTMyNTRiNS5janMuZGV2LmpzJyk7XG52YXIgQ2VsbExpbmsgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L0NlbGxMaW5rLWRjNDFjODc3LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvYnV0dG9uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxlcnRUcmlhbmdsZUljb24nKTtcbnJlcXVpcmUoJ25leHQvbGluaycpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3RvYXN0Jyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbG9hZGluZycpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL21vZGFscycpO1xucmVxdWlyZSgnYXBvbGxvLXVwbG9hZC1jbGllbnQnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMicpO1xucmVxdWlyZSgnQGVtb3Rpb24vaGFzaCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9zcWxpdGUtYWY5ZTUxNDguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9ncmFwaHFsLXRzLXNjaGVtYS1mY2U3YTZhOC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYXBvbGxvL2NsaWVudCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9hZG1pbi1tZXRhLWdyYXBocWwtOWY5YTljMTEuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG5yZXF1aXJlKCduZXh0L3JvdXRlcicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3BvcG92ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Nb3JlSG9yaXpvbnRhbEljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uUmlnaHRJY29uJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L1NpZ25vdXRCdXR0b24tYWNkYjE1NTQuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbm90aWNlJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9hZG1pbi11aS9yb3V0ZXIvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWFkbWluLXVpLXJvdXRlci5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10b29scy9zY2hlbWEnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0Jyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEnKTtcbnJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG5yZXF1aXJlKCdncmFwaHFsLXVwbG9hZC9wdWJsaWMvR3JhcGhRTFVwbG9hZC5qcycpO1xucmVxdWlyZSgnZ3JhcGhxbCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcblxuLyoqIEBqc3hSdW50aW1lIGNsYXNzaWMgKi9cbmNvbnN0IEZpZWxkID0gKHtcbiAgZmllbGQsXG4gIGZvcmNlVmFsaWRhdGlvbixcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBhdXRvRm9jdXNcbn0pID0+IHtcbiAgcmV0dXJuIGNvcmUuanN4KGZpZWxkcy5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzLkZpZWxkTGFiZWwsIG51bGwsIGZpZWxkLmxhYmVsLCBvbkNoYW5nZSA/IGNvcmUuanN4KGNvcmUuU3RhY2ssIG51bGwsIGNvcmUuanN4KGZpZWxkcy5UZXh0QXJlYSwge1xuICAgIGNzczoge1xuICAgICAgZm9udEZhbWlseTogJ21vbm9zcGFjZSdcbiAgICB9LFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiBvbkNoYW5nZShldmVudC50YXJnZXQudmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KSwgZm9yY2VWYWxpZGF0aW9uICYmIGNvcmUuanN4KGNvcmUuVGV4dCwge1xuICAgIGNvbG9yOiBcInJlZDYwMFwiLFxuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCAnSW52YWxpZCBKU09OJykpIDogdmFsdWUpKTtcbn07XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGQsXG4gIGxpbmtUb1xufSkgPT4ge1xuICBsZXQgdmFsdWUgPSBpdGVtW2ZpZWxkLnBhdGhdICsgJyc7XG4gIHJldHVybiBsaW5rVG8gPyBjb3JlLmpzeChDZWxsTGluay5DZWxsTGluaywgbGlua1RvLCB2YWx1ZSkgOiBjb3JlLmpzeChDZWxsQ29udGFpbmVyLkNlbGxDb250YWluZXIsIG51bGwsIHZhbHVlKTtcbn07XG5DZWxsLnN1cHBvcnRzTGlua1RvID0gdHJ1ZTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGl0ZW1bZmllbGQucGF0aF0pO1xufTtcbmNvbnN0IGNvbnRyb2xsZXIgPSBjb25maWcgPT4ge1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgIGxhYmVsOiBjb25maWcubGFiZWwsXG4gICAgZ3JhcGhxbFNlbGVjdGlvbjogY29uZmlnLnBhdGgsXG4gICAgZGVmYXVsdFZhbHVlOiBjb25maWcuZmllbGRNZXRhLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCA/ICcnIDogSlNPTi5zdHJpbmdpZnkoY29uZmlnLmZpZWxkTWV0YS5kZWZhdWx0VmFsdWUsIG51bGwsIDIpLFxuICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiB7XG4gICAgICBpZiAoIXZhbHVlKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZTogZGF0YSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbY29uZmlnLnBhdGhdO1xuICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgbGV0IHBhcnNlZFZhbHVlO1xuXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRWYWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXTogcGFyc2VkVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5DYXJkVmFsdWUgPSBDYXJkVmFsdWU7XG5leHBvcnRzLkNlbGwgPSBDZWxsO1xuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWpzb24tdmlld3MuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLWpzb24tdmlld3MuY2pzLmRldi5qc1wiKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9vYmplY3RTcHJlYWQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgYnV0dG9uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2J1dHRvbicpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvY29yZScpO1xudmFyIGZpZWxkcyA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9maWVsZHMnKTtcbnZhciBFeWVJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0V5ZUljb24nKTtcbnZhciBFeWVPZmZJY29uID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0V5ZU9mZkljb24nKTtcbnZhciBYSWNvbiA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9YSWNvbicpO1xudmFyIHNlZ21lbnRlZENvbnRyb2wgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvc2VnbWVudGVkLWNvbnRyb2wnKTtcbnZhciBkdW1iUGFzc3dvcmRzID0gcmVxdWlyZSgnZHVtYi1wYXNzd29yZHMnKTtcbnZhciBDZWxsQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9DZWxsQ29udGFpbmVyLTQ1MzI1NGI1LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xucmVxdWlyZSgnbmV4dC9yb3V0ZXInKTtcbnJlcXVpcmUoJ25leHQvbGluaycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsZXJ0VHJpYW5nbGVJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvdG9hc3QnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9sb2FkaW5nJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbW9kYWxzJyk7XG5yZXF1aXJlKCdhcG9sbG8tdXBsb2FkLWNsaWVudCcpO1xucmVxdWlyZSgnQGVtb3Rpb24vaGFzaCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9zcWxpdGUtYWY5ZTUxNDguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9ncmFwaHFsLXRzLXNjaGVtYS1mY2U3YTZhOC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYXBvbGxvL2NsaWVudCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9hZG1pbi1tZXRhLWdyYXBocWwtOWY5YTljMTEuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3BvcG92ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Nb3JlSG9yaXpvbnRhbEljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uUmlnaHRJY29uJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L1NpZ25vdXRCdXR0b24tYWNkYjE1NTQuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbm90aWNlJyk7XG5yZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10b29scy9zY2hlbWEnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0Jyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEnKTtcbnJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG5yZXF1aXJlKCdncmFwaHFsLXVwbG9hZC9wdWJsaWMvR3JhcGhRTFVwbG9hZC5qcycpO1xucmVxdWlyZSgnZ3JhcGhxbCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBkdW1iUGFzc3dvcmRzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChkdW1iUGFzc3dvcmRzKTtcblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHZhbGlkYXRpb24sIGZpZWxkTGFiZWwpIHtcbiAgaWYgKHZhbHVlLmtpbmQgPT09ICdpbml0aWFsJyAmJiAodmFsdWUuaXNTZXQgPT09IG51bGwgfHwgdmFsdWUuaXNTZXQgPT09IHRydWUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh2YWx1ZS5raW5kID09PSAnaW5pdGlhbCcgJiYgdmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5pc1JlcXVpcmVkKSB7XG4gICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuXG4gIGlmICh2YWx1ZS5raW5kID09PSAnZWRpdGluZycgJiYgdmFsdWUuY29uZmlybSAhPT0gdmFsdWUudmFsdWUpIHtcbiAgICByZXR1cm4gYFRoZSBwYXNzd29yZHMgZG8gbm90IG1hdGNoYDtcbiAgfVxuXG4gIGlmICh2YWx1ZS5raW5kID09PSAnZWRpdGluZycpIHtcbiAgICBjb25zdCB2YWwgPSB2YWx1ZS52YWx1ZTtcblxuICAgIGlmICh2YWwubGVuZ3RoIDwgdmFsaWRhdGlvbi5sZW5ndGgubWluKSB7XG4gICAgICBpZiAodmFsaWRhdGlvbi5sZW5ndGgubWluID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBiZSBlbXB0eWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7dmFsaWRhdGlvbi5sZW5ndGgubWlufSBjaGFyYWN0ZXJzIGxvbmdgO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0aW9uLmxlbmd0aC5tYXggIT09IG51bGwgJiYgdmFsLmxlbmd0aCA+IHZhbGlkYXRpb24ubGVuZ3RoLm1heCkge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3QgYmUgbm8gbG9uZ2VyIHRoYW4gJHt2YWxpZGF0aW9uLmxlbmd0aC5taW59IGNoYXJhY3RlcnNgO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0aW9uLm1hdGNoICYmICF2YWxpZGF0aW9uLm1hdGNoLnJlZ2V4LnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbGlkYXRpb24ubWF0Y2guZXhwbGFuYXRpb247XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRpb24ucmVqZWN0Q29tbW9uICYmIGR1bWJQYXNzd29yZHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNoZWNrKHZhbCkpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBpcyB0b28gY29tbW9uIGFuZCBpcyBub3QgYWxsb3dlZGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNTZXRUZXh0KGlzU2V0KSB7XG4gIHJldHVybiBpc1NldCA9PSBudWxsID8gJ0FjY2VzcyBEZW5pZWQnIDogaXNTZXQgPyAnSXMgc2V0JyA6ICdJcyBub3Qgc2V0Jztcbn1cblxuY29uc3QgRmllbGQgPSAoe1xuICBmaWVsZCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBmb3JjZVZhbGlkYXRpb24sXG4gIGF1dG9Gb2N1c1xufSkgPT4ge1xuICBjb25zdCBbc2hvd0lucHV0VmFsdWUsIHNldFNob3dJbnB1dFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3RvdWNoZWRGaXJzdElucHV0LCBzZXRUb3VjaGVkRmlyc3RJbnB1dF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt0b3VjaGVkU2Vjb25kSW5wdXQsIHNldFRvdWNoZWRTZWNvbmRJbnB1dF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHNob3VsZFNob3dWYWxpZGF0aW9uID0gZm9yY2VWYWxpZGF0aW9uIHx8IHRvdWNoZWRGaXJzdElucHV0ICYmIHRvdWNoZWRTZWNvbmRJbnB1dDtcbiAgY29uc3QgdmFsaWRhdGlvbk1lc3NhZ2UgPSBzaG91bGRTaG93VmFsaWRhdGlvbiA/IHZhbGlkYXRlKHZhbHVlLCBmaWVsZC52YWxpZGF0aW9uLCBmaWVsZC5sYWJlbCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0aW9uTWVzc2FnZSAmJiBjb3JlLmpzeChjb3JlLlRleHQsIHtcbiAgICBjb2xvcjogXCJyZWQ2MDBcIixcbiAgICBzaXplOiBcInNtYWxsXCJcbiAgfSwgdmFsaWRhdGlvbk1lc3NhZ2UpO1xuICBjb25zdCBpbnB1dFR5cGUgPSBzaG93SW5wdXRWYWx1ZSA/ICd0ZXh0JyA6ICdwYXNzd29yZCc7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIHtcbiAgICBhczogXCJmaWVsZHNldFwiXG4gIH0sIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCB7XG4gICAgYXM6IFwibGVnZW5kXCJcbiAgfSwgZmllbGQubGFiZWwpLCBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkID8gaXNTZXRUZXh0KHZhbHVlLmlzU2V0KSA6IHZhbHVlLmtpbmQgPT09ICdpbml0aWFsJyA/IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICBraW5kOiAnZWRpdGluZycsXG4gICAgICAgIGNvbmZpcm06ICcnLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIGlzU2V0OiB2YWx1ZS5pc1NldFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB2YWx1ZS5pc1NldCA/ICdDaGFuZ2UgUGFzc3dvcmQnIDogJ1NldCBQYXNzd29yZCcpLCB2YWxpZGF0aW9uKSA6IGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwic21hbGxcIlxuICB9LCBjb3JlLmpzeChcImRpdlwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICB9XG4gIH0sIGNvcmUuanN4KGNvcmUuVmlzdWFsbHlIaWRkZW4sIHtcbiAgICBhczogXCJsYWJlbFwiLFxuICAgIGh0bWxGb3I6IGAke2ZpZWxkLnBhdGh9LW5ldy1wYXNzd29yZGBcbiAgfSwgXCJOZXcgUGFzc3dvcmRcIiksIGNvcmUuanN4KGZpZWxkcy5UZXh0SW5wdXQsIHtcbiAgICBpZDogYCR7ZmllbGQucGF0aH0tbmV3LXBhc3N3b3JkYCxcbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgaW52YWxpZDogdmFsaWRhdGlvbk1lc3NhZ2UgIT09IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBpbnB1dFR5cGUsXG4gICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgIHBsYWNlaG9sZGVyOiBcIk5ldyBQYXNzd29yZFwiLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiB7XG4gICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgb25CbHVyOiAoKSA9PiB7XG4gICAgICBzZXRUb3VjaGVkRmlyc3RJbnB1dCh0cnVlKTtcbiAgICB9XG4gIH0pLCBjb3JlLmpzeChTcGFjZXIsIG51bGwpLCBjb3JlLmpzeChjb3JlLlZpc3VhbGx5SGlkZGVuLCB7XG4gICAgYXM6IFwibGFiZWxcIixcbiAgICBodG1sRm9yOiBgJHtmaWVsZC5wYXRofS1jb25maXJtLXBhc3N3b3JkYFxuICB9LCBcIkNvbmZpcm0gUGFzc3dvcmRcIiksIGNvcmUuanN4KGZpZWxkcy5UZXh0SW5wdXQsIHtcbiAgICBpZDogYCR7ZmllbGQucGF0aH0tY29uZmlybS1wYXNzd29yZGAsXG4gICAgaW52YWxpZDogdmFsaWRhdGlvbk1lc3NhZ2UgIT09IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBpbnB1dFR5cGUsXG4gICAgdmFsdWU6IHZhbHVlLmNvbmZpcm0sXG4gICAgcGxhY2Vob2xkZXI6IFwiQ29uZmlybSBQYXNzd29yZFwiLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiB7XG4gICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgY29uZmlybTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBvbkJsdXI6ICgpID0+IHtcbiAgICAgIHNldFRvdWNoZWRTZWNvbmRJbnB1dCh0cnVlKTtcbiAgICB9XG4gIH0pLCBjb3JlLmpzeChTcGFjZXIsIG51bGwpLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgc2V0U2hvd0lucHV0VmFsdWUoIXNob3dJbnB1dFZhbHVlKTtcbiAgICB9XG4gIH0sIGNvcmUuanN4KGNvcmUuVmlzdWFsbHlIaWRkZW4sIG51bGwsIHNob3dJbnB1dFZhbHVlID8gJ0hpZGUgVGV4dCcgOiAnU2hvdyBUZXh0JyksIHNob3dJbnB1dFZhbHVlID8gY29yZS5qc3goRXllT2ZmSWNvbi5FeWVPZmZJY29uLCBudWxsKSA6IGNvcmUuanN4KEV5ZUljb24uRXllSWNvbiwgbnVsbCkpLCBjb3JlLmpzeChTcGFjZXIsIG51bGwpLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICBraW5kOiAnaW5pdGlhbCcsXG4gICAgICAgIGlzU2V0OiB2YWx1ZS5pc1NldFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBjb3JlLmpzeChjb3JlLlZpc3VhbGx5SGlkZGVuLCBudWxsLCBcIkNhbmNlbFwiKSwgY29yZS5qc3goWEljb24uWEljb24sIG51bGwpKSksIHZhbGlkYXRpb24pKTtcbn07XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGRcbn0pID0+IHtcbiAgdmFyIF9pdGVtJGZpZWxkJHBhdGg7XG5cbiAgcmV0dXJuIGNvcmUuanN4KENlbGxDb250YWluZXIuQ2VsbENvbnRhaW5lciwgbnVsbCwgaXNTZXRUZXh0KChfaXRlbSRmaWVsZCRwYXRoID0gaXRlbVtmaWVsZC5wYXRoXSkgPT09IG51bGwgfHwgX2l0ZW0kZmllbGQkcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW0kZmllbGQkcGF0aC5pc1NldCkpO1xufTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHZhciBfaXRlbSRmaWVsZCRwYXRoMjtcblxuICByZXR1cm4gY29yZS5qc3goZmllbGRzLkZpZWxkQ29udGFpbmVyLCBudWxsLCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwgbnVsbCwgZmllbGQubGFiZWwpLCBpc1NldFRleHQoKF9pdGVtJGZpZWxkJHBhdGgyID0gaXRlbVtmaWVsZC5wYXRoXSkgPT09IG51bGwgfHwgX2l0ZW0kZmllbGQkcGF0aDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtJGZpZWxkJHBhdGgyLmlzU2V0KSk7XG59O1xuY29uc3QgY29udHJvbGxlciA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IHZhbGlkYXRpb24gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbiksIHt9LCB7XG4gICAgbWF0Y2g6IGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5tYXRjaCA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICByZWdleDogbmV3IFJlZ0V4cChjb25maWcuZmllbGRNZXRhLnZhbGlkYXRpb24ubWF0Y2gucmVnZXguc291cmNlLCBjb25maWcuZmllbGRNZXRhLnZhbGlkYXRpb24ubWF0Y2gucmVnZXguZmxhZ3MpLFxuICAgICAgZXhwbGFuYXRpb246IGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5tYXRjaC5leHBsYW5hdGlvblxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBjb25maWcucGF0aCxcbiAgICBsYWJlbDogY29uZmlnLmxhYmVsLFxuICAgIGdyYXBocWxTZWxlY3Rpb246IGAke2NvbmZpZy5wYXRofSB7aXNTZXR9YCxcbiAgICB2YWxpZGF0aW9uLFxuICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAga2luZDogJ2luaXRpYWwnLFxuICAgICAgaXNTZXQ6IGZhbHNlXG4gICAgfSxcbiAgICB2YWxpZGF0ZTogc3RhdGUgPT4gdmFsaWRhdGUoc3RhdGUsIHZhbGlkYXRpb24sIGNvbmZpZy5sYWJlbCkgPT09IHVuZGVmaW5lZCxcbiAgICBkZXNlcmlhbGl6ZTogZGF0YSA9PiB7XG4gICAgICB2YXIgX2RhdGEkY29uZmlnJHBhdGgkaXNTLCBfZGF0YSRjb25maWckcGF0aDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2luaXRpYWwnLFxuICAgICAgICBpc1NldDogKF9kYXRhJGNvbmZpZyRwYXRoJGlzUyA9IChfZGF0YSRjb25maWckcGF0aCA9IGRhdGFbY29uZmlnLnBhdGhdKSA9PT0gbnVsbCB8fCBfZGF0YSRjb25maWckcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkY29uZmlnJHBhdGguaXNTZXQpICE9PSBudWxsICYmIF9kYXRhJGNvbmZpZyRwYXRoJGlzUyAhPT0gdm9pZCAwID8gX2RhdGEkY29uZmlnJHBhdGgkaXNTIDogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgaWYgKHZhbHVlLmtpbmQgPT09ICdpbml0aWFsJykgcmV0dXJuIHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXTogdmFsdWUudmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBmaWx0ZXI6IGNvbmZpZy5maWVsZE1ldGEuaXNOdWxsYWJsZSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiB7XG4gICAgICBGaWx0ZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUuanN4KHNlZ21lbnRlZENvbnRyb2wuU2VnbWVudGVkQ29udHJvbCwge1xuICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IE51bWJlcihwcm9wcy52YWx1ZSksXG4gICAgICAgICAgb25DaGFuZ2U6IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKCEhdmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VnbWVudHM6IFsnSXMgTm90IFNldCcsICdJcyBTZXQnXVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGdyYXBocWw6ICh7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgaXNTZXQ6IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgTGFiZWwoe1xuICAgICAgICB2YWx1ZVxuICAgICAgfSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyAnaXMgc2V0JyA6ICdpcyBub3Qgc2V0JztcbiAgICAgIH0sXG5cbiAgICAgIHR5cGVzOiB7XG4gICAgICAgIGlzX3NldDoge1xuICAgICAgICAgIGxhYmVsOiAnSXMgU2V0JyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IFNwYWNlciA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIHNwYWNpbmdcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgcmV0dXJuIGNvcmUuanN4KFwiZGl2XCIsIHtcbiAgICBjc3M6IHtcbiAgICAgIHdpZHRoOiBzcGFjaW5nLnNtYWxsLFxuICAgICAgZmxleFNocmluazogMFxuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnRzLkNhcmRWYWx1ZSA9IENhcmRWYWx1ZTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtcGFzc3dvcmQtdmlld3MuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXBhc3N3b3JkLXZpZXdzLmNqcy5kZXYuanNcIik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfb2JqZWN0U3ByZWFkID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJyk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xudmFyIF90b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5Jyk7XG5yZXF1aXJlKCdpbnRlcnNlY3Rpb24tb2JzZXJ2ZXInKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG52YXIgY2xpZW50ID0gcmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wiY2hpbGRyZW5cIl07XG5cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbk9ic2VydmVyKGNiLCByZWYpIHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2IsIHt9KTtcbiAgICBsZXQgbm9kZSA9IHJlZi5jdXJyZW50O1xuXG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIudW5vYnNlcnZlKG5vZGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGlkVmFsaWRhdG9ycyA9IHtcbiAgdXVpZDogdXVpZC52YWxpZGF0ZSxcblxuICBjdWlkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN0YXJ0c1dpdGgoJ2MnKTtcbiAgfSxcblxuICBhdXRvaW5jcmVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIC9eXFxkKyQvLnRlc3QodmFsdWUpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIHVzZUZpbHRlcihzZWFyY2gsIGxpc3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBjb25kaXRpb25zID0gW107XG5cbiAgICBpZiAoc2VhcmNoLmxlbmd0aCkge1xuICAgICAgY29uc3QgaWRGaWVsZEtpbmQgPSBsaXN0LmZpZWxkcy5pZC5jb250cm9sbGVyLmlkRmllbGRLaW5kO1xuICAgICAgY29uc3QgdHJpbW1lZFNlYXJjaCA9IHNlYXJjaC50cmltKCk7XG4gICAgICBjb25zdCBpc1ZhbGlkSWQgPSBpZFZhbGlkYXRvcnNbaWRGaWVsZEtpbmRdKHRyaW1tZWRTZWFyY2gpO1xuXG4gICAgICBpZiAoaXNWYWxpZElkKSB7XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IHRyaW1tZWRTZWFyY2hcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyhsaXN0LmZpZWxkcykpIHtcbiAgICAgICAgaWYgKGZpZWxkLnNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBbYCR7ZmllbGQucGF0aH1fY29udGFpbnMke2ZpZWxkLnNlYXJjaCA9PT0gJ2luc2Vuc2l0aXZlJyA/ICdfaScgOiAnJ31gXTogdHJpbW1lZFNlYXJjaFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIE9SOiBjb25kaXRpb25zXG4gICAgfTtcbiAgfSwgW3NlYXJjaCwgbGlzdF0pO1xufVxuXG5jb25zdCBpbml0aWFsSXRlbXNUb0xvYWQgPSAxMDtcbmNvbnN0IHN1YnNlcXVlbnRJdGVtc1RvTG9hZCA9IDUwO1xuY29uc3QgaWRGaWVsZCA9ICdfX19faWRfX19fJztcbmNvbnN0IGxhYmVsRmllbGQgPSAnX19fX2xhYmVsX19fXyc7XG5jb25zdCBMb2FkaW5nSW5kaWNhdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgY291bnQ6IDAsXG4gIHJlZjogKCkgPT4ge31cbn0pO1xuY29uc3QgUmVsYXRpb25zaGlwU2VsZWN0ID0gKHtcbiAgYXV0b0ZvY3VzLFxuICBjb250cm9sU2hvdWxkUmVuZGVyVmFsdWUsXG4gIGlzRGlzYWJsZWQsXG4gIGlzTG9hZGluZyxcbiAgbGlzdCxcbiAgcGxhY2Vob2xkZXIsXG4gIHBvcnRhbE1lbnUsXG4gIHN0YXRlLFxuICBleHRyYVNlbGVjdGlvbiA9ICcnXG59KSA9PiB7XG4gIHZhciBfZGF0YSRpdGVtcztcblxuICBjb25zdCBbc2VhcmNoLCBzZXRTZWFyY2hdID0gUmVhY3QudXNlU3RhdGUoJycpOyAvLyBub3RlIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBpcyBpbiBzdGF0ZSByYXRoZXIgdGhhbiBhIHJlZlxuICAvLyBiZWNhdXNlIHdlIHdhbnQgYSByZS1yZW5kZXIgaWYgdGhlIGVsZW1lbnQgY2hhbmdlc1xuICAvLyBzbyB0aGF0IHdlIGNhbiByZWdpc3RlciB0aGUgaW50ZXJzZWN0aW9uIG9ic2VydmVyXG4gIC8vIG9uIHRoZSByaWdodCBlbGVtZW50XG5cbiAgY29uc3QgW2xvYWRpbmdJbmRpY2F0b3JFbGVtZW50LCBzZXRMb2FkaW5nSW5kaWNhdG9yRWxlbWVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgUVVFUlkgPSBjbGllbnQuZ3FsYFxuICAgIHF1ZXJ5IFJlbGF0aW9uc2hpcFNlbGVjdCgkd2hlcmU6ICR7bGlzdC5ncWxOYW1lcy53aGVyZUlucHV0TmFtZX0hLCAkdGFrZTogSW50ISwgJHNraXA6IEludCEpIHtcbiAgICAgIGl0ZW1zOiAke2xpc3QuZ3FsTmFtZXMubGlzdFF1ZXJ5TmFtZX0od2hlcmU6ICR3aGVyZSwgdGFrZTogJHRha2UsIHNraXA6ICRza2lwKSB7XG4gICAgICAgICR7aWRGaWVsZH06IGlkXG4gICAgICAgICR7bGFiZWxGaWVsZH06ICR7bGlzdC5sYWJlbEZpZWxkfVxuICAgICAgICAke2V4dHJhU2VsZWN0aW9ufVxuICAgICAgfVxuICAgICAgY291bnQ6ICR7bGlzdC5ncWxOYW1lcy5saXN0UXVlcnlDb3VudE5hbWV9KHdoZXJlOiAkd2hlcmUpXG4gICAgfVxuICBgO1xuICBjb25zdCB3aGVyZSA9IHVzZUZpbHRlcihzZWFyY2gsIGxpc3QpO1xuICBjb25zdCB7XG4gICAgZGF0YSxcbiAgICBlcnJvcixcbiAgICBsb2FkaW5nLFxuICAgIGZldGNoTW9yZVxuICB9ID0gY2xpZW50LnVzZVF1ZXJ5KFFVRVJZLCB7XG4gICAgZmV0Y2hQb2xpY3k6ICduZXR3b3JrLW9ubHknLFxuICAgIHZhcmlhYmxlczoge1xuICAgICAgd2hlcmUsXG4gICAgICB0YWtlOiBpbml0aWFsSXRlbXNUb0xvYWQsXG4gICAgICBza2lwOiAwXG4gICAgfVxuICB9KTtcbiAgY29uc3QgY291bnQgPSAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNvdW50KSB8fCAwO1xuICBjb25zdCBvcHRpb25zID0gKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kYXRhJGl0ZW1zID0gZGF0YS5pdGVtcykgPT09IG51bGwgfHwgX2RhdGEkaXRlbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhJGl0ZW1zLm1hcChfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgW2lkRmllbGRdOiB2YWx1ZSxcbiAgICAgIFtsYWJlbEZpZWxkXTogbGFiZWxcbiAgICB9ID0gX3JlZixcbiAgICAgICAgZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbaWRGaWVsZCwgbGFiZWxGaWVsZF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWUsXG4gICAgICBsYWJlbDogbGFiZWwgfHwgdmFsdWUsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgfSkpIHx8IFtdO1xuICBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ29udGV4dFZhbCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBjb3VudCxcbiAgICByZWY6IHNldExvYWRpbmdJbmRpY2F0b3JFbGVtZW50XG4gIH0pLCBbY291bnRdKTtcbiAgdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKFt7XG4gICAgaXNJbnRlcnNlY3RpbmdcbiAgfV0pID0+IHtcbiAgICBpZiAoIWxvYWRpbmcgJiYgaXNJbnRlcnNlY3RpbmcgJiYgb3B0aW9ucy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgY29uc3QgUVVFUlkgPSBjbGllbnQuZ3FsYFxuICAgICAgICAgICAgICBxdWVyeSBSZWxhdGlvbnNoaXBTZWxlY3RNb3JlKCR3aGVyZTogJHtsaXN0LmdxbE5hbWVzLndoZXJlSW5wdXROYW1lfSEsICR0YWtlOiBJbnQhLCAkc2tpcDogSW50ISkge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiAke2xpc3QuZ3FsTmFtZXMubGlzdFF1ZXJ5TmFtZX0od2hlcmU6ICR3aGVyZSwgdGFrZTogJHRha2UsIHNraXA6ICRza2lwKSB7XG4gICAgICAgICAgICAgICAgICAke2xhYmVsRmllbGR9OiAke2xpc3QubGFiZWxGaWVsZH1cbiAgICAgICAgICAgICAgICAgICR7aWRGaWVsZH06IGlkXG4gICAgICAgICAgICAgICAgICAke2V4dHJhU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIGZldGNoTW9yZSh7XG4gICAgICAgIHF1ZXJ5OiBRVUVSWSxcbiAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgd2hlcmUsXG4gICAgICAgICAgdGFrZTogc3Vic2VxdWVudEl0ZW1zVG9Mb2FkLFxuICAgICAgICAgIHNraXA6IGRhdGEuaXRlbXMubGVuZ3RoXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVF1ZXJ5OiAocHJldiwge1xuICAgICAgICAgIGZldGNoTW9yZVJlc3VsdFxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFmZXRjaE1vcmVSZXN1bHQpIHJldHVybiBwcmV2O1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByZXYpLCB7fSwge1xuICAgICAgICAgICAgaXRlbXM6IFsuLi5wcmV2Lml0ZW1zLCAuLi5mZXRjaE1vcmVSZXN1bHQuaXRlbXNdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGN1cnJlbnQ6IGxvYWRpbmdJbmRpY2F0b3JFbGVtZW50XG4gIH0pOyAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgVUlcbiAgLy8gVE9ETzogSGFuZGxlIHBlcm1pc3Npb24gZXJyb3JzXG4gIC8vIChpZTsgdXNlciBoYXMgcGVybWlzc2lvbiB0byByZWFkIHRoaXMgcmVsYXRpb25zaGlwIGZpZWxkLCBidXRcbiAgLy8gbm90IHRoZSByZWxhdGVkIGxpc3QsIG9yIHNvbWUgaXRlbXMgb24gdGhlIGxpc3QpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGNvcmUuanN4KFwic3BhblwiLCBudWxsLCBcIkVycm9yXCIpO1xuICB9XG5cbiAgaWYgKHN0YXRlLmtpbmQgPT09ICdvbmUnKSB7XG4gICAgcmV0dXJuIGNvcmUuanN4KExvYWRpbmdJbmRpY2F0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbG9hZGluZ0luZGljYXRvckNvbnRleHRWYWxcbiAgICB9LCBjb3JlLmpzeChmaWVsZHMuU2VsZWN0IC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVhY3Qtc2VsZWN0IHBhc3NlcyBhIHNlY29uZCBhcmd1bWVudCB0byBvbklucHV0Q2hhbmdlXG4gICAgLy8gYW5kIHVzZVN0YXRlIHNldHRlcnMgbG9nIGEgd2FybmluZyBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAsIHtcbiAgICAgIG9uSW5wdXRDaGFuZ2U6IHZhbCA9PiBzZXRTZWFyY2godmFsKSxcbiAgICAgIGlzTG9hZGluZzogbG9hZGluZyB8fCBpc0xvYWRpbmcsXG4gICAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICAgIGNvbXBvbmVudHM6IHJlbGF0aW9uc2hpcFNlbGVjdENvbXBvbmVudHMsXG4gICAgICBwb3J0YWxNZW51OiBwb3J0YWxNZW51LFxuICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlID8ge1xuICAgICAgICB2YWx1ZTogc3RhdGUudmFsdWUuaWQsXG4gICAgICAgIGxhYmVsOiBzdGF0ZS52YWx1ZS5sYWJlbCxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkYXRhOiBzdGF0ZS52YWx1ZS5kYXRhXG4gICAgICB9IDogbnVsbCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBvbkNoYW5nZTogdmFsdWUgPT4ge1xuICAgICAgICBzdGF0ZS5vbkNoYW5nZSh2YWx1ZSA/IHtcbiAgICAgICAgICBpZDogdmFsdWUudmFsdWUsXG4gICAgICAgICAgbGFiZWw6IHZhbHVlLmxhYmVsLFxuICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGFcbiAgICAgICAgfSA6IG51bGwpO1xuICAgICAgfSxcbiAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgIGNvbnRyb2xTaG91bGRSZW5kZXJWYWx1ZTogY29udHJvbFNob3VsZFJlbmRlclZhbHVlLFxuICAgICAgaXNDbGVhcmFibGU6IGNvbnRyb2xTaG91bGRSZW5kZXJWYWx1ZSxcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gY29yZS5qc3goTG9hZGluZ0luZGljYXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9hZGluZ0luZGljYXRvckNvbnRleHRWYWxcbiAgfSwgY29yZS5qc3goZmllbGRzLk11bHRpU2VsZWN0IC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVhY3Qtc2VsZWN0IHBhc3NlcyBhIHNlY29uZCBhcmd1bWVudCB0byBvbklucHV0Q2hhbmdlXG4gIC8vIGFuZCB1c2VTdGF0ZSBzZXR0ZXJzIGxvZyBhIHdhcm5pbmcgaWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgcGFzc2VkXG4gICwge1xuICAgIG9uSW5wdXRDaGFuZ2U6IHZhbCA9PiBzZXRTZWFyY2godmFsKSxcbiAgICBpc0xvYWRpbmc6IGxvYWRpbmcgfHwgaXNMb2FkaW5nLFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIGNvbXBvbmVudHM6IHJlbGF0aW9uc2hpcFNlbGVjdENvbXBvbmVudHMsXG4gICAgcG9ydGFsTWVudTogcG9ydGFsTWVudSxcbiAgICB2YWx1ZTogc3RhdGUudmFsdWUubWFwKHZhbHVlID0+ICh7XG4gICAgICB2YWx1ZTogdmFsdWUuaWQsXG4gICAgICBsYWJlbDogdmFsdWUubGFiZWwsXG4gICAgICBkYXRhOiB2YWx1ZS5kYXRhXG4gICAgfSkpLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgb25DaGFuZ2U6IHZhbHVlID0+IHtcbiAgICAgIHN0YXRlLm9uQ2hhbmdlKHZhbHVlLm1hcCh4ID0+ICh7XG4gICAgICAgIGlkOiB4LnZhbHVlLFxuICAgICAgICBsYWJlbDogeC5sYWJlbCxcbiAgICAgICAgZGF0YTogeC5kYXRhXG4gICAgICB9KSkpO1xuICAgIH0sXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIGNvbnRyb2xTaG91bGRSZW5kZXJWYWx1ZTogY29udHJvbFNob3VsZFJlbmRlclZhbHVlLFxuICAgIGlzQ2xlYXJhYmxlOiBjb250cm9sU2hvdWxkUmVuZGVyVmFsdWUsXG4gICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZFxuICB9KSk7XG59O1xuY29uc3QgcmVsYXRpb25zaGlwU2VsZWN0Q29tcG9uZW50cyA9IHtcbiAgTWVudUxpc3Q6IF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjIsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQpO1xuXG4gICAgY29uc3Qge1xuICAgICAgY291bnQsXG4gICAgICByZWZcbiAgICB9ID0gUmVhY3QudXNlQ29udGV4dChMb2FkaW5nSW5kaWNhdG9yQ29udGV4dCk7XG4gICAgcmV0dXJuIGNvcmUuanN4KGZpZWxkcy5zZWxlY3RDb21wb25lbnRzLk1lbnVMaXN0LCBwcm9wcywgY2hpbGRyZW4sIGNvcmUuanN4KFwiZGl2XCIsIHtcbiAgICAgIGNzczoge1xuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICB9LFxuICAgICAgcmVmOiByZWZcbiAgICB9LCBwcm9wcy5vcHRpb25zLmxlbmd0aCA8IGNvdW50ICYmIGNvcmUuanN4KFwic3BhblwiLCB7XG4gICAgICBjc3M6IHtcbiAgICAgICAgcGFkZGluZzogOFxuICAgICAgfVxuICAgIH0sIFwiTG9hZGluZy4uLlwiKSkpO1xuICB9XG59O1xuXG5leHBvcnRzLlJlbGF0aW9uc2hpcFNlbGVjdCA9IFJlbGF0aW9uc2hpcFNlbGVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9vYmplY3RTcHJlYWQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBidXR0b24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvYnV0dG9uJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIG1vZGFscyA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9tb2RhbHMnKTtcbnZhciBhZG1pblVpX3JvdXRlcl9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaVJvdXRlciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2FkbWluLXVpL3JvdXRlci9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtYWRtaW4tdWktcm91dGVyLmNqcy5kZXYuanMnKTtcbnZhciBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vYWRtaW4tdWkvY29udGV4dC9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtYWRtaW4tdWktY29udGV4dC5janMuZGV2LmpzJyk7XG52YXIgY2xpZW50ID0gcmVxdWlyZSgnQGFwb2xsby9jbGllbnQnKTtcbnZhciBDZWxsQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9DZWxsQ29udGFpbmVyLTQ1MzI1NGI1LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9BbGVydFRyaWFuZ2xlSWNvbicpO1xucmVxdWlyZSgnbmV4dC9saW5rJyk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xucmVxdWlyZSgnbmV4dC9yb3V0ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9wb3BvdmVyJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTW9yZUhvcml6b250YWxJY29uJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQ2hldnJvblJpZ2h0SWNvbicpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9TaWdub3V0QnV0dG9uLWFjZGIxNTU0LmNqcy5kZXYuanMnKTtcbnZhciBDcmVhdGVJdGVtRHJhd2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9DcmVhdGVJdGVtRHJhd2VyLWZhNGUyMjEzLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9ub3RpY2UnKTtcbnZhciB0b29sdGlwID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL3Rvb2x0aXAnKTtcbnZhciBsb2FkaW5nID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnZhciBkYXRhR2V0dGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9kYXRhR2V0dGVyLTlmYmUyZjhlLmNqcy5kZXYuanMnKTtcbnZhciBnZXRSb290R3JhcGhRTEZpZWxkc0Zyb21GaWVsZENvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L2dldFJvb3RHcmFwaFFMRmllbGRzRnJvbUZpZWxkQ29udHJvbGxlci00NzY5OWEwZC5janMuZGV2LmpzJyk7XG52YXIgaXNEZWVwRXF1YWwgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKTtcbnZhciBmaWVsZHNfdHlwZXNfcmVsYXRpb25zaGlwX3ZpZXdzX1JlbGF0aW9uc2hpcFNlbGVjdF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lRmllbGRzVHlwZXNSZWxhdGlvbnNoaXBWaWV3c1JlbGF0aW9uc2hpcFNlbGVjdCA9IHJlcXVpcmUoJy4uL1JlbGF0aW9uc2hpcFNlbGVjdC9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXJlbGF0aW9uc2hpcC12aWV3cy1SZWxhdGlvbnNoaXBTZWxlY3QuY2pzLmRldi5qcycpO1xudmFyIHRvYXN0ID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL3RvYXN0Jyk7XG52YXIgRmllbGRzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9GaWVsZHMtNGFmYjM4ZjAuY2pzLmRldi5qcycpO1xudmFyIHVzZUludmFsaWRGaWVsZHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L3VzZUludmFsaWRGaWVsZHMtMTYyZDFiOWMuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnYXBvbGxvLXVwbG9hZC1jbGllbnQnKTtcbnJlcXVpcmUoJ0BlbW90aW9uL2hhc2gnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3Qvc3FsaXRlLWFmOWU1MTQ4LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvZ3JhcGhxbC10cy1zY2hlbWEtZmNlN2E2YTguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9hZG1pbi1tZXRhLWdyYXBocWwtOWY5YTljMTEuY2pzLmRldi5qcycpO1xudmFyIEdyYXBoUUxFcnJvck5vdGljZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvR3JhcGhRTEVycm9yTm90aWNlLTc2ZmY5NmRkLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvY29yZS1jOGVjY2UyMy5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10b29scy9zY2hlbWEnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0Jyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEnKTtcbnJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG5yZXF1aXJlKCdncmFwaHFsLXVwbG9hZC9wdWJsaWMvR3JhcGhRTFVwbG9hZC5qcycpO1xucmVxdWlyZSgnZ3JhcGhxbCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcbnJlcXVpcmUoJ0BlbW90aW9uL3dlYWstbWVtb2l6ZScpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5Jyk7XG5yZXF1aXJlKCdpbnRlcnNlY3Rpb24tb2JzZXJ2ZXInKTtcbnJlcXVpcmUoJ3V1aWQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBpc0RlZXBFcXVhbF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoaXNEZWVwRXF1YWwpO1xuXG5mdW5jdGlvbiB1c2VJdGVtU3RhdGUoe1xuICBzZWxlY3RlZEZpZWxkcyxcbiAgbG9jYWxMaXN0LFxuICBpZCxcbiAgZmllbGRcbn0pIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgZXJyb3IsXG4gICAgbG9hZGluZ1xuICB9ID0gY2xpZW50LnVzZVF1ZXJ5KGNsaWVudC5ncWxgcXVlcnkoJGlkOiBJRCEpIHtcbiAgaXRlbTogJHtsb2NhbExpc3QuZ3FsTmFtZXMuaXRlbVF1ZXJ5TmFtZX0od2hlcmU6IHtpZDogJGlkfSkge1xuICAgIGlkXG4gICAgcmVsYXRpb25zaGlwOiAke2ZpZWxkLnBhdGh9IHtcbiAgICAgICR7c2VsZWN0ZWRGaWVsZHN9XG4gICAgfVxuICB9XG59YCwge1xuICAgIHZhcmlhYmxlczoge1xuICAgICAgaWRcbiAgICB9LFxuICAgIGVycm9yUG9saWN5OiAnYWxsJ1xuICB9KTtcbiAgY29uc3Qge1xuICAgIGl0ZW1zQXJyRnJvbURhdGEsXG4gICAgcmVsYXRpb25zaGlwR2V0dGVyXG4gIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBkYXRhR2V0dGVyJDEgPSBkYXRhR2V0dGVyLm1ha2VEYXRhR2V0dGVyKGRhdGEsIGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5ncmFwaFFMRXJyb3JzKTtcbiAgICBjb25zdCByZWxhdGlvbnNoaXBHZXR0ZXIgPSBkYXRhR2V0dGVyJDEuZ2V0KCdpdGVtJykuZ2V0KCdyZWxhdGlvbnNoaXAnKTtcbiAgICBjb25zdCBpc01hbnkgPSBBcnJheS5pc0FycmF5KHJlbGF0aW9uc2hpcEdldHRlci5kYXRhKTtcbiAgICBjb25zdCBpdGVtc0FyckZyb21EYXRhID0gKGlzTWFueSA/IHJlbGF0aW9uc2hpcEdldHRlci5kYXRhLm1hcCgoXywgaSkgPT4gcmVsYXRpb25zaGlwR2V0dGVyLmdldChpKSkgOiBbcmVsYXRpb25zaGlwR2V0dGVyXSkuZmlsdGVyKHggPT4ge1xuICAgICAgdmFyIF94JGRhdGE7XG5cbiAgICAgIHJldHVybiAoKF94JGRhdGEgPSB4LmRhdGEpID09PSBudWxsIHx8IF94JGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF94JGRhdGEuaWQpICE9IG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbGF0aW9uc2hpcEdldHRlcixcbiAgICAgIGl0ZW1zQXJyRnJvbURhdGFcbiAgICB9O1xuICB9LCBbZGF0YSwgZXJyb3JdKTtcbiAgbGV0IFt7XG4gICAgaXRlbXMsXG4gICAgaXRlbXNBcnJGcm9tRGF0YTogaXRlbXNBcnJGcm9tRGF0YVN0YXRlXG4gIH0sIHNldEl0ZW1zU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGl0ZW1zQXJyRnJvbURhdGE6IFtdLFxuICAgIGl0ZW1zOiB7fVxuICB9KTtcblxuICBpZiAoaXRlbXNBcnJGcm9tRGF0YVN0YXRlICE9PSBpdGVtc0FyckZyb21EYXRhKSB7XG4gICAgbGV0IG5ld0l0ZW1zID0ge307XG4gICAgaXRlbXNBcnJGcm9tRGF0YS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdmFyIF9pdGVtcyRpdGVtJGRhdGEkaWQsIF9pdGVtJGVycm9ycywgX2luaXRpYWxJdGVtSW5TdGF0ZSRlO1xuXG4gICAgICBjb25zdCBpbml0aWFsSXRlbUluU3RhdGUgPSAoX2l0ZW1zJGl0ZW0kZGF0YSRpZCA9IGl0ZW1zW2l0ZW0uZGF0YS5pZF0pID09PSBudWxsIHx8IF9pdGVtcyRpdGVtJGRhdGEkaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtcyRpdGVtJGRhdGEkaWQuZnJvbUluaXRpYWxRdWVyeTtcblxuICAgICAgaWYgKChpdGVtc1tpdGVtLmRhdGEuaWRdICYmIGluaXRpYWxJdGVtSW5TdGF0ZSB8fCAhaXRlbXNbaXRlbS5kYXRhLmlkXSkgJiYgKCFpbml0aWFsSXRlbUluU3RhdGUgfHwgaXRlbS5kYXRhICE9PSBpbml0aWFsSXRlbUluU3RhdGUuZGF0YSB8fCAoKF9pdGVtJGVycm9ycyA9IGl0ZW0uZXJyb3JzKSA9PT0gbnVsbCB8fCBfaXRlbSRlcnJvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtJGVycm9ycy5sZW5ndGgpICE9PSAoKF9pbml0aWFsSXRlbUluU3RhdGUkZSA9IGluaXRpYWxJdGVtSW5TdGF0ZS5lcnJvcnMpID09PSBudWxsIHx8IF9pbml0aWFsSXRlbUluU3RhdGUkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luaXRpYWxJdGVtSW5TdGF0ZSRlLmxlbmd0aCkgfHwgKGl0ZW0uZXJyb3JzIHx8IFtdKS5zb21lKChlcnIsIGkpID0+IHtcbiAgICAgICAgdmFyIF9pbml0aWFsSXRlbUluU3RhdGUkZTI7XG5cbiAgICAgICAgcmV0dXJuIGVyciAhPT0gKChfaW5pdGlhbEl0ZW1JblN0YXRlJGUyID0gaW5pdGlhbEl0ZW1JblN0YXRlLmVycm9ycykgPT09IG51bGwgfHwgX2luaXRpYWxJdGVtSW5TdGF0ZSRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luaXRpYWxJdGVtSW5TdGF0ZSRlMltpXSk7XG4gICAgICB9KSkpIHtcbiAgICAgICAgbmV3SXRlbXNbaXRlbS5kYXRhLmlkXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiBpdGVtLFxuICAgICAgICAgIGZyb21Jbml0aWFsUXVlcnk6IGl0ZW1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0l0ZW1zW2l0ZW0uZGF0YS5pZF0gPSBpdGVtc1tpdGVtLmRhdGEuaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGl0ZW1zID0gbmV3SXRlbXM7XG4gICAgc2V0SXRlbXNTdGF0ZSh7XG4gICAgICBpdGVtczogbmV3SXRlbXMsXG4gICAgICBpdGVtc0FyckZyb21EYXRhXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGl0ZW1zOiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zVG9SZXR1cm4gPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGl0ZW1zKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgaXRlbXNUb1JldHVybltpZF0gPSBpdGVtc1tpZF0uY3VycmVudDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zVG9SZXR1cm47XG4gICAgfSwgW2l0ZW1zXSksXG4gICAgc2V0SXRlbXM6IFJlYWN0LnVzZUNhbGxiYWNrKGl0ZW1zID0+IHtcbiAgICAgIHNldEl0ZW1zU3RhdGUoc3RhdGUgPT4ge1xuICAgICAgICBsZXQgaXRlbXNGb3JTdGF0ZSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhpdGVtcykuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgdmFyIF9zdGF0ZSRpdGVtcyRpZDtcblxuICAgICAgICAgIGlmIChpdGVtc1tpZF0gPT09ICgoX3N0YXRlJGl0ZW1zJGlkID0gc3RhdGUuaXRlbXNbaWRdKSA9PT0gbnVsbCB8fCBfc3RhdGUkaXRlbXMkaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRpdGVtcyRpZC5jdXJyZW50KSkge1xuICAgICAgICAgICAgaXRlbXNGb3JTdGF0ZVtpZF0gPSBzdGF0ZS5pdGVtc1tpZF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkaXRlbXMkaWQyO1xuXG4gICAgICAgICAgICBpdGVtc0ZvclN0YXRlW2lkXSA9IHtcbiAgICAgICAgICAgICAgY3VycmVudDogaXRlbXNbaWRdLFxuICAgICAgICAgICAgICBmcm9tSW5pdGlhbFF1ZXJ5OiAoX3N0YXRlJGl0ZW1zJGlkMiA9IHN0YXRlLml0ZW1zW2lkXSkgPT09IG51bGwgfHwgX3N0YXRlJGl0ZW1zJGlkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJGl0ZW1zJGlkMi5mcm9tSW5pdGlhbFF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlbXNBcnJGcm9tRGF0YTogc3RhdGUuaXRlbXNBcnJGcm9tRGF0YSxcbiAgICAgICAgICBpdGVtczogaXRlbXNGb3JTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSwgW3NldEl0ZW1zU3RhdGVdKSxcbiAgICBzdGF0ZTogKCgpID0+IHtcbiAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2luZDogJ2xvYWRpbmcnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwICYmIGVycm9yLm5ldHdvcmtFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubmV0d29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLm1hbnkgJiYgIXJlbGF0aW9uc2hpcEdldHRlci5kYXRhKSB7XG4gICAgICAgIHZhciBfcmVsYXRpb25zaGlwR2V0dGVyJGU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICgoX3JlbGF0aW9uc2hpcEdldHRlciRlID0gcmVsYXRpb25zaGlwR2V0dGVyLmVycm9ycykgPT09IG51bGwgfHwgX3JlbGF0aW9uc2hpcEdldHRlciRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsYXRpb25zaGlwR2V0dGVyJGVbMF0ubWVzc2FnZSkgfHwgJydcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2xvYWRlZCdcbiAgICAgIH07XG4gICAgfSkoKVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRmllbGRzT2JqKGxpc3QsIGZpZWxkcykge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZWRpdEZpZWxkcyA9IHt9O1xuICAgIGZpZWxkcyA9PT0gbnVsbCB8fCBmaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkcy5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XG4gICAgICBlZGl0RmllbGRzW2ZpZWxkUGF0aF0gPSBsaXN0LmZpZWxkc1tmaWVsZFBhdGhdO1xuICAgIH0pO1xuICAgIHJldHVybiBlZGl0RmllbGRzO1xuICB9LCBbZmllbGRzLCBsaXN0LmZpZWxkc10pO1xufVxuXG5mdW5jdGlvbiBJbmxpbmVFZGl0KHtcbiAgZmllbGRzLFxuICBsaXN0LFxuICBzZWxlY3RlZEZpZWxkcyxcbiAgaXRlbUdldHRlcixcbiAgb25DYW5jZWwsXG4gIG9uU2F2ZVxufSkge1xuICB2YXIgX2l0ZW1HZXR0ZXIkZXJyb3JzO1xuXG4gIGNvbnN0IGZpZWxkc09iaiA9IHVzZUZpZWxkc09iaihsaXN0LCBmaWVsZHMpO1xuICBjb25zdCBbdXBkYXRlLCB7XG4gICAgbG9hZGluZyxcbiAgICBlcnJvclxuICB9XSA9IGNsaWVudC51c2VNdXRhdGlvbihjbGllbnQuZ3FsYG11dGF0aW9uICgkZGF0YTogJHtsaXN0LmdxbE5hbWVzLnVwZGF0ZUlucHV0TmFtZX0hLCAkaWQ6IElEISkge1xuICAgICAgICAgIGl0ZW06ICR7bGlzdC5ncWxOYW1lcy51cGRhdGVNdXRhdGlvbk5hbWV9KHdoZXJlOiB7IGlkOiAkaWQgfSwgZGF0YTogJGRhdGEpIHtcbiAgICAgICAgICAgICR7c2VsZWN0ZWRGaWVsZHN9XG4gICAgICAgICAgfVxuICAgICAgICB9YCwge1xuICAgIGVycm9yUG9saWN5OiAnYWxsJ1xuICB9KTtcbiAgY29uc3QgW3N0YXRlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VJbnZhbGlkRmllbGRzLmRlc2VyaWFsaXplVmFsdWUoZmllbGRzT2JqLCBpdGVtR2V0dGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWUsXG4gICAgICBpdGVtOiBpdGVtR2V0dGVyLmRhdGFcbiAgICB9O1xuICB9KTtcblxuICBpZiAoc3RhdGUuaXRlbSAhPT0gaXRlbUdldHRlci5kYXRhICYmIChfaXRlbUdldHRlciRlcnJvcnMgPSBpdGVtR2V0dGVyLmVycm9ycykgIT09IG51bGwgJiYgX2l0ZW1HZXR0ZXIkZXJyb3JzICE9PSB2b2lkIDAgJiYgX2l0ZW1HZXR0ZXIkZXJyb3JzLmV2ZXJ5KHggPT4ge1xuICAgIHZhciBfeCRwYXRoO1xuXG4gICAgcmV0dXJuICgoX3gkcGF0aCA9IHgucGF0aCkgPT09IG51bGwgfHwgX3gkcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3gkcGF0aC5sZW5ndGgpICE9PSAxO1xuICB9KSkge1xuICAgIGNvbnN0IHZhbHVlID0gdXNlSW52YWxpZEZpZWxkcy5kZXNlcmlhbGl6ZVZhbHVlKGZpZWxkc09iaiwgaXRlbUdldHRlcik7XG4gICAgc2V0VmFsdWUoe1xuICAgICAgdmFsdWUsXG4gICAgICBpdGVtOiBpdGVtR2V0dGVyLmRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBjaGFuZ2VkRmllbGRzLFxuICAgIGRhdGFGb3JVcGRhdGVcbiAgfSA9IHVzZUludmFsaWRGaWVsZHMudXNlQ2hhbmdlZEZpZWxkc0FuZERhdGFGb3JVcGRhdGUoZmllbGRzT2JqLCBpdGVtR2V0dGVyLCBzdGF0ZS52YWx1ZSk7XG4gIGNvbnN0IGludmFsaWRGaWVsZHMgPSB1c2VJbnZhbGlkRmllbGRzLnVzZUludmFsaWRGaWVsZHMoZmllbGRzT2JqLCBzdGF0ZS52YWx1ZSk7XG4gIGNvbnN0IFtmb3JjZVZhbGlkYXRpb24sIHNldEZvcmNlVmFsaWRhdGlvbl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHRvYXN0cyA9IHRvYXN0LnVzZVRvYXN0cygpO1xuICBjb25zdCBzYXZlQnV0dG9uUHJvcHMgPSB7XG4gICAgaXNMb2FkaW5nOiBsb2FkaW5nLFxuICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIHNpemU6ICdzbWFsbCcsXG4gICAgdG9uZTogJ2FjdGl2ZScsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgY29uc3QgbmV3Rm9yY2VWYWxpZGF0aW9uID0gaW52YWxpZEZpZWxkcy5zaXplICE9PSAwO1xuICAgICAgc2V0Rm9yY2VWYWxpZGF0aW9uKG5ld0ZvcmNlVmFsaWRhdGlvbik7XG4gICAgICBpZiAobmV3Rm9yY2VWYWxpZGF0aW9uKSByZXR1cm47XG4gICAgICB1cGRhdGUoe1xuICAgICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgICBkYXRhOiBkYXRhRm9yVXBkYXRlLFxuICAgICAgICAgIGlkOiBpdGVtR2V0dGVyLmdldCgnaWQnKS5kYXRhXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZXJyb3JzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIC8vIHdlJ3JlIGNoZWNraW5nIGZvciBwYXRoLmxlbmd0aCA9PT0gMSBiZWNhdXNlIGVycm9ycyB3aXRoIGEgcGF0aCBsYXJnZXIgdGhhbiAxIHdpbGwgYmUgZmllbGQgbGV2ZWwgZXJyb3JzXG4gICAgICAgIC8vIHdoaWNoIGFyZSBoYW5kbGVkIHNlcGVyYXRlbHkgYW5kIGRvIG5vdCBpbmRpY2F0ZSBhIGZhaWx1cmUgdG8gdXBkYXRlIHRoZSBpdGVtXG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzID09PSBudWxsIHx8IGVycm9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3JzLmZpbmQoeCA9PiB7XG4gICAgICAgICAgdmFyIF94JHBhdGgyO1xuXG4gICAgICAgICAgcmV0dXJuICgoX3gkcGF0aDIgPSB4LnBhdGgpID09PSBudWxsIHx8IF94JHBhdGgyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfeCRwYXRoMi5sZW5ndGgpID09PSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0b2FzdHMuYWRkVG9hc3Qoe1xuICAgICAgICAgICAgdGl0bGU6ICdGYWlsZWQgdG8gdXBkYXRlIGl0ZW0nLFxuICAgICAgICAgICAgdG9uZTogJ25lZ2F0aXZlJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2FzdHMuYWRkVG9hc3Qoe1xuICAgICAgICAgICAgdGl0bGU6IGRhdGEuaXRlbVtsaXN0LmxhYmVsRmllbGRdIHx8IGRhdGEuaXRlbS5pZCxcbiAgICAgICAgICAgIHRvbmU6ICdwb3NpdGl2ZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnU2F2ZWQgc3VjY2Vzc2Z1bGx5J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uU2F2ZShkYXRhR2V0dGVyLm1ha2VEYXRhR2V0dGVyKGRhdGEsIGVycm9ycykuZ2V0KCdpdGVtJykpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0b2FzdHMuYWRkVG9hc3Qoe1xuICAgICAgICAgIHRpdGxlOiAnRmFpbGVkIHRvIHVwZGF0ZSBpdGVtJyxcbiAgICAgICAgICB0b25lOiAnbmVnYXRpdmUnLFxuICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjaGlsZHJlbjogJ1NhdmUnXG4gIH07XG4gIHJldHVybiBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInhsYXJnZVwiXG4gIH0sIGVycm9yICYmIGNvcmUuanN4KEdyYXBoUUxFcnJvck5vdGljZS5HcmFwaFFMRXJyb3JOb3RpY2UsIHtcbiAgICBuZXR3b3JrRXJyb3I6IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5uZXR3b3JrRXJyb3IgLy8gd2UncmUgY2hlY2tpbmcgZm9yIHBhdGgubGVuZ3RoID09PSAxIGJlY2F1c2UgZXJyb3JzIHdpdGggYSBwYXRoIGxhcmdlciB0aGFuIDEgd2lsbCBiZSBmaWVsZCBsZXZlbCBlcnJvcnNcbiAgICAvLyB3aGljaCBhcmUgaGFuZGxlZCBzZXBlcmF0ZWx5IGFuZCBkbyBub3QgaW5kaWNhdGUgYSBmYWlsdXJlIHRvIHVwZGF0ZSB0aGUgaXRlbVxuICAgICxcbiAgICBlcnJvcnM6IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5ncmFwaFFMRXJyb3JzLmZpbHRlcih4ID0+IHtcbiAgICAgIHZhciBfeCRwYXRoMztcblxuICAgICAgcmV0dXJuICgoX3gkcGF0aDMgPSB4LnBhdGgpID09PSBudWxsIHx8IF94JHBhdGgzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfeCRwYXRoMy5sZW5ndGgpID09PSAxO1xuICAgIH0pXG4gIH0pLCBjb3JlLmpzeChGaWVsZHMuRmllbGRzLCB7XG4gICAgZmllbGRNb2RlczogbnVsbCxcbiAgICBmaWVsZHM6IGZpZWxkc09iaixcbiAgICBmb3JjZVZhbGlkYXRpb246IGZvcmNlVmFsaWRhdGlvbixcbiAgICBpbnZhbGlkRmllbGRzOiBpbnZhbGlkRmllbGRzLFxuICAgIG9uQ2hhbmdlOiBSZWFjdC51c2VDYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgICBzZXRWYWx1ZShzdGF0ZSA9PiAoe1xuICAgICAgICBpdGVtOiBzdGF0ZS5pdGVtLFxuICAgICAgICB2YWx1ZTogdmFsdWUoc3RhdGUudmFsdWUpXG4gICAgICB9KSk7XG4gICAgfSwgW3NldFZhbHVlXSksXG4gICAgdmFsdWU6IHN0YXRlLnZhbHVlXG4gIH0pLCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgYWNyb3NzOiB0cnVlLFxuICAgIGdhcDogXCJzbWFsbFwiXG4gIH0sIGNoYW5nZWRGaWVsZHMuc2l6ZSA/IGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHNhdmVCdXR0b25Qcm9wcykgOiBjb3JlLmpzeCh0b29sdGlwLlRvb2x0aXAsIHtcbiAgICBjb250ZW50OiBcIk5vIGZpZWxkcyBoYXZlIGJlZW4gbW9kaWZpZWQgc28geW91IGNhbm5vdCBzYXZlIGNoYW5nZXNcIlxuICB9LCBwcm9wcyA9PiBjb3JlLmpzeChidXR0b24uQnV0dG9uLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHNhdmVCdXR0b25Qcm9wcywge1xuICAgIC8vIG1ha2luZyBvbkNsaWNrIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIG1ha2luZyB0aGUgYnV0dG9uIGRpc2FibGVkIHNvIHRoZSBidXR0b24gY2FuIGJlIGZvY3Vzc2VkIHNvIGtleWJvYXJkIHVzZXJzIGNhbiBzZWUgdGhlIHRvb2x0aXBcbiAgICBvbkNsaWNrOiB1bmRlZmluZWRcbiAgfSkpKSwgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICB3ZWlnaHQ6IFwibm9uZVwiLFxuICAgIG9uQ2xpY2s6IG9uQ2FuY2VsXG4gIH0sIFwiQ2FuY2VsXCIpKSk7XG59XG5cbi8qKiBAanN4UnVudGltZSBjbGFzc2ljICovXG5mdW5jdGlvbiBJbmxpbmVDcmVhdGUoe1xuICBsaXN0LFxuICBvbkNhbmNlbCxcbiAgb25DcmVhdGUsXG4gIGZpZWxkczogZmllbGRQYXRocyxcbiAgc2VsZWN0ZWRGaWVsZHNcbn0pIHtcbiAgY29uc3QgdG9hc3RzID0gdG9hc3QudXNlVG9hc3RzKCk7XG4gIGNvbnN0IGZpZWxkcyA9IHVzZUZpZWxkc09iaihsaXN0LCBmaWVsZFBhdGhzKTtcbiAgY29uc3QgW2NyZWF0ZUl0ZW0sIHtcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yXG4gIH1dID0gY2xpZW50LnVzZU11dGF0aW9uKGNsaWVudC5ncWxgbXV0YXRpb24oJGRhdGE6ICR7bGlzdC5ncWxOYW1lcy5jcmVhdGVJbnB1dE5hbWV9ISkge1xuICAgICAgaXRlbTogJHtsaXN0LmdxbE5hbWVzLmNyZWF0ZU11dGF0aW9uTmFtZX0oZGF0YTogJGRhdGEpIHtcbiAgICAgICAgJHtzZWxlY3RlZEZpZWxkc31cbiAgICB9XG4gIH1gKTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goZmllbGRQYXRoID0+IHtcbiAgICAgIHZhbHVlW2ZpZWxkUGF0aF0gPSB7XG4gICAgICAgIGtpbmQ6ICd2YWx1ZScsXG4gICAgICAgIHZhbHVlOiBmaWVsZHNbZmllbGRQYXRoXS5jb250cm9sbGVyLmRlZmF1bHRWYWx1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xuICBjb25zdCBpbnZhbGlkRmllbGRzID0gdXNlSW52YWxpZEZpZWxkcy51c2VJbnZhbGlkRmllbGRzKGZpZWxkcywgdmFsdWUpO1xuICBjb25zdCBbZm9yY2VWYWxpZGF0aW9uLCBzZXRGb3JjZVZhbGlkYXRpb25dID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IG9uQ3JlYXRlQ2xpY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Rm9yY2VWYWxpZGF0aW9uID0gaW52YWxpZEZpZWxkcy5zaXplICE9PSAwO1xuICAgIHNldEZvcmNlVmFsaWRhdGlvbihuZXdGb3JjZVZhbGlkYXRpb24pO1xuICAgIGlmIChuZXdGb3JjZVZhbGlkYXRpb24pIHJldHVybjtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgY29uc3QgYWxsU2VyaWFsaXplZFZhbHVlcyA9IHVzZUludmFsaWRGaWVsZHMuc2VyaWFsaXplVmFsdWVUb09iakJ5RmllbGRLZXkoZmllbGRzLCB2YWx1ZSk7XG4gICAgT2JqZWN0LmtleXMoYWxsU2VyaWFsaXplZFZhbHVlcykuZm9yRWFjaChmaWVsZFBhdGggPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cm9sbGVyXG4gICAgICB9ID0gZmllbGRzW2ZpZWxkUGF0aF07XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gYWxsU2VyaWFsaXplZFZhbHVlc1tmaWVsZFBhdGhdO1xuXG4gICAgICBpZiAoIWlzRGVlcEVxdWFsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShzZXJpYWxpemVkLCBjb250cm9sbGVyLnNlcmlhbGl6ZShjb250cm9sbGVyLmRlZmF1bHRWYWx1ZSkpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3JlYXRlSXRlbSh7XG4gICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHtcbiAgICAgIGRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KSA9PiB7XG4gICAgICAvLyB3ZSdyZSBjaGVja2luZyBmb3IgcGF0aC5sZW5ndGggPT09IDEgYmVjYXVzZSBlcnJvcnMgd2l0aCBhIHBhdGggbGFyZ2VyIHRoYW4gMSB3aWxsIGJlIGZpZWxkIGxldmVsIGVycm9yc1xuICAgICAgLy8gd2hpY2ggYXJlIGhhbmRsZWQgc2VwZXJhdGVseSBhbmQgZG8gbm90IGluZGljYXRlIGEgZmFpbHVyZSB0byB1cGRhdGUgdGhlIGl0ZW1cbiAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzID09PSBudWxsIHx8IGVycm9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3JzLmZpbmQoeCA9PiB7XG4gICAgICAgIHZhciBfeCRwYXRoO1xuXG4gICAgICAgIHJldHVybiAoKF94JHBhdGggPSB4LnBhdGgpID09PSBudWxsIHx8IF94JHBhdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF94JHBhdGgubGVuZ3RoKSA9PT0gMTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RzLmFkZFRvYXN0KHtcbiAgICAgICAgICB0aXRsZTogJ0ZhaWxlZCB0byBjcmVhdGUgaXRlbScsXG4gICAgICAgICAgdG9uZTogJ25lZ2F0aXZlJyxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9hc3RzLmFkZFRvYXN0KHtcbiAgICAgICAgICB0aXRsZTogZGF0YS5pdGVtW2xpc3QubGFiZWxGaWVsZF0gfHwgZGF0YS5pdGVtLmlkLFxuICAgICAgICAgIHRvbmU6ICdwb3NpdGl2ZScsXG4gICAgICAgICAgbWVzc2FnZTogJ1NhdmVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ3JlYXRlKGRhdGFHZXR0ZXIubWFrZURhdGFHZXR0ZXIoZGF0YSwgZXJyb3JzKS5nZXQoJ2l0ZW0nKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIHRvYXN0cy5hZGRUb2FzdCh7XG4gICAgICAgIHRpdGxlOiAnRmFpbGVkIHRvIHVwZGF0ZSBpdGVtJyxcbiAgICAgICAgdG9uZTogJ25lZ2F0aXZlJyxcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInhsYXJnZVwiXG4gIH0sIGVycm9yICYmIGNvcmUuanN4KEdyYXBoUUxFcnJvck5vdGljZS5HcmFwaFFMRXJyb3JOb3RpY2UsIHtcbiAgICBuZXR3b3JrRXJyb3I6IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5uZXR3b3JrRXJyb3IsXG4gICAgZXJyb3JzOiBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZ3JhcGhRTEVycm9yc1xuICB9KSwgY29yZS5qc3goRmllbGRzLkZpZWxkcywge1xuICAgIGZpZWxkTW9kZXM6IG51bGwsXG4gICAgZmllbGRzOiBmaWVsZHMsXG4gICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24sXG4gICAgaW52YWxpZEZpZWxkczogaW52YWxpZEZpZWxkcyxcbiAgICBvbkNoYW5nZTogc2V0VmFsdWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pLCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgYWNyb3NzOiB0cnVlXG4gIH0sIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBpc0xvYWRpbmc6IGxvYWRpbmcsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIHRvbmU6IFwicG9zaXRpdmVcIixcbiAgICB3ZWlnaHQ6IFwiYm9sZFwiLFxuICAgIG9uQ2xpY2s6IG9uQ3JlYXRlQ2xpY2tcbiAgfSwgXCJDcmVhdGUgXCIsIGxpc3Quc2luZ3VsYXIpLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIHdlaWdodDogXCJub25lXCIsXG4gICAgb25DbGljazogb25DYW5jZWxcbiAgfSwgXCJDYW5jZWxcIikpKTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wibW9kZVwiXTtcbmNvbnN0IENhcmRDb250YWluZXIgPSBjb3JlLmZvcndhcmRSZWZXaXRoQXMoKF9yZWYsIHJlZikgPT4ge1xuICBsZXQge1xuICAgIG1vZGUgPSAndmlldydcbiAgfSA9IF9yZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIGNvbnN0IHtcbiAgICB0b25lc1xuICB9ID0gY29yZS51c2VUaGVtZSgpO1xuICBjb25zdCB0b25lID0gdG9uZXNbbW9kZSA9PT0gJ2VkaXQnID8gJ2FjdGl2ZScgOiBtb2RlID09PSAnY3JlYXRlJyA/ICdwb3NpdGl2ZScgOiAncGFzc2l2ZSddO1xuICByZXR1cm4gY29yZS5qc3goY29yZS5Cb3gsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBwYWRkaW5nTGVmdDogXCJ4bGFyZ2VcIixcbiAgICBjc3M6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgJzpiZWZvcmUnOiB7XG4gICAgICAgIGNvbnRlbnQ6ICdcIiBcIicsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdG9uZS5ib3JkZXIsXG4gICAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgICAgd2lkdGg6IDQsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgekluZGV4OiAxXG4gICAgICB9XG4gICAgfVxuICB9LCBwcm9wcykpO1xufSk7XG5mdW5jdGlvbiBDYXJkcyh7XG4gIGxvY2FsTGlzdCxcbiAgZmllbGQsXG4gIGZvcmVpZ25MaXN0LFxuICBpZCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBmb3JjZVZhbGlkYXRpb25cbn0pIHtcbiAgdmFyIF9maWVsZCRkaXNwbGF5JGlubGluZTtcblxuICBsZXQgc2VsZWN0ZWRGaWVsZHMgPSBbLi4ubmV3IFNldChbLi4uZmllbGQuZGlzcGxheS5jYXJkRmllbGRzLCAuLi4oKChfZmllbGQkZGlzcGxheSRpbmxpbmUgPSBmaWVsZC5kaXNwbGF5LmlubGluZUVkaXQpID09PSBudWxsIHx8IF9maWVsZCRkaXNwbGF5JGlubGluZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZpZWxkJGRpc3BsYXkkaW5saW5lLmZpZWxkcykgfHwgW10pXSldLm1hcChmaWVsZFBhdGggPT4ge1xuICAgIHJldHVybiBmb3JlaWduTGlzdC5maWVsZHNbZmllbGRQYXRoXS5jb250cm9sbGVyLmdyYXBocWxTZWxlY3Rpb247XG4gIH0pLmpvaW4oJ1xcbicpO1xuXG4gIGlmICghZmllbGQuZGlzcGxheS5jYXJkRmllbGRzLmluY2x1ZGVzKCdpZCcpKSB7XG4gICAgc2VsZWN0ZWRGaWVsZHMgKz0gJ1xcbmlkJztcbiAgfVxuXG4gIGlmICghZmllbGQuZGlzcGxheS5jYXJkRmllbGRzLmluY2x1ZGVzKGZvcmVpZ25MaXN0LmxhYmVsRmllbGQpICYmIGZvcmVpZ25MaXN0LmxhYmVsRmllbGQgIT09ICdpZCcpIHtcbiAgICBzZWxlY3RlZEZpZWxkcyArPSBgXFxuJHtmb3JlaWduTGlzdC5sYWJlbEZpZWxkfWA7XG4gIH1cblxuICBjb25zdCB7XG4gICAgaXRlbXMsXG4gICAgc2V0SXRlbXMsXG4gICAgc3RhdGU6IGl0ZW1zU3RhdGVcbiAgfSA9IHVzZUl0ZW1TdGF0ZSh7XG4gICAgc2VsZWN0ZWRGaWVsZHMsXG4gICAgbG9jYWxMaXN0LFxuICAgIGlkLFxuICAgIGZpZWxkXG4gIH0pO1xuICBjb25zdCBjbGllbnQkMSA9IGNsaWVudC51c2VBcG9sbG9DbGllbnQoKTtcbiAgY29uc3QgW2lzTG9hZGluZ0xhenlJdGVtcywgc2V0SXNMb2FkaW5nTGF6eUl0ZW1zXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dDb25uZWN0SXRlbXMsIHNldFNob3dDb25uZWN0SXRlbXNdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaGlkZUNvbm5lY3RJdGVtc0xhYmVsLCBzZXRIaWRlQ29ubmVjdEl0ZW1zTGFiZWxdID0gUmVhY3QudXNlU3RhdGUoJ0NhbmNlbCcpO1xuICBjb25zdCBlZGl0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodmFsdWUuaXRlbXNCZWluZ0VkaXRlZCkge1xuICAgICAgdmFyIF9lZGl0UmVmJGN1cnJlbnQ7XG5cbiAgICAgIGVkaXRSZWYgPT09IG51bGwgfHwgZWRpdFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9lZGl0UmVmJGN1cnJlbnQgPSBlZGl0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9lZGl0UmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lZGl0UmVmJGN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuXG4gIGlmIChpdGVtc1N0YXRlLmtpbmQgPT09ICdsb2FkaW5nJykge1xuICAgIHJldHVybiBjb3JlLmpzeChcImRpdlwiLCBudWxsLCBjb3JlLmpzeChsb2FkaW5nLkxvYWRpbmdEb3RzLCB7XG4gICAgICBsYWJlbDogYExvYWRpbmcgaXRlbXMgZm9yICR7ZmllbGQubGFiZWx9IGZpZWxkYFxuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChpdGVtc1N0YXRlLmtpbmQgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gY29yZS5qc3goXCJzcGFuXCIsIHtcbiAgICAgIGNzczoge1xuICAgICAgICBjb2xvcjogJ3JlZCdcbiAgICAgIH1cbiAgICB9LCBpdGVtc1N0YXRlLm1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwieGxhcmdlXCJcbiAgfSwgY29yZS5qc3goY29yZS5TdGFjaywge1xuICAgIGFzOiBcInVsXCIsXG4gICAgZ2FwOiBcInhsYXJnZVwiLFxuICAgIGNzczoge1xuICAgICAgcGFkZGluZzogMCxcbiAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgIGxpOiB7XG4gICAgICAgIGxpc3RTdHlsZTogJ25vbmUnXG4gICAgICB9XG4gICAgfVxuICB9LCBbLi4udmFsdWUuY3VycmVudElkc10ubWFwKChpZCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpdGVtR2V0dGVyID0gaXRlbXNbaWRdO1xuICAgIGNvbnN0IGlzRWRpdE1vZGUgPSAhIShvbkNoYW5nZSAhPT0gdW5kZWZpbmVkKSAmJiB2YWx1ZS5pdGVtc0JlaW5nRWRpdGVkLmhhcyhpZCk7XG4gICAgcmV0dXJuIGNvcmUuanN4KENhcmRDb250YWluZXIsIHtcbiAgICAgIHJvbGU6IFwic3RhdHVzXCIsXG4gICAgICBtb2RlOiBpc0VkaXRNb2RlID8gJ2VkaXQnIDogJ3ZpZXcnXG4gICAgfSwgY29yZS5qc3goY29yZS5WaXN1YWxseUhpZGRlbiwge1xuICAgICAgYXM6IFwiaDJcIlxuICAgIH0sIGAke2ZpZWxkLmxhYmVsfSAke2luZGV4ICsgMX0gJHtpc0VkaXRNb2RlID8gJ2VkaXQnIDogJ3ZpZXcnfSBtb2RlYCksIGlzRWRpdE1vZGUgPyBjb3JlLmpzeChJbmxpbmVFZGl0LCB7XG4gICAgICBsaXN0OiBmb3JlaWduTGlzdCxcbiAgICAgIGZpZWxkczogZmllbGQuZGlzcGxheS5pbmxpbmVFZGl0LmZpZWxkcyxcbiAgICAgIG9uU2F2ZTogbmV3SXRlbUdldHRlciA9PiB7XG4gICAgICAgIHNldEl0ZW1zKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbXMpLCB7fSwge1xuICAgICAgICAgIFtpZF06IG5ld0l0ZW1HZXR0ZXJcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBpdGVtc0JlaW5nRWRpdGVkID0gbmV3IFNldCh2YWx1ZS5pdGVtc0JlaW5nRWRpdGVkKTtcbiAgICAgICAgaXRlbXNCZWluZ0VkaXRlZC5kZWxldGUoaWQpO1xuICAgICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgICBpdGVtc0JlaW5nRWRpdGVkXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEZpZWxkczogc2VsZWN0ZWRGaWVsZHMsXG4gICAgICBpdGVtR2V0dGVyOiBpdGVtR2V0dGVyLFxuICAgICAgb25DYW5jZWw6ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbXNCZWluZ0VkaXRlZCA9IG5ldyBTZXQodmFsdWUuaXRlbXNCZWluZ0VkaXRlZCk7XG4gICAgICAgIGl0ZW1zQmVpbmdFZGl0ZWQuZGVsZXRlKGlkKTtcbiAgICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgICAgaXRlbXNCZWluZ0VkaXRlZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSkgOiBjb3JlLmpzeChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29yZS5qc3goY29yZS5TdGFjaywge1xuICAgICAgZ2FwOiBcInhsYXJnZVwiXG4gICAgfSwgZmllbGQuZGlzcGxheS5jYXJkRmllbGRzLm1hcChmaWVsZFBhdGggPT4ge1xuICAgICAgY29uc3QgZmllbGQgPSBmb3JlaWduTGlzdC5maWVsZHNbZmllbGRQYXRoXTtcbiAgICAgIGNvbnN0IGl0ZW1Gb3JGaWVsZCA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IGdyYXBocWxGaWVsZCBvZiBnZXRSb290R3JhcGhRTEZpZWxkc0Zyb21GaWVsZENvbnRyb2xsZXIuZ2V0Um9vdEdyYXBoUUxGaWVsZHNGcm9tRmllbGRDb250cm9sbGVyKGZpZWxkLmNvbnRyb2xsZXIpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkR2V0dGVyID0gaXRlbUdldHRlci5nZXQoZ3JhcGhxbEZpZWxkKTtcblxuICAgICAgICBpZiAoZmllbGRHZXR0ZXIuZXJyb3JzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZmllbGRHZXR0ZXIuZXJyb3JzWzBdLm1lc3NhZ2U7XG4gICAgICAgICAgcmV0dXJuIGNvcmUuanN4KGZpZWxkcy5GaWVsZENvbnRhaW5lciwgbnVsbCwgY29yZS5qc3goZmllbGRzLkZpZWxkTGFiZWwsIG51bGwsIGZpZWxkLmxhYmVsKSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1Gb3JGaWVsZFtncmFwaHFsRmllbGRdID0gZmllbGRHZXR0ZXIuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvcmUuanN4KGZpZWxkLnZpZXdzLkNhcmRWYWx1ZSwge1xuICAgICAgICBrZXk6IGZpZWxkUGF0aCxcbiAgICAgICAgZmllbGQ6IGZpZWxkLmNvbnRyb2xsZXIsXG4gICAgICAgIGl0ZW06IGl0ZW1Gb3JGaWVsZFxuICAgICAgfSk7XG4gICAgfSkpLCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgICBhY3Jvc3M6IHRydWUsXG4gICAgICBnYXA6IFwic21hbGxcIixcbiAgICAgIG1hcmdpblRvcDogXCJ4bGFyZ2VcIlxuICAgIH0sIGZpZWxkLmRpc3BsYXkuaW5saW5lRWRpdCAmJiBvbkNoYW5nZSAhPT0gdW5kZWZpbmVkICYmIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgIGRpc2FibGVkOiBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgICBpdGVtc0JlaW5nRWRpdGVkOiBuZXcgU2V0KFsuLi52YWx1ZS5pdGVtc0JlaW5nRWRpdGVkLCBpZF0pXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICB0b25lOiBcImFjdGl2ZVwiXG4gICAgfSwgXCJFZGl0XCIpLCBmaWVsZC5kaXNwbGF5LnJlbW92ZU1vZGUgPT09ICdkaXNjb25uZWN0JyAmJiBvbkNoYW5nZSAhPT0gdW5kZWZpbmVkICYmIGNvcmUuanN4KHRvb2x0aXAuVG9vbHRpcCwge1xuICAgICAgY29udGVudDogXCJUaGlzIGl0ZW0gd2lsbCBub3QgYmUgZGVsZXRlZC4gSXQgd2lsbCBvbmx5IGJlIHJlbW92ZWQgZnJvbSB0aGlzIGZpZWxkLlwiXG4gICAgfSwgcHJvcHMgPT4gY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgZGlzYWJsZWQ6IG9uQ2hhbmdlID09PSB1bmRlZmluZWQsXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJZHMgPSBuZXcgU2V0KHZhbHVlLmN1cnJlbnRJZHMpO1xuICAgICAgICBjdXJyZW50SWRzLmRlbGV0ZShpZCk7XG4gICAgICAgIG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICAgIGN1cnJlbnRJZHNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIHByb3BzLCB7XG4gICAgICB0b25lOiBcIm5lZ2F0aXZlXCJcbiAgICB9KSwgXCJSZW1vdmVcIikpLCBmaWVsZC5kaXNwbGF5LmxpbmtUb0l0ZW0gJiYgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgd2VpZ2h0OiBcImxpbmtcIixcbiAgICAgIHRvbmU6IFwiYWN0aXZlXCIsXG4gICAgICBjc3M6IHtcbiAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJ1xuICAgICAgfSxcbiAgICAgIGFzOiBhZG1pblVpX3JvdXRlcl9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaVJvdXRlci5MaW5rLFxuICAgICAgaHJlZjogYC8ke2ZvcmVpZ25MaXN0LnBhdGh9LyR7aWR9YFxuICAgIH0sIFwiVmlldyBcIiwgZm9yZWlnbkxpc3Quc2luZ3VsYXIsIFwiIGRldGFpbHNcIikpKSk7XG4gIH0pKSwgb25DaGFuZ2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmaWVsZC5kaXNwbGF5LmlubGluZUNvbm5lY3QgJiYgc2hvd0Nvbm5lY3RJdGVtcyA/IGNvcmUuanN4KENhcmRDb250YWluZXIsIHtcbiAgICBtb2RlOiBcImVkaXRcIlxuICB9LCBjb3JlLmpzeChjb3JlLlN0YWNrLCB7XG4gICAgZ2FwOiBcInNtYWxsXCIsXG4gICAgbWFyZ2luWTogXCJtZWRpdW1cIixcbiAgICBhY3Jvc3M6IHRydWUsXG4gICAgY3NzOiB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICdkaXY6Zmlyc3Qtb2YtdHlwZSc6IHtcbiAgICAgICAgZmxleDogJzInXG4gICAgICB9XG4gICAgfVxuICB9LCBjb3JlLmpzeChmaWVsZHNfdHlwZXNfcmVsYXRpb25zaGlwX3ZpZXdzX1JlbGF0aW9uc2hpcFNlbGVjdF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lRmllbGRzVHlwZXNSZWxhdGlvbnNoaXBWaWV3c1JlbGF0aW9uc2hpcFNlbGVjdC5SZWxhdGlvbnNoaXBTZWxlY3QsIHtcbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgY29udHJvbFNob3VsZFJlbmRlclZhbHVlOiBpc0xvYWRpbmdMYXp5SXRlbXMsXG4gICAgaXNEaXNhYmxlZDogb25DaGFuZ2UgPT09IHVuZGVmaW5lZCxcbiAgICBsaXN0OiBmb3JlaWduTGlzdCxcbiAgICBpc0xvYWRpbmc6IGlzTG9hZGluZ0xhenlJdGVtcyxcbiAgICBwbGFjZWhvbGRlcjogYFNlbGVjdCBhICR7Zm9yZWlnbkxpc3Quc2luZ3VsYXJ9YCxcbiAgICBwb3J0YWxNZW51OiB0cnVlLFxuICAgIHN0YXRlOiB7XG4gICAgICBraW5kOiAnbWFueScsXG5cbiAgICAgIGFzeW5jIG9uQ2hhbmdlKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVE9ETzogbWF5YmUgdXNlIHRoZSBleHRyYVNlbGVjdGlvbiBwcm9wIG9uIFJlbGF0aW9uc2hpcFNlbGVjdCBoZXJlXG4gICAgICAgIGNvbnN0IGl0ZW1zVG9GZXRjaEFuZENvbm5lY3QgPSBbXTtcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGlmICghdmFsdWUuY3VycmVudElkcy5oYXMoaXRlbS5pZCkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9GZXRjaEFuZENvbm5lY3QucHVzaChpdGVtLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpdGVtc1RvRmV0Y2hBbmRDb25uZWN0Lmxlbmd0aCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfSA9IGF3YWl0IGNsaWVudCQxLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgcXVlcnk6IGNsaWVudC5ncWxgcXVlcnkgKCRpZHM6IFtJRCFdISkge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiAke2ZvcmVpZ25MaXN0LmdxbE5hbWVzLmxpc3RRdWVyeU5hbWV9KHdoZXJlOiB7IGlkOiB7IGluOiAkaWRzIH19KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke3NlbGVjdGVkRmllbGRzfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgICAgICAgIGlkczogaXRlbXNUb0ZldGNoQW5kQ29ubmVjdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFHZXR0ZXJzID0gZGF0YUdldHRlci5tYWtlRGF0YUdldHRlcihkYXRhLCBlcnJvcnMpO1xuICAgICAgICAgICAgICBjb25zdCBpdGVtc0RhdGFHZXR0ZXIgPSBkYXRhR2V0dGVycy5nZXQoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgbGV0IG5ld0l0ZW1zID0gX29iamVjdFNwcmVhZCh7fSwgaXRlbXMpO1xuXG4gICAgICAgICAgICAgIGxldCBuZXdDdXJyZW50SWRzID0gZmllbGQubWFueSA/IG5ldyBTZXQodmFsdWUuY3VycmVudElkcykgOiBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXNEYXRhR2V0dGVyLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhR2V0dGVyLmRhdGEuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0uaWQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3VycmVudElkcy5hZGQoaXRlbS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1zW2l0ZW0uaWRdID0gaXRlbXNEYXRhR2V0dGVyLmdldChpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuZXdDdXJyZW50SWRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50SWRzOiBuZXdDdXJyZW50SWRzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHNldEhpZGVDb25uZWN0SXRlbXNMYWJlbCgnRG9uZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBzZXRJc0xvYWRpbmdMYXp5SXRlbXMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdmFsdWU6ICgoKSA9PiB7XG4gICAgICAgIGxldCBvcHRpb25zID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKGl0ZW1zKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICBpZiAodmFsdWUuY3VycmVudElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbGFiZWw6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH0pKClcbiAgICB9XG4gIH0pLCBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgb25DbGljazogKCkgPT4gc2V0U2hvd0Nvbm5lY3RJdGVtcyhmYWxzZSlcbiAgfSwgaGlkZUNvbm5lY3RJdGVtc0xhYmVsKSkpIDogdmFsdWUuaXRlbUJlaW5nQ3JlYXRlZCA/IGNvcmUuanN4KENhcmRDb250YWluZXIsIHtcbiAgICBtb2RlOiBcImNyZWF0ZVwiXG4gIH0sIGNvcmUuanN4KElubGluZUNyZWF0ZSwge1xuICAgIHNlbGVjdGVkRmllbGRzOiBzZWxlY3RlZEZpZWxkcyxcbiAgICBmaWVsZHM6IGZpZWxkLmRpc3BsYXkuaW5saW5lQ3JlYXRlLmZpZWxkcyxcbiAgICBsaXN0OiBmb3JlaWduTGlzdCxcbiAgICBvbkNhbmNlbDogKCkgPT4ge1xuICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgIGl0ZW1CZWluZ0NyZWF0ZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBvbkNyZWF0ZTogaXRlbUdldHRlciA9PiB7XG4gICAgICBjb25zdCBpZCA9IGl0ZW1HZXR0ZXIuZGF0YS5pZDtcbiAgICAgIHNldEl0ZW1zKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbXMpLCB7fSwge1xuICAgICAgICBbaWRdOiBpdGVtR2V0dGVyXG4gICAgICB9KSk7XG4gICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgaXRlbUJlaW5nQ3JlYXRlZDogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRJZHM6IGZpZWxkLm1hbnkgPyBuZXcgU2V0KFsuLi52YWx1ZS5jdXJyZW50SWRzLCBpZF0pIDogbmV3IFNldChbaWRdKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSkpIDogZmllbGQuZGlzcGxheS5pbmxpbmVDcmVhdGUgfHwgZmllbGQuZGlzcGxheS5pbmxpbmVDb25uZWN0ID8gY29yZS5qc3goQ2FyZENvbnRhaW5lciwge1xuICAgIG1vZGU6IFwiY3JlYXRlXCJcbiAgfSwgY29yZS5qc3goY29yZS5TdGFjaywge1xuICAgIGdhcDogXCJzbWFsbFwiLFxuICAgIG1hcmdpblRvcDogXCJtZWRpdW1cIixcbiAgICBhY3Jvc3M6IHRydWVcbiAgfSwgZmllbGQuZGlzcGxheS5pbmxpbmVDcmVhdGUgJiYgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogb25DaGFuZ2UgPT09IHVuZGVmaW5lZCxcbiAgICB0b25lOiBcInBvc2l0aXZlXCIsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgIGl0ZW1CZWluZ0NyZWF0ZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFwiQ3JlYXRlIFwiLCBmb3JlaWduTGlzdC5zaW5ndWxhciksIGZpZWxkLmRpc3BsYXkuaW5saW5lQ29ubmVjdCAmJiBjb3JlLmpzeChidXR0b24uQnV0dG9uLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIHdlaWdodDogXCJub25lXCIsXG4gICAgdG9uZTogXCJwYXNzaXZlXCIsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgc2V0U2hvd0Nvbm5lY3RJdGVtcyh0cnVlKTtcbiAgICAgIHNldEhpZGVDb25uZWN0SXRlbXNMYWJlbCgnQ2FuY2VsJyk7XG4gICAgfVxuICB9LCBcIkxpbmsgZXhpc3RpbmcgXCIsIGZvcmVpZ25MaXN0LnNpbmd1bGFyKSkpIDogbnVsbCwgZm9yY2VWYWxpZGF0aW9uICYmIGNvcmUuanN4KGNvcmUuVGV4dCwge1xuICAgIGNvbG9yOiBcInJlZDYwMFwiLFxuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCBcIllvdSBtdXN0IGZpbmlzaCBjcmVhdGluZyBhbmQgZWRpdGluZyBhbnkgcmVsYXRlZCBcIiwgZm9yZWlnbkxpc3QubGFiZWwudG9Mb3dlckNhc2UoKSwgXCIgYmVmb3JlIHNhdmluZyB0aGUgXCIsIGxvY2FsTGlzdC5zaW5ndWxhci50b0xvd2VyQ2FzZSgpKSk7XG59XG5cbmZ1bmN0aW9uIExpbmtUb1JlbGF0ZWRJdGVtcyh7XG4gIGl0ZW1JZCxcbiAgaXNEb3VibGVTaWRlZCxcbiAgdmFsdWUsXG4gIGxpc3Rcbn0pIHtcbiAgdmFyIF92YWx1ZSR2YWx1ZTtcblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RRdWVyeSh7XG4gICAgaXNEb3VibGVTaWRlZCxcbiAgICBpdGVtSWQsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIGlmIChpc0RvdWJsZVNpZGVkICYmIGl0ZW1JZCkge1xuICAgICAgcmV0dXJuIGAhYXNzaWduZWRUb19tYXRjaGVzPVwiJHtpdGVtSWR9XCJgO1xuICAgIH1cblxuICAgIHJldHVybiBgIWlkX2luPVwiJHsodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnZhbHVlKS5zbGljZSgwLCAxMDApLm1hcCgoe1xuICAgICAgaWRcbiAgICB9KSA9PiBpZCkuam9pbignLCcpfVwiYDtcbiAgfVxuXG4gIGNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgIHNpemU6ICdzbWFsbCcsXG4gICAgdG9uZTogJ2FjdGl2ZScsXG4gICAgd2VpZ2h0OiAnbGluaydcbiAgfTtcblxuICBpZiAodmFsdWUua2luZCA9PT0gJ21hbnknKSB7XG4gICAgY29uc3QgcXVlcnkgPSBjb25zdHJ1Y3RRdWVyeSh7XG4gICAgICBpc0RvdWJsZVNpZGVkLFxuICAgICAgdmFsdWUsXG4gICAgICBpdGVtSWRcbiAgICB9KTtcbiAgICByZXR1cm4gY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwgX2V4dGVuZHMoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBhczogYWRtaW5VaV9yb3V0ZXJfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlSb3V0ZXIuTGluayxcbiAgICAgIGhyZWY6IGAvJHtsaXN0LnBhdGh9PyR7cXVlcnl9YFxuICAgIH0pLCBcIlZpZXcgcmVsYXRlZCBcIiwgbGlzdC5wbHVyYWwpO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIF9leHRlbmRzKHt9LCBjb21tb25Qcm9wcywge1xuICAgIGFzOiBhZG1pblVpX3JvdXRlcl9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaVJvdXRlci5MaW5rLFxuICAgIGhyZWY6IGAvJHtsaXN0LnBhdGh9LyR7KF92YWx1ZSR2YWx1ZSA9IHZhbHVlLnZhbHVlKSA9PT0gbnVsbCB8fCBfdmFsdWUkdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92YWx1ZSR2YWx1ZS5pZH1gXG4gIH0pLCBcIlZpZXcgXCIsIGxpc3Quc2luZ3VsYXIsIFwiIGRldGFpbHNcIik7XG59XG5cbmNvbnN0IFJlbGF0aW9uc2hpcExpbmtCdXR0b24gPSAoe1xuICBocmVmLFxuICBjaGlsZHJlblxufSkgPT4gY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICBjc3M6IHtcbiAgICBwYWRkaW5nOiAwLFxuICAgIGhlaWdodDogJ2F1dG8nXG4gIH0sXG4gIHdlaWdodDogXCJsaW5rXCIsXG4gIHRvbmU6IFwiYWN0aXZlXCIsXG4gIGFzOiBhZG1pblVpX3JvdXRlcl9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaVJvdXRlci5MaW5rLFxuICBocmVmOiBocmVmXG59LCBjaGlsZHJlbik7XG5cbmNvbnN0IFJlbGF0aW9uc2hpcERpc3BsYXkgPSAoe1xuICBsaXN0LFxuICB2YWx1ZVxufSkgPT4ge1xuICBpZiAodmFsdWUua2luZCA9PT0gJ21hbnknKSB7XG4gICAgaWYgKHZhbHVlLnZhbHVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNvcmUuanN4KGNvcmUuSW5saW5lLCB7XG4gICAgICAgIGdhcDogXCJzbWFsbFwiXG4gICAgICB9LCB2YWx1ZS52YWx1ZS5tYXAoaSA9PiBjb3JlLmpzeChSZWxhdGlvbnNoaXBMaW5rQnV0dG9uLCB7XG4gICAgICAgIGhyZWY6IGAvJHtsaXN0LnBhdGh9LyR7aS5pZH1gXG4gICAgICB9LCBpLmxhYmVsKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29yZS5qc3goXCJkaXZcIiwgbnVsbCwgXCIoTm8gXCIsIGxpc3QucGx1cmFsLCBcIilcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZS52YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcmUuanN4KFJlbGF0aW9uc2hpcExpbmtCdXR0b24sIHtcbiAgICAgICAgaHJlZjogYC8ke2xpc3QucGF0aH0vJHt2YWx1ZS52YWx1ZS5pZH1gXG4gICAgICB9LCB2YWx1ZS52YWx1ZS5sYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb3JlLmpzeChcImRpdlwiLCBudWxsLCBcIihObyBcIiwgbGlzdC5zaW5ndWxhciwgXCIpXCIpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgRmllbGQgPSAoe1xuICBmaWVsZCxcbiAgYXV0b0ZvY3VzLFxuICB2YWx1ZSxcbiAgb25DaGFuZ2UsXG4gIGZvcmNlVmFsaWRhdGlvblxufSkgPT4ge1xuICBjb25zdCBrZXlzdG9uZSA9IGFkbWluVWlfY29udGV4dF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaUNvbnRleHQudXNlS2V5c3RvbmUoKTtcbiAgY29uc3QgZm9yZWlnbkxpc3QgPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUxpc3QoZmllbGQucmVmTGlzdEtleSk7XG4gIGNvbnN0IGxvY2FsTGlzdCA9IGFkbWluVWlfY29udGV4dF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaUNvbnRleHQudXNlTGlzdChmaWVsZC5saXN0S2V5KTtcbiAgY29uc3QgW2lzRHJhd2VyT3Blbiwgc2V0SXNEcmF3ZXJPcGVuXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICBpZiAodmFsdWUua2luZCA9PT0gJ2NhcmRzLXZpZXcnKSB7XG4gICAgcmV0dXJuIGNvcmUuanN4KGZpZWxkcy5GaWVsZENvbnRhaW5lciwge1xuICAgICAgYXM6IFwiZmllbGRzZXRcIlxuICAgIH0sIGNvcmUuanN4KGZpZWxkcy5GaWVsZExlZ2VuZCwgbnVsbCwgZmllbGQubGFiZWwpLCBjb3JlLmpzeChDYXJkcywge1xuICAgICAgZm9yY2VWYWxpZGF0aW9uOiBmb3JjZVZhbGlkYXRpb24sXG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBpZDogdmFsdWUuaWQsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgICBmb3JlaWduTGlzdDogZm9yZWlnbkxpc3QsXG4gICAgICBsb2NhbExpc3Q6IGxvY2FsTGlzdFxuICAgIH0pKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5raW5kID09PSAnY291bnQnKSB7XG4gICAgcmV0dXJuIGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICAgIGFzOiBcImZpZWxkc2V0XCIsXG4gICAgICBnYXA6IFwibWVkaXVtXCJcbiAgICB9LCBjb3JlLmpzeChmaWVsZHMuRmllbGRMZWdlbmQsIG51bGwsIGZpZWxkLmxhYmVsKSwgY29yZS5qc3goXCJkaXZcIiwgbnVsbCwgdmFsdWUuY291bnQgPT09IDEgPyBgVGhlcmUgaXMgMSAke2ZvcmVpZ25MaXN0LnNpbmd1bGFyfSBgIDogYFRoZXJlIGFyZSAke3ZhbHVlLmNvdW50fSAke2ZvcmVpZ25MaXN0LnBsdXJhbH0gYCwgXCJsaW5rZWQgdG8gdGhpcyBcIiwgbG9jYWxMaXN0LnNpbmd1bGFyKSk7XG4gIH1cblxuICByZXR1cm4gY29yZS5qc3goZmllbGRzLkZpZWxkQ29udGFpbmVyLCB7XG4gICAgYXM6IFwiZmllbGRzZXRcIlxuICB9LCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwge1xuICAgIGFzOiBcImxlZ2VuZFwiXG4gIH0sIGZpZWxkLmxhYmVsKSwgb25DaGFuZ2UgPyBjb3JlLmpzeChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29yZS5qc3goY29yZS5TdGFjaywge1xuICAgIGdhcDogXCJtZWRpdW1cIlxuICB9LCBjb3JlLmpzeChmaWVsZHNfdHlwZXNfcmVsYXRpb25zaGlwX3ZpZXdzX1JlbGF0aW9uc2hpcFNlbGVjdF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lRmllbGRzVHlwZXNSZWxhdGlvbnNoaXBWaWV3c1JlbGF0aW9uc2hpcFNlbGVjdC5SZWxhdGlvbnNoaXBTZWxlY3QsIHtcbiAgICBjb250cm9sU2hvdWxkUmVuZGVyVmFsdWU6IHRydWUsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgaXNEaXNhYmxlZDogb25DaGFuZ2UgPT09IHVuZGVmaW5lZCxcbiAgICBsaXN0OiBmb3JlaWduTGlzdCxcbiAgICBwb3J0YWxNZW51OiB0cnVlLFxuICAgIHN0YXRlOiB2YWx1ZS5raW5kID09PSAnbWFueScgPyB7XG4gICAgICBraW5kOiAnbWFueScsXG4gICAgICB2YWx1ZTogdmFsdWUudmFsdWUsXG5cbiAgICAgIG9uQ2hhbmdlKG5ld0l0ZW1zKSB7XG4gICAgICAgIG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICAgIHZhbHVlOiBuZXdJdGVtc1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAga2luZDogJ29uZScsXG4gICAgICB2YWx1ZTogdmFsdWUudmFsdWUsXG5cbiAgICAgIG9uQ2hhbmdlKG5ld1ZhbCkge1xuICAgICAgICBpZiAodmFsdWUua2luZCA9PT0gJ29uZScpIHtcbiAgICAgICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfSksIGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBhY3Jvc3M6IHRydWUsXG4gICAgZ2FwOiBcInNtYWxsXCJcbiAgfSwgIWZpZWxkLmhpZGVDcmVhdGUgJiYgY29yZS5qc3goYnV0dG9uLkJ1dHRvbiwge1xuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogaXNEcmF3ZXJPcGVuLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIHNldElzRHJhd2VyT3Blbih0cnVlKTtcbiAgICB9XG4gIH0sIFwiQ3JlYXRlIHJlbGF0ZWQgXCIsIGZvcmVpZ25MaXN0LnNpbmd1bGFyKSwga2V5c3RvbmUuYXV0aGVudGljYXRlZEl0ZW0uc3RhdGUgPT09ICdhdXRoZW50aWNhdGVkJyAmJiBrZXlzdG9uZS5hdXRoZW50aWNhdGVkSXRlbS5saXN0S2V5ID09PSBmaWVsZC5yZWZMaXN0S2V5ICYmIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgaXNEaXNhYmxlZDogb25DaGFuZ2UgPT09IHVuZGVmaW5lZCxcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBpZiAoa2V5c3RvbmUuYXV0aGVudGljYXRlZEl0ZW0uc3RhdGUgPT09ICdhdXRoZW50aWNhdGVkJykge1xuICAgICAgICBjb25zdCB2YWwgPSB7XG4gICAgICAgICAgbGFiZWw6IGtleXN0b25lLmF1dGhlbnRpY2F0ZWRJdGVtLmxhYmVsLFxuICAgICAgICAgIGlkOiBrZXlzdG9uZS5hdXRoZW50aWNhdGVkSXRlbS5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh2YWx1ZS5raW5kID09PSAnbWFueScpIHtcbiAgICAgICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgICAgIHZhbHVlOiBbLi4udmFsdWUudmFsdWUsIHZhbF1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB2YWx1ZS5raW5kID09PSAnbWFueScgPyAnQWRkICcgOiAnU2V0IGFzICcsIGtleXN0b25lLmF1dGhlbnRpY2F0ZWRJdGVtLmxhYmVsKSwgISEodmFsdWUua2luZCA9PT0gJ21hbnknID8gdmFsdWUudmFsdWUubGVuZ3RoIDogdmFsdWUua2luZCA9PT0gJ29uZScgJiYgdmFsdWUudmFsdWUpICYmIGNvcmUuanN4KExpbmtUb1JlbGF0ZWRJdGVtcywge1xuICAgIGl0ZW1JZDogdmFsdWUuaWQsXG4gICAgaXNEb3VibGVTaWRlZDogISFmaWVsZC5yZWZGaWVsZEtleSxcbiAgICBsaXN0OiBmb3JlaWduTGlzdCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSkpKSwgY29yZS5qc3gobW9kYWxzLkRyYXdlckNvbnRyb2xsZXIsIHtcbiAgICBpc09wZW46IGlzRHJhd2VyT3BlblxuICB9LCBjb3JlLmpzeChDcmVhdGVJdGVtRHJhd2VyLkNyZWF0ZUl0ZW1EcmF3ZXIsIHtcbiAgICBsaXN0S2V5OiBmb3JlaWduTGlzdC5rZXksXG4gICAgb25DbG9zZTogKCkgPT4ge1xuICAgICAgc2V0SXNEcmF3ZXJPcGVuKGZhbHNlKTtcbiAgICB9LFxuICAgIG9uQ3JlYXRlOiB2YWwgPT4ge1xuICAgICAgc2V0SXNEcmF3ZXJPcGVuKGZhbHNlKTtcblxuICAgICAgaWYgKHZhbHVlLmtpbmQgPT09ICdtYW55Jykge1xuICAgICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgICB2YWx1ZTogWy4uLnZhbHVlLnZhbHVlLCB2YWxdXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUua2luZCA9PT0gJ29uZScpIHtcbiAgICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSkpIDogY29yZS5qc3goUmVsYXRpb25zaGlwRGlzcGxheSwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsaXN0OiBmb3JlaWduTGlzdFxuICB9KSk7XG59O1xuY29uc3QgQ2VsbCA9ICh7XG4gIGZpZWxkLFxuICBpdGVtXG59KSA9PiB7XG4gIGNvbnN0IGxpc3QgPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUxpc3QoZmllbGQucmVmTGlzdEtleSk7XG4gIGNvbnN0IHtcbiAgICBjb2xvcnNcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcblxuICBpZiAoZmllbGQuZGlzcGxheS5tb2RlID09PSAnY291bnQnKSB7XG4gICAgdmFyIF9pdGVtJDtcblxuICAgIGNvbnN0IGNvdW50ID0gKF9pdGVtJCA9IGl0ZW1bYCR7ZmllbGQucGF0aH1Db3VudGBdKSAhPT0gbnVsbCAmJiBfaXRlbSQgIT09IHZvaWQgMCA/IF9pdGVtJCA6IDA7XG4gICAgcmV0dXJuIGNvcmUuanN4KENlbGxDb250YWluZXIuQ2VsbENvbnRhaW5lciwgbnVsbCwgY291bnQsIFwiIFwiLCBjb3VudCA9PT0gMSA/IGxpc3Quc2luZ3VsYXIgOiBsaXN0LnBsdXJhbCk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gaXRlbVtmaWVsZC5wYXRoXTtcbiAgY29uc3QgaXRlbXMgPSAoQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV0pLmZpbHRlcihpdGVtID0+IGl0ZW0pO1xuICBjb25zdCBkaXNwbGF5SXRlbXMgPSBpdGVtcy5sZW5ndGggPCA1ID8gaXRlbXMgOiBpdGVtcy5zbGljZSgwLCAzKTtcbiAgY29uc3Qgb3ZlcmZsb3cgPSBpdGVtcy5sZW5ndGggPCA1ID8gMCA6IGl0ZW1zLmxlbmd0aCAtIDM7XG4gIGNvbnN0IHN0eWxlcyA9IHtcbiAgICBjb2xvcjogY29sb3JzLmZvcmVncm91bmQsXG4gICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICAnOmhvdmVyJzoge1xuICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnXG4gICAgfVxuICB9O1xuICByZXR1cm4gY29yZS5qc3goQ2VsbENvbnRhaW5lci5DZWxsQ29udGFpbmVyLCBudWxsLCBkaXNwbGF5SXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIHtcbiAgICBrZXk6IGl0ZW0uaWRcbiAgfSwgISFpbmRleCA/ICcsICcgOiAnJywgY29yZS5qc3goYWRtaW5VaV9yb3V0ZXJfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlSb3V0ZXIuTGluaywge1xuICAgIGhyZWY6IGAvJHtsaXN0LnBhdGh9L1tpZF1gLFxuICAgIGFzOiBgLyR7bGlzdC5wYXRofS8ke2l0ZW0uaWR9YCxcbiAgICBjc3M6IHN0eWxlc1xuICB9LCBpdGVtLmxhYmVsIHx8IGl0ZW0uaWQpKSksIG92ZXJmbG93ID8gYCwgYW5kICR7b3ZlcmZsb3d9IG1vcmVgIDogbnVsbCk7XG59O1xuY29uc3QgQ2FyZFZhbHVlID0gKHtcbiAgZmllbGQsXG4gIGl0ZW1cbn0pID0+IHtcbiAgY29uc3QgbGlzdCA9IGFkbWluVWlfY29udGV4dF9kaXN0X2tleXN0b25lTmV4dEtleXN0b25lQWRtaW5VaUNvbnRleHQudXNlTGlzdChmaWVsZC5yZWZMaXN0S2V5KTtcbiAgY29uc3QgZGF0YSA9IGl0ZW1bZmllbGQucGF0aF07XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIChBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXSkuZmlsdGVyKGl0ZW0gPT4gaXRlbSkubWFwKChpdGVtLCBpbmRleCkgPT4gY29yZS5qc3goUmVhY3QuRnJhZ21lbnQsIHtcbiAgICBrZXk6IGl0ZW0uaWRcbiAgfSwgISFpbmRleCA/ICcsICcgOiAnJywgY29yZS5qc3goYWRtaW5VaV9yb3V0ZXJfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlSb3V0ZXIuTGluaywge1xuICAgIGhyZWY6IGAvJHtsaXN0LnBhdGh9L1tpZF1gLFxuICAgIGFzOiBgLyR7bGlzdC5wYXRofS8ke2l0ZW0uaWR9YFxuICB9LCBpdGVtLmxhYmVsIHx8IGl0ZW0uaWQpKSkpO1xufTtcbmNvbnN0IGNvbnRyb2xsZXIgPSBjb25maWcgPT4ge1xuICByZXR1cm4ge1xuICAgIHJlZkZpZWxkS2V5OiBjb25maWcuZmllbGRNZXRhLnJlZkZpZWxkS2V5LFxuICAgIG1hbnk6IGNvbmZpZy5maWVsZE1ldGEubWFueSxcbiAgICBsaXN0S2V5OiBjb25maWcubGlzdEtleSxcbiAgICBwYXRoOiBjb25maWcucGF0aCxcbiAgICBsYWJlbDogY29uZmlnLmxhYmVsLFxuICAgIGRpc3BsYXk6IGNvbmZpZy5maWVsZE1ldGEuZGlzcGxheU1vZGUgPT09ICdjYXJkcycgPyB7XG4gICAgICBtb2RlOiAnY2FyZHMnLFxuICAgICAgY2FyZEZpZWxkczogY29uZmlnLmZpZWxkTWV0YS5jYXJkRmllbGRzLFxuICAgICAgaW5saW5lQ3JlYXRlOiBjb25maWcuZmllbGRNZXRhLmlubGluZUNyZWF0ZSxcbiAgICAgIGlubGluZUVkaXQ6IGNvbmZpZy5maWVsZE1ldGEuaW5saW5lRWRpdCxcbiAgICAgIGxpbmtUb0l0ZW06IGNvbmZpZy5maWVsZE1ldGEubGlua1RvSXRlbSxcbiAgICAgIHJlbW92ZU1vZGU6IGNvbmZpZy5maWVsZE1ldGEucmVtb3ZlTW9kZSxcbiAgICAgIGlubGluZUNvbm5lY3Q6IGNvbmZpZy5maWVsZE1ldGEuaW5saW5lQ29ubmVjdFxuICAgIH0gOiBjb25maWcuZmllbGRNZXRhLmRpc3BsYXlNb2RlID09PSAnY291bnQnID8ge1xuICAgICAgbW9kZTogJ2NvdW50J1xuICAgIH0gOiB7XG4gICAgICBtb2RlOiAnc2VsZWN0JyxcbiAgICAgIHJlZkxhYmVsRmllbGQ6IGNvbmZpZy5maWVsZE1ldGEucmVmTGFiZWxGaWVsZFxuICAgIH0sXG4gICAgcmVmTGlzdEtleTogY29uZmlnLmZpZWxkTWV0YS5yZWZMaXN0S2V5LFxuICAgIGdyYXBocWxTZWxlY3Rpb246IGNvbmZpZy5maWVsZE1ldGEuZGlzcGxheU1vZGUgPT09ICdjYXJkcycgPyBgJHtjb25maWcucGF0aH0ge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIGxhYmVsOiAke2NvbmZpZy5maWVsZE1ldGEucmVmTGFiZWxGaWVsZH1cbiAgICAgICAgICB9YCA6IGNvbmZpZy5maWVsZE1ldGEuZGlzcGxheU1vZGUgPT09ICdjb3VudCcgPyBgJHtjb25maWcucGF0aH1Db3VudGAgOiBgJHtjb25maWcucGF0aH0ge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICBsYWJlbDogJHtjb25maWcuZmllbGRNZXRhLnJlZkxhYmVsRmllbGR9XG4gICAgICAgICAgICB9YCxcbiAgICBoaWRlQ3JlYXRlOiBjb25maWcuZmllbGRNZXRhLmhpZGVDcmVhdGUsXG4gICAgZGVmYXVsdFZhbHVlOiBjb25maWcuZmllbGRNZXRhLm1hbnkgPyB7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGtpbmQ6ICdtYW55JyxcbiAgICAgIGluaXRpYWxWYWx1ZTogW10sXG4gICAgICB2YWx1ZTogW11cbiAgICB9IDoge1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBraW5kOiAnb25lJyxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgaW5pdGlhbFZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZTogZGF0YSA9PiB7XG4gICAgICBpZiAoY29uZmlnLmZpZWxkTWV0YS5kaXNwbGF5TW9kZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICB2YXIgX2RhdGEkO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAga2luZDogJ2NvdW50JyxcbiAgICAgICAgICBjb3VudDogKF9kYXRhJCA9IGRhdGFbYCR7Y29uZmlnLnBhdGh9Q291bnRgXSkgIT09IG51bGwgJiYgX2RhdGEkICE9PSB2b2lkIDAgPyBfZGF0YSQgOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuZmllbGRNZXRhLmRpc3BsYXlNb2RlID09PSAnY2FyZHMnKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxJZHMgPSBuZXcgU2V0KChBcnJheS5pc0FycmF5KGRhdGFbY29uZmlnLnBhdGhdKSA/IGRhdGFbY29uZmlnLnBhdGhdIDogZGF0YVtjb25maWcucGF0aF0gPyBbZGF0YVtjb25maWcucGF0aF1dIDogW10pLm1hcCh4ID0+IHguaWQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiAnY2FyZHMtdmlldycsXG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgaXRlbXNCZWluZ0VkaXRlZDogbmV3IFNldCgpLFxuICAgICAgICAgIGl0ZW1CZWluZ0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGluaXRpYWxJZHMsXG4gICAgICAgICAgY3VycmVudElkczogaW5pdGlhbElkc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmZpZWxkTWV0YS5tYW55KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IChkYXRhW2NvbmZpZy5wYXRoXSB8fCBbXSkubWFwKHggPT4gKHtcbiAgICAgICAgICBpZDogeC5pZCxcbiAgICAgICAgICBsYWJlbDogeC5sYWJlbCB8fCB4LmlkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiAnbWFueScsXG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSBkYXRhW2NvbmZpZy5wYXRoXTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIGlkOiB2YWx1ZS5pZCxcbiAgICAgICAgICBsYWJlbDogdmFsdWUubGFiZWwgfHwgdmFsdWUuaWRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ29uZScsXG4gICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGZpbHRlcjoge1xuICAgICAgRmlsdGVyOiAoe1xuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgZm9yZWlnbkxpc3QgPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUxpc3QoY29uZmlnLmZpZWxkTWV0YS5yZWZMaXN0S2V5KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZpbHRlclZhbHVlcyxcbiAgICAgICAgICBsb2FkaW5nXG4gICAgICAgIH0gPSB1c2VSZWxhdGlvbnNoaXBGaWx0ZXJWYWx1ZXMoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGxpc3Q6IGZvcmVpZ25MaXN0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICBraW5kOiAnbWFueScsXG4gICAgICAgICAgdmFsdWU6IGZpbHRlclZhbHVlcyxcblxuICAgICAgICAgIG9uQ2hhbmdlKG5ld0l0ZW1zKSB7XG4gICAgICAgICAgICBvbkNoYW5nZShuZXdJdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlkKS5qb2luKCcsJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29yZS5qc3goZmllbGRzX3R5cGVzX3JlbGF0aW9uc2hpcF92aWV3c19SZWxhdGlvbnNoaXBTZWxlY3RfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUZpZWxkc1R5cGVzUmVsYXRpb25zaGlwVmlld3NSZWxhdGlvbnNoaXBTZWxlY3QuUmVsYXRpb25zaGlwU2VsZWN0LCB7XG4gICAgICAgICAgY29udHJvbFNob3VsZFJlbmRlclZhbHVlOiB0cnVlLFxuICAgICAgICAgIGxpc3Q6IGZvcmVpZ25MaXN0LFxuICAgICAgICAgIGlzTG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICBpc0Rpc2FibGVkOiBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBncmFwaHFsOiAoe1xuICAgICAgICB2YWx1ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBmb3JlaWduSWRzID0gZ2V0Rm9yZWlnbklkcyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5maWVsZE1ldGEubWFueSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbY29uZmlnLnBhdGhdOiB7XG4gICAgICAgICAgICAgIHNvbWU6IHtcbiAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgaW46IGZvcmVpZ25JZHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbY29uZmlnLnBhdGhdOiB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICBpbjogZm9yZWlnbklkc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIExhYmVsKHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pIHtcbiAgICAgICAgY29uc3QgZm9yZWlnbkxpc3QgPSBhZG1pblVpX2NvbnRleHRfZGlzdF9rZXlzdG9uZU5leHRLZXlzdG9uZUFkbWluVWlDb250ZXh0LnVzZUxpc3QoY29uZmlnLmZpZWxkTWV0YS5yZWZMaXN0S2V5KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZpbHRlclZhbHVlc1xuICAgICAgICB9ID0gdXNlUmVsYXRpb25zaGlwRmlsdGVyVmFsdWVzKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBsaXN0OiBmb3JlaWduTGlzdFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWZpbHRlclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYGhhcyBubyB2YWx1ZWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyVmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWx0ZXJWYWx1ZXMubWFwKGkgPT4gaS5sYWJlbCkuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYGlzIGluIFske3ZhbHVlc31dYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbkxhYmVsID0gZmlsdGVyVmFsdWVzWzBdLmxhYmVsO1xuICAgICAgICByZXR1cm4gYGlzICR7b3B0aW9uTGFiZWx9YDtcbiAgICAgIH0sXG5cbiAgICAgIHR5cGVzOiB7XG4gICAgICAgIG1hdGNoZXM6IHtcbiAgICAgICAgICBsYWJlbDogJ01hdGNoZXMnLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmtpbmQgIT09ICdjYXJkcy12aWV3JyB8fCB2YWx1ZS5pdGVtc0JlaW5nRWRpdGVkLnNpemUgPT09IDAgJiYgIXZhbHVlLml0ZW1CZWluZ0NyZWF0ZWQ7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlLmtpbmQgPT09ICdtYW55Jykge1xuICAgICAgICBjb25zdCBuZXdBbGxJZHMgPSBuZXcgU2V0KHN0YXRlLnZhbHVlLm1hcCh4ID0+IHguaWQpKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbElkcyA9IG5ldyBTZXQoc3RhdGUuaW5pdGlhbFZhbHVlLm1hcCh4ID0+IHguaWQpKTtcbiAgICAgICAgbGV0IGRpc2Nvbm5lY3QgPSBzdGF0ZS5pbml0aWFsVmFsdWUuZmlsdGVyKHggPT4gIW5ld0FsbElkcy5oYXMoeC5pZCkpLm1hcCh4ID0+ICh7XG4gICAgICAgICAgaWQ6IHguaWRcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgY29ubmVjdCA9IHN0YXRlLnZhbHVlLmZpbHRlcih4ID0+ICFpbml0aWFsSWRzLmhhcyh4LmlkKSkubWFwKHggPT4gKHtcbiAgICAgICAgICBpZDogeC5pZFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGRpc2Nvbm5lY3QubGVuZ3RoIHx8IGNvbm5lY3QubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IG91dHB1dCA9IHt9O1xuXG4gICAgICAgICAgaWYgKGRpc2Nvbm5lY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbm5lY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQuY29ubmVjdCA9IGNvbm5lY3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtjb25maWcucGF0aF06IG91dHB1dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUua2luZCA9PT0gJ29uZScpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRpbml0aWFsVmFsdWU7XG5cbiAgICAgICAgaWYgKHN0YXRlLmluaXRpYWxWYWx1ZSAmJiAhc3RhdGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgICBkaXNjb25uZWN0OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS52YWx1ZSAmJiBzdGF0ZS52YWx1ZS5pZCAhPT0gKChfc3RhdGUkaW5pdGlhbFZhbHVlID0gc3RhdGUuaW5pdGlhbFZhbHVlKSA9PT0gbnVsbCB8fCBfc3RhdGUkaW5pdGlhbFZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkaW5pdGlhbFZhbHVlLmlkKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbY29uZmlnLnBhdGhdOiB7XG4gICAgICAgICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICAgICAgICBpZDogc3RhdGUudmFsdWUuaWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUua2luZCA9PT0gJ2NhcmRzLXZpZXcnKSB7XG4gICAgICAgIGxldCBkaXNjb25uZWN0ID0gWy4uLnN0YXRlLmluaXRpYWxJZHNdLmZpbHRlcihpZCA9PiAhc3RhdGUuY3VycmVudElkcy5oYXMoaWQpKS5tYXAoaWQgPT4gKHtcbiAgICAgICAgICBpZFxuICAgICAgICB9KSk7XG4gICAgICAgIGxldCBjb25uZWN0ID0gWy4uLnN0YXRlLmN1cnJlbnRJZHNdLmZpbHRlcihpZCA9PiAhc3RhdGUuaW5pdGlhbElkcy5oYXMoaWQpKS5tYXAoaWQgPT4gKHtcbiAgICAgICAgICBpZFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5maWVsZE1ldGEubWFueSkge1xuICAgICAgICAgIGlmIChkaXNjb25uZWN0Lmxlbmd0aCB8fCBjb25uZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QubGVuZ3RoID8gY29ubmVjdCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0Lmxlbmd0aCA/IGRpc2Nvbm5lY3QgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgICAgICBjb25uZWN0OiBjb25uZWN0WzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXNjb25uZWN0Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbY29uZmlnLnBhdGhdOiB7XG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiB1c2VSZWxhdGlvbnNoaXBGaWx0ZXJWYWx1ZXMoe1xuICB2YWx1ZSxcbiAgbGlzdFxufSkge1xuICB2YXIgX2RhdGEkaXRlbXM7XG5cbiAgY29uc3QgZm9yZWlnbklkcyA9IGdldEZvcmVpZ25JZHModmFsdWUpO1xuICBjb25zdCB3aGVyZSA9IHtcbiAgICBpZDoge1xuICAgICAgaW46IGZvcmVpZ25JZHNcbiAgICB9XG4gIH07XG4gIGNvbnN0IHF1ZXJ5ID0gY2xpZW50LmdxbGBcbiAgICBxdWVyeSBGT1JFSUdOTElTVF9RVUVSWSgkd2hlcmU6ICR7bGlzdC5ncWxOYW1lcy53aGVyZUlucHV0TmFtZX0hKSB7XG4gICAgICBpdGVtczogJHtsaXN0LmdxbE5hbWVzLmxpc3RRdWVyeU5hbWV9KHdoZXJlOiAkd2hlcmUpIHtcbiAgICAgICAgaWQgXG4gICAgICAgICR7bGlzdC5sYWJlbEZpZWxkfVxuICAgICAgfVxuICAgIH1cbiAgYDtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgbG9hZGluZ1xuICB9ID0gY2xpZW50LnVzZVF1ZXJ5KHF1ZXJ5LCB7XG4gICAgdmFyaWFibGVzOiB7XG4gICAgICB3aGVyZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVmFsdWVzOiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RhdGEkaXRlbXMgPSBkYXRhLml0ZW1zKSA9PT0gbnVsbCB8fCBfZGF0YSRpdGVtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIGxhYmVsOiBpdGVtW2xpc3QubGFiZWxGaWVsZF0gfHwgaXRlbS5pZFxuICAgICAgfTtcbiAgICB9KSkgfHwgZm9yZWlnbklkcy5tYXAoZiA9PiAoe1xuICAgICAgbGFiZWw6IGYsXG4gICAgICBpZDogZlxuICAgIH0pKSxcbiAgICBsb2FkaW5nOiBsb2FkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZvcmVpZ25JZHModmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnLCcpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnRzLkNhcmRWYWx1ZSA9IENhcmRWYWx1ZTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtcmVsYXRpb25zaGlwLXZpZXdzLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy1yZWxhdGlvbnNoaXAtdmlld3MuY2pzLmRldi5qc1wiKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9vYmplY3RTcHJlYWQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIHNlZ21lbnRlZENvbnRyb2wgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvc2VnbWVudGVkLWNvbnRyb2wnKTtcbnZhciBidXR0b24gPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvYnV0dG9uJyk7XG52YXIgQ2VsbENvbnRhaW5lciA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvQ2VsbENvbnRhaW5lci00NTMyNTRiNS5janMuZGV2LmpzJyk7XG52YXIgQ2VsbExpbmsgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L0NlbGxMaW5rLWRjNDFjODc3LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9BbGVydFRyaWFuZ2xlSWNvbicpO1xucmVxdWlyZSgnbmV4dC9saW5rJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvdG9hc3QnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9sb2FkaW5nJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbW9kYWxzJyk7XG5yZXF1aXJlKCdhcG9sbG8tdXBsb2FkLWNsaWVudCcpO1xucmVxdWlyZSgnQGVtb3Rpb24vaGFzaCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9zcWxpdGUtYWY5ZTUxNDguY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9ncmFwaHFsLXRzLXNjaGVtYS1mY2U3YTZhOC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYXBvbGxvL2NsaWVudCcpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9hZG1pbi1tZXRhLWdyYXBocWwtOWY5YTljMTEuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG5yZXF1aXJlKCduZXh0L3JvdXRlcicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3BvcG92ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Nb3JlSG9yaXpvbnRhbEljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uUmlnaHRJY29uJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L1NpZ25vdXRCdXR0b24tYWNkYjE1NTQuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbm90aWNlJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9hZG1pbi11aS9yb3V0ZXIvZGlzdC9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWFkbWluLXVpLXJvdXRlci5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10b29scy9zY2hlbWEnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYS9hcGktd2l0aG91dC1jb250ZXh0Jyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEnKTtcbnJlcXVpcmUoJ2dyYXBocWwtdHlwZS1qc29uJyk7XG5yZXF1aXJlKCdncmFwaHFsLXVwbG9hZC9wdWJsaWMvR3JhcGhRTFVwbG9hZC5qcycpO1xucmVxdWlyZSgnZ3JhcGhxbCcpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHQnKTtcblxuY29uc3QgRmllbGQgPSAoe1xuICBmaWVsZCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBhdXRvRm9jdXMsXG4gIGZvcmNlVmFsaWRhdGlvblxufSkgPT4ge1xuICBjb25zdCBbaGFzQ2hhbmdlZCwgc2V0SGFzQ2hhbmdlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHZhbGlkYXRpb25NZXNzYWdlID0gKGhhc0NoYW5nZWQgfHwgZm9yY2VWYWxpZGF0aW9uKSAmJiAhdmFsaWRhdGUodmFsdWUsIGZpZWxkLmlzUmVxdWlyZWQpID8gY29yZS5qc3goY29yZS5UZXh0LCB7XG4gICAgY29sb3I6IFwicmVkNjAwXCIsXG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0sIGZpZWxkLmxhYmVsLCBcIiBpcyByZXF1aXJlZFwiKSA6IG51bGw7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIHtcbiAgICBhczogZmllbGQuZGlzcGxheU1vZGUgPT09ICdzZWxlY3QnID8gJ2RpdicgOiAnZmllbGRzZXQnXG4gIH0sIGZpZWxkLmRpc3BsYXlNb2RlID09PSAnc2VsZWN0JyA/IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwge1xuICAgIGh0bWxGb3I6IGZpZWxkLnBhdGhcbiAgfSwgZmllbGQubGFiZWwpLCBjb3JlLmpzeChmaWVsZHMuU2VsZWN0LCB7XG4gICAgaWQ6IGZpZWxkLnBhdGgsXG4gICAgaXNDbGVhcmFibGU6IHRydWUsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgb3B0aW9uczogZmllbGQub3B0aW9ucyxcbiAgICBpc0Rpc2FibGVkOiBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkLFxuICAgIG9uQ2hhbmdlOiBuZXdWYWwgPT4ge1xuICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICB2YWx1ZTogbmV3VmFsXG4gICAgICB9KSk7XG4gICAgICBzZXRIYXNDaGFuZ2VkKHRydWUpO1xuICAgIH0sXG4gICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgIHBvcnRhbE1lbnU6IHRydWVcbiAgfSksIHZhbGlkYXRpb25NZXNzYWdlKSA6IGNvcmUuanN4KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwge1xuICAgIGFzOiBcImxlZ2VuZFwiXG4gIH0sIGZpZWxkLmxhYmVsKSwgY29yZS5qc3goY29yZS5TdGFjaywge1xuICAgIGFjcm9zczogdHJ1ZSxcbiAgICBnYXA6IFwic21hbGxcIixcbiAgICBhbGlnbjogXCJjZW50ZXJcIlxuICB9LCBjb3JlLmpzeChzZWdtZW50ZWRDb250cm9sLlNlZ21lbnRlZENvbnRyb2wsIHtcbiAgICBzZWdtZW50czogZmllbGQub3B0aW9ucy5tYXAoeCA9PiB4LmxhYmVsKSxcbiAgICBzZWxlY3RlZEluZGV4OiB2YWx1ZS52YWx1ZSA/IGZpZWxkLm9wdGlvbnMuZmluZEluZGV4KHggPT4geC52YWx1ZSA9PT0gdmFsdWUudmFsdWUudmFsdWUpIDogdW5kZWZpbmVkLFxuICAgIG9uQ2hhbmdlOiBpbmRleCA9PiB7XG4gICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBmaWVsZC5vcHRpb25zW2luZGV4XVxuICAgICAgfSkpO1xuICAgICAgc2V0SGFzQ2hhbmdlZCh0cnVlKTtcbiAgICB9XG4gIH0pLCB2YWx1ZS52YWx1ZSAhPT0gbnVsbCAmJiBvbkNoYW5nZSAhPT0gdW5kZWZpbmVkICYmIGNvcmUuanN4KGJ1dHRvbi5CdXR0b24sIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pKTtcbiAgICAgIHNldEhhc0NoYW5nZWQodHJ1ZSk7XG4gICAgfVxuICB9LCBcIkNsZWFyXCIpKSwgdmFsaWRhdGlvbk1lc3NhZ2UpKTtcbn07XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGQsXG4gIGxpbmtUb1xufSkgPT4ge1xuICB2YXIgX2ZpZWxkJG9wdGlvbnMkZmluZDtcblxuICBsZXQgdmFsdWUgPSBpdGVtW2ZpZWxkLnBhdGhdICsgJyc7XG4gIGNvbnN0IGxhYmVsID0gKF9maWVsZCRvcHRpb25zJGZpbmQgPSBmaWVsZC5vcHRpb25zLmZpbmQoeCA9PiB4LnZhbHVlID09PSB2YWx1ZSkpID09PSBudWxsIHx8IF9maWVsZCRvcHRpb25zJGZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maWVsZCRvcHRpb25zJGZpbmQubGFiZWw7XG4gIHJldHVybiBsaW5rVG8gPyBjb3JlLmpzeChDZWxsTGluay5DZWxsTGluaywgbGlua1RvLCBsYWJlbCkgOiBjb3JlLmpzeChDZWxsQ29udGFpbmVyLkNlbGxDb250YWluZXIsIG51bGwsIGxhYmVsKTtcbn07XG5DZWxsLnN1cHBvcnRzTGlua1RvID0gdHJ1ZTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHZhciBfZmllbGQkb3B0aW9ucyRmaW5kMjtcblxuICBsZXQgdmFsdWUgPSBpdGVtW2ZpZWxkLnBhdGhdICsgJyc7XG4gIGNvbnN0IGxhYmVsID0gKF9maWVsZCRvcHRpb25zJGZpbmQyID0gZmllbGQub3B0aW9ucy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpKSA9PT0gbnVsbCB8fCBfZmllbGQkb3B0aW9ucyRmaW5kMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZpZWxkJG9wdGlvbnMkZmluZDIubGFiZWw7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGxhYmVsKTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBpc1JlcXVpcmVkKSB7XG4gIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgLy8gaWYgeW91IGdvdCBudWxsIGluaXRpYWxseSBvbiB0aGUgdXBkYXRlIHNjcmVlbiwgd2Ugd2FudCB0byBhbGxvdyBzYXZpbmdcbiAgICAvLyBzaW5jZSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgcmVhZCBhY2Nlc3MgY29udHJvbFxuICAgIGlmICh2YWx1ZS5raW5kID09PSAndXBkYXRlJyAmJiB2YWx1ZS5pbml0aWFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudmFsdWUgIT09IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgY29udHJvbGxlciA9IGNvbmZpZyA9PiB7XG4gIHZhciBfY29uZmlnJGZpZWxkTWV0YSRkZWYsIF9vcHRpb25zV2l0aFN0cmluZ1ZhbDtcblxuICBjb25zdCBvcHRpb25zV2l0aFN0cmluZ1ZhbHVlcyA9IGNvbmZpZy5maWVsZE1ldGEub3B0aW9ucy5tYXAoeCA9PiAoe1xuICAgIGxhYmVsOiB4LmxhYmVsLFxuICAgIHZhbHVlOiB4LnZhbHVlLnRvU3RyaW5nKClcbiAgfSkpOyAvLyBUcmFuc2Zvcm0gZnJvbSBzdHJpbmcgdmFsdWUgdG8gdHlwZSBhcHByb3ByaWF0ZSB2YWx1ZVxuXG4gIGNvbnN0IHQgPSB2ID0+IHYgPT09IG51bGwgPyBudWxsIDogY29uZmlnLmZpZWxkTWV0YS50eXBlID09PSAnaW50ZWdlcicgPyBwYXJzZUludCh2KSA6IHY7XG5cbiAgY29uc3Qgc3RyaW5naWZpZWREZWZhdWx0ID0gKF9jb25maWckZmllbGRNZXRhJGRlZiA9IGNvbmZpZy5maWVsZE1ldGEuZGVmYXVsdFZhbHVlKSA9PT0gbnVsbCB8fCBfY29uZmlnJGZpZWxkTWV0YSRkZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25maWckZmllbGRNZXRhJGRlZi50b1N0cmluZygpO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgIGxhYmVsOiBjb25maWcubGFiZWwsXG4gICAgZ3JhcGhxbFNlbGVjdGlvbjogY29uZmlnLnBhdGgsXG4gICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgIHZhbHVlOiAoX29wdGlvbnNXaXRoU3RyaW5nVmFsID0gb3B0aW9uc1dpdGhTdHJpbmdWYWx1ZXMuZmluZCh4ID0+IHgudmFsdWUgPT09IHN0cmluZ2lmaWVkRGVmYXVsdCkpICE9PSBudWxsICYmIF9vcHRpb25zV2l0aFN0cmluZ1ZhbCAhPT0gdm9pZCAwID8gX29wdGlvbnNXaXRoU3RyaW5nVmFsIDogbnVsbFxuICAgIH0sXG4gICAgdHlwZTogY29uZmlnLmZpZWxkTWV0YS50eXBlLFxuICAgIGRpc3BsYXlNb2RlOiBjb25maWcuZmllbGRNZXRhLmRpc3BsYXlNb2RlLFxuICAgIGlzUmVxdWlyZWQ6IGNvbmZpZy5maWVsZE1ldGEuaXNSZXF1aXJlZCxcbiAgICBvcHRpb25zOiBvcHRpb25zV2l0aFN0cmluZ1ZhbHVlcyxcbiAgICBkZXNlcmlhbGl6ZTogZGF0YSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBjb25maWcuZmllbGRNZXRhLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gZGF0YVtjb25maWcucGF0aF0pIHtcbiAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZE9wdGlvbiA9IHtcbiAgICAgICAgICAgIGxhYmVsOiBvcHRpb24ubGFiZWwsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAndXBkYXRlJyxcbiAgICAgICAgICAgIGluaXRpYWw6IHN0cmluZ2lmaWVkT3B0aW9uLFxuICAgICAgICAgICAgdmFsdWU6IHN0cmluZ2lmaWVkT3B0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAndXBkYXRlJyxcbiAgICAgICAgaW5pdGlhbDogbnVsbCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IHZhbHVlID0+IHtcbiAgICAgIHZhciBfdmFsdWUkdmFsdWUkdmFsdWUsIF92YWx1ZSR2YWx1ZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXTogdCgoX3ZhbHVlJHZhbHVlJHZhbHVlID0gKF92YWx1ZSR2YWx1ZSA9IHZhbHVlLnZhbHVlKSA9PT0gbnVsbCB8fCBfdmFsdWUkdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92YWx1ZSR2YWx1ZS52YWx1ZSkgIT09IG51bGwgJiYgX3ZhbHVlJHZhbHVlJHZhbHVlICE9PSB2b2lkIDAgPyBfdmFsdWUkdmFsdWUkdmFsdWUgOiBudWxsKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiB2YWxpZGF0ZSh2YWx1ZSwgY29uZmlnLmZpZWxkTWV0YS5pc1JlcXVpcmVkKSxcbiAgICBmaWx0ZXI6IHtcbiAgICAgIEZpbHRlcihwcm9wcykge1xuICAgICAgICByZXR1cm4gY29yZS5qc3goZmllbGRzLk11bHRpU2VsZWN0LCB7XG4gICAgICAgICAgb25DaGFuZ2U6IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRoU3RyaW5nVmFsdWVzLFxuICAgICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICAgICAgICBhdXRvRm9jdXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBncmFwaHFsOiAoe1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgfSkgPT4gKHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXToge1xuICAgICAgICAgIFt0eXBlID09PSAnbm90X21hdGNoZXMnID8gJ25vdEluJyA6ICdpbiddOiBvcHRpb25zLm1hcCh4ID0+IHQoeC52YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBMYWJlbCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdub3RfbWF0Y2hlcycgPyBgaXMgc2V0YCA6IGBoYXMgbm8gdmFsdWVgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5tYXAoaSA9PiBpLmxhYmVsKS5qb2luKCcsICcpO1xuICAgICAgICAgIHJldHVybiB0eXBlID09PSAnbm90X21hdGNoZXMnID8gYGlzIG5vdCBpbiBbJHt2YWx1ZXN9XWAgOiBgaXMgaW4gWyR7dmFsdWVzfV1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uTGFiZWwgPSB2YWx1ZVswXS5sYWJlbDtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdub3RfbWF0Y2hlcycgPyBgaXMgbm90ICR7b3B0aW9uTGFiZWx9YCA6IGBpcyAke29wdGlvbkxhYmVsfWA7XG4gICAgICB9LFxuXG4gICAgICB0eXBlczoge1xuICAgICAgICBtYXRjaGVzOiB7XG4gICAgICAgICAgbGFiZWw6ICdNYXRjaGVzJyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG5vdF9tYXRjaGVzOiB7XG4gICAgICAgICAgbGFiZWw6ICdEb2VzIG5vdCBtYXRjaCcsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5DYXJkVmFsdWUgPSBDYXJkVmFsdWU7XG5leHBvcnRzLkNlbGwgPSBDZWxsO1xuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tleXN0b25lLW5leHQta2V5c3RvbmUtZmllbGRzLXR5cGVzLXNlbGVjdC12aWV3cy5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtc2VsZWN0LXZpZXdzLmNqcy5kZXYuanNcIik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfb2JqZWN0U3ByZWFkID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9jb3JlJyk7XG52YXIgZmllbGRzID0gcmVxdWlyZSgnQGtleXN0b25lLXVpL2ZpZWxkcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBDZWxsQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9DZWxsQ29udGFpbmVyLTQ1MzI1NGI1LmNqcy5kZXYuanMnKTtcbnZhciBDZWxsTGluayA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvQ2VsbExpbmstZGM0MWM4NzcuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2J1dHRvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsZXJ0VHJpYW5nbGVJY29uJyk7XG5yZXF1aXJlKCduZXh0L2xpbmsnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b2FzdCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9tb2RhbHMnKTtcbnJlcXVpcmUoJ2Fwb2xsby11cGxvYWQtY2xpZW50Jyk7XG5yZXF1aXJlKCdAZW1vdGlvbi9oYXNoJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L3NxbGl0ZS1hZjllNTE0OC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L2dyYXBocWwtdHMtc2NoZW1hLWZjZTdhNmE4LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BhcG9sbG8vY2xpZW50Jyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L2FkbWluLW1ldGEtZ3JhcGhxbC05ZjlhOWMxMS5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcbnJlcXVpcmUoJ25leHQvcm91dGVyJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvcG9wb3ZlcicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01vcmVIb3Jpem9udGFsSWNvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0NoZXZyb25SaWdodEljb24nKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvU2lnbm91dEJ1dHRvbi1hY2RiMTU1NC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9ub3RpY2UnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2FkbWluLXVpL3JvdXRlci9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtYWRtaW4tdWktcm91dGVyLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRvb2xzL3NjaGVtYScpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRob3V0LWNvbnRleHQnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYScpO1xucmVxdWlyZSgnZ3JhcGhxbC10eXBlLWpzb24nKTtcbnJlcXVpcmUoJ2dyYXBocWwtdXBsb2FkL3B1YmxpYy9HcmFwaFFMVXBsb2FkLmpzJyk7XG5yZXF1aXJlKCdncmFwaHFsJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGgtY29udGV4dCcpO1xuXG5jb25zdCBGaWVsZCA9ICh7XG4gIGZpZWxkLFxuICB2YWx1ZSxcbiAgb25DaGFuZ2UsXG4gIGF1dG9Gb2N1cyxcbiAgZm9yY2VWYWxpZGF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBvZ3JhcGh5LFxuICAgIGZpZWxkczogZmllbGRzJDFcbiAgfSA9IGNvcmUudXNlVGhlbWUoKTtcbiAgY29uc3QgW3Nob3VsZFNob3dFcnJvcnMsIHNldFNob3VsZFNob3dFcnJvcnNdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB2YWxpZGF0aW9uTWVzc2FnZXMgPSB2YWxpZGF0ZSh2YWx1ZSwgZmllbGQudmFsaWRhdGlvbiwgZmllbGQubGFiZWwpO1xuICByZXR1cm4gY29yZS5qc3goZmllbGRzLkZpZWxkQ29udGFpbmVyLCBudWxsLCBjb3JlLmpzeChmaWVsZHMuRmllbGRMYWJlbCwgbnVsbCwgZmllbGQubGFiZWwpLCBvbkNoYW5nZSA/IGNvcmUuanN4KGNvcmUuU3RhY2ssIHtcbiAgICBnYXA6IFwic21hbGxcIlxuICB9LCBmaWVsZC5kaXNwbGF5TW9kZSA9PT0gJ3RleHRhcmVhJyA/IGNvcmUuanN4KGZpZWxkcy5UZXh0QXJlYSwge1xuICAgIGlkOiBmaWVsZC5wYXRoLFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIG9uQ2hhbmdlOiBldmVudCA9PiBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgIGlubmVyOiB7XG4gICAgICAgIGtpbmQ6ICd2YWx1ZScsXG4gICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9KSksXG4gICAgdmFsdWU6IHZhbHVlLmlubmVyLmtpbmQgPT09ICdudWxsJyA/ICcnIDogdmFsdWUuaW5uZXIudmFsdWUsXG4gICAgZGlzYWJsZWQ6IHZhbHVlLmlubmVyLmtpbmQgPT09ICdudWxsJyxcbiAgICBvbkJsdXI6ICgpID0+IHtcbiAgICAgIHNldFNob3VsZFNob3dFcnJvcnModHJ1ZSk7XG4gICAgfVxuICB9KSA6IGNvcmUuanN4KGZpZWxkcy5UZXh0SW5wdXQsIHtcbiAgICBpZDogZmllbGQucGF0aCxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBvbkNoYW5nZTogZXZlbnQgPT4gb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICBpbm5lcjoge1xuICAgICAgICBraW5kOiAndmFsdWUnLFxuICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfSkpLFxuICAgIHZhbHVlOiB2YWx1ZS5pbm5lci5raW5kID09PSAnbnVsbCcgPyAnJyA6IHZhbHVlLmlubmVyLnZhbHVlLFxuICAgIGRpc2FibGVkOiB2YWx1ZS5pbm5lci5raW5kID09PSAnbnVsbCcsXG4gICAgb25CbHVyOiAoKSA9PiB7XG4gICAgICBzZXRTaG91bGRTaG93RXJyb3JzKHRydWUpO1xuICAgIH1cbiAgfSksIGZpZWxkLmlzTnVsbGFibGUgJiYgY29yZS5qc3goZmllbGRzLkNoZWNrYm94LCB7XG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgZGlzYWJsZWQ6IG9uQ2hhbmdlID09PSB1bmRlZmluZWQsXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIGlmICh2YWx1ZS5pbm5lci5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgIG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICBraW5kOiAnbnVsbCcsXG4gICAgICAgICAgICBwcmV2OiB2YWx1ZS5pbm5lci52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgICAgaW5uZXI6IHtcbiAgICAgICAgICAgIGtpbmQ6ICd2YWx1ZScsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUuaW5uZXIucHJldlxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2hlY2tlZDogdmFsdWUuaW5uZXIua2luZCA9PT0gJ251bGwnXG4gIH0sIGNvcmUuanN4KFwic3BhblwiLCB7XG4gICAgY3NzOiB7XG4gICAgICBmb250V2VpZ2h0OiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHQuc2VtaWJvbGQsXG4gICAgICBjb2xvcjogZmllbGRzJDEubGFiZWxDb2xvclxuICAgIH1cbiAgfSwgXCJTZXQgZmllbGQgYXMgbnVsbFwiKSksICEhdmFsaWRhdGlvbk1lc3NhZ2VzLmxlbmd0aCAmJiAoc2hvdWxkU2hvd0Vycm9ycyB8fCBmb3JjZVZhbGlkYXRpb24pICYmIHZhbGlkYXRpb25NZXNzYWdlcy5tYXAoKG1lc3NhZ2UsIGkpID0+IGNvcmUuanN4KFwic3BhblwiLCB7XG4gICAga2V5OiBpLFxuICAgIGNzczoge1xuICAgICAgY29sb3I6ICdyZWQnXG4gICAgfVxuICB9LCBtZXNzYWdlKSkpIDogdmFsdWUuaW5uZXIua2luZCA9PT0gJ251bGwnID8gbnVsbCA6IHZhbHVlLmlubmVyLnZhbHVlKTtcbn07XG5jb25zdCBDZWxsID0gKHtcbiAgaXRlbSxcbiAgZmllbGQsXG4gIGxpbmtUb1xufSkgPT4ge1xuICBsZXQgdmFsdWUgPSBpdGVtW2ZpZWxkLnBhdGhdICsgJyc7XG4gIHJldHVybiBsaW5rVG8gPyBjb3JlLmpzeChDZWxsTGluay5DZWxsTGluaywgbGlua1RvLCB2YWx1ZSkgOiBjb3JlLmpzeChDZWxsQ29udGFpbmVyLkNlbGxDb250YWluZXIsIG51bGwsIHZhbHVlKTtcbn07XG5DZWxsLnN1cHBvcnRzTGlua1RvID0gdHJ1ZTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGl0ZW1bZmllbGQucGF0aF0pO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHZhbGlkYXRpb24sIGZpZWxkTGFiZWwpIHtcbiAgLy8gaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBpbml0aWFsIGZvciBhbiB1cGRhdGUsIHdlIGRvbid0IHdhbnQgdG8gYmxvY2sgc2F2aW5nXG4gIC8vIHNpbmNlIHdlJ3JlIG5vdCBnb25uYSBzZW5kIGl0IGFueXdheSBpZiBpdCdzIHRoZSBzYW1lXG4gIC8vIGFuZCBnb2luZyBcImZpeCB0aGlzIHRoaW5nIHRoYXQgaXMgdW5yZWxhdGVkIHRvIHRoZSB0aGluZyB5b3UncmUgZG9pbmdcIiBpcyBiYWRcbiAgLy8gYW5kIGFsc28gYmMgaXQgY291bGQgYmUgbnVsbCBiYyBvZiByZWFkIGFjY2VzcyBjb250cm9sXG4gIGlmICh2YWx1ZS5raW5kID09PSAndXBkYXRlJyAmJiAodmFsdWUuaW5pdGlhbC5raW5kID09PSAnbnVsbCcgJiYgdmFsdWUuaW5uZXIua2luZCA9PT0gJ251bGwnIHx8IHZhbHVlLmluaXRpYWwua2luZCA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZS5pbm5lci5raW5kID09PSAndmFsdWUnICYmIHZhbHVlLmlubmVyLnZhbHVlID09PSB2YWx1ZS5pbml0aWFsLnZhbHVlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbm5lci5raW5kID09PSAnbnVsbCcpIHtcbiAgICBpZiAodmFsaWRhdGlvbi5pc1JlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gW2Ake2ZpZWxkTGFiZWx9IGlzIHJlcXVpcmVkYF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgdmFsID0gdmFsdWUuaW5uZXIudmFsdWU7XG4gIGxldCBtZXNzYWdlcyA9IFtdO1xuXG4gIGlmICh2YWxpZGF0aW9uLmxlbmd0aC5taW4gIT09IG51bGwgJiYgdmFsLmxlbmd0aCA8IHZhbGlkYXRpb24ubGVuZ3RoLm1pbikge1xuICAgIGlmICh2YWxpZGF0aW9uLmxlbmd0aC5taW4gPT09IDEpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgYmUgZW1wdHlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZXMucHVzaChgJHtmaWVsZExhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7dmFsaWRhdGlvbi5sZW5ndGgubWlufSBjaGFyYWN0ZXJzIGxvbmdgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWRhdGlvbi5sZW5ndGgubWF4ICE9PSBudWxsICYmIHZhbC5sZW5ndGggPiB2YWxpZGF0aW9uLmxlbmd0aC5tYXgpIHtcbiAgICBtZXNzYWdlcy5wdXNoKGAke2ZpZWxkTGFiZWx9IG11c3QgYmUgbm8gbG9uZ2VyIHRoYW4gJHt2YWxpZGF0aW9uLmxlbmd0aC5taW59IGNoYXJhY3RlcnNgKTtcbiAgfVxuXG4gIGlmICh2YWxpZGF0aW9uLm1hdGNoICYmICF2YWxpZGF0aW9uLm1hdGNoLnJlZ2V4LnRlc3QodmFsKSkge1xuICAgIG1lc3NhZ2VzLnB1c2godmFsaWRhdGlvbi5tYXRjaC5leHBsYW5hdGlvbiB8fCBgJHtmaWVsZExhYmVsfSBtdXN0IG1hdGNoICR7dmFsaWRhdGlvbi5tYXRjaC5yZWdleH1gKTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlcztcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVUZXh0VmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdudWxsJyxcbiAgICAgIHByZXY6ICcnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2luZDogJ3ZhbHVlJyxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5jb25zdCBjb250cm9sbGVyID0gY29uZmlnID0+IHtcbiAgY29uc3QgdmFsaWRhdGlvbiA9IHtcbiAgICBpc1JlcXVpcmVkOiBjb25maWcuZmllbGRNZXRhLnZhbGlkYXRpb24uaXNSZXF1aXJlZCxcbiAgICBsZW5ndGg6IGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5sZW5ndGgsXG4gICAgbWF0Y2g6IGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5tYXRjaCA/IHtcbiAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5tYXRjaC5yZWdleC5zb3VyY2UsIGNvbmZpZy5maWVsZE1ldGEudmFsaWRhdGlvbi5tYXRjaC5yZWdleC5mbGFncyksXG4gICAgICBleHBsYW5hdGlvbjogY29uZmlnLmZpZWxkTWV0YS52YWxpZGF0aW9uLm1hdGNoLmV4cGxhbmF0aW9uXG4gICAgfSA6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBjb25maWcucGF0aCxcbiAgICBsYWJlbDogY29uZmlnLmxhYmVsLFxuICAgIGdyYXBocWxTZWxlY3Rpb246IGNvbmZpZy5wYXRoLFxuICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICBpbm5lcjogZGVzZXJpYWxpemVUZXh0VmFsdWUoY29uZmlnLmZpZWxkTWV0YS5kZWZhdWx0VmFsdWUpXG4gICAgfSxcbiAgICBkaXNwbGF5TW9kZTogY29uZmlnLmZpZWxkTWV0YS5kaXNwbGF5TW9kZSxcbiAgICBpc051bGxhYmxlOiBjb25maWcuZmllbGRNZXRhLmlzTnVsbGFibGUsXG4gICAgZGVzZXJpYWxpemU6IGRhdGEgPT4ge1xuICAgICAgY29uc3QgaW5uZXIgPSBkZXNlcmlhbGl6ZVRleHRWYWx1ZShkYXRhW2NvbmZpZy5wYXRoXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAndXBkYXRlJyxcbiAgICAgICAgaW5uZXIsXG4gICAgICAgIGluaXRpYWw6IGlubmVyXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiB2YWx1ZSA9PiAoe1xuICAgICAgW2NvbmZpZy5wYXRoXTogdmFsdWUuaW5uZXIua2luZCA9PT0gJ251bGwnID8gbnVsbCA6IHZhbHVlLmlubmVyLnZhbHVlXG4gICAgfSksXG4gICAgdmFsaWRhdGlvbixcbiAgICB2YWxpZGF0ZTogdmFsID0+IHZhbGlkYXRlKHZhbCwgdmFsaWRhdGlvbiwgY29uZmlnLmxhYmVsKS5sZW5ndGggPT09IDAsXG4gICAgZmlsdGVyOiB7XG4gICAgICBGaWx0ZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUuanN4KGZpZWxkcy5UZXh0SW5wdXQsIHtcbiAgICAgICAgICBvbkNoYW5nZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICAgICAgICBhdXRvRm9jdXM6IHByb3BzLmF1dG9Gb2N1c1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGdyYXBocWw6ICh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTm90ID0gdHlwZS5zdGFydHNXaXRoKCdub3RfJyk7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGUgPT09ICdpc19pJyB8fCB0eXBlID09PSAnbm90X2knID8gJ2VxdWFscycgOiB0eXBlLnJlcGxhY2UoL19pJC8sICcnKS5yZXBsYWNlKCdub3RfJywgJycpLnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2NvbmZpZy5wYXRoXTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpc05vdCA/IHtcbiAgICAgICAgICAgIG5vdDogZmlsdGVyXG4gICAgICAgICAgfSA6IGZpbHRlciksIHt9LCB7XG4gICAgICAgICAgICBtb2RlOiBjb25maWcuZmllbGRNZXRhLnNob3VsZFVzZU1vZGVJbnNlbnNpdGl2ZSA/ICdpbnNlbnNpdGl2ZScgOiB1bmRlZmluZWRcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgTGFiZWwoe1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke2xhYmVsLnRvTG93ZXJDYXNlKCl9OiBcIiR7dmFsdWV9XCJgO1xuICAgICAgfSxcblxuICAgICAgdHlwZXM6IHtcbiAgICAgICAgY29udGFpbnNfaToge1xuICAgICAgICAgIGxhYmVsOiAnQ29udGFpbnMnLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgbm90X2NvbnRhaW5zX2k6IHtcbiAgICAgICAgICBsYWJlbDogJ0RvZXMgbm90IGNvbnRhaW4nLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgaXNfaToge1xuICAgICAgICAgIGxhYmVsOiAnSXMgZXhhY3RseScsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBub3RfaToge1xuICAgICAgICAgIGxhYmVsOiAnSXMgbm90IGV4YWN0bHknLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRzX3dpdGhfaToge1xuICAgICAgICAgIGxhYmVsOiAnU3RhcnRzIHdpdGgnLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgbm90X3N0YXJ0c193aXRoX2k6IHtcbiAgICAgICAgICBsYWJlbDogJ0RvZXMgbm90IHN0YXJ0IHdpdGgnLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZTogJydcbiAgICAgICAgfSxcbiAgICAgICAgZW5kc193aXRoX2k6IHtcbiAgICAgICAgICBsYWJlbDogJ0VuZHMgd2l0aCcsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBub3RfZW5kc193aXRoX2k6IHtcbiAgICAgICAgICBsYWJlbDogJ0RvZXMgbm90IGVuZCB3aXRoJyxcbiAgICAgICAgICBpbml0aWFsVmFsdWU6ICcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLkNhcmRWYWx1ZSA9IENhcmRWYWx1ZTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtdGV4dC12aWV3cy5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtdGV4dC12aWV3cy5janMuZGV2LmpzXCIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcbnZhciBfb2JqZWN0U3ByZWFkID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAa2V5c3RvbmUtdWkvY29yZScpO1xudmFyIGZpZWxkcyA9IHJlcXVpcmUoJ0BrZXlzdG9uZS11aS9maWVsZHMnKTtcbnZhciBDZWxsQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vZGlzdC9DZWxsQ29udGFpbmVyLTQ1MzI1NGI1LmNqcy5kZXYuanMnKTtcbnZhciBDZWxsTGluayA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2Rpc3QvQ2VsbExpbmstZGM0MWM4NzcuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2J1dHRvbicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsZXJ0VHJpYW5nbGVJY29uJyk7XG5yZXF1aXJlKCduZXh0L2xpbmsnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS90b2FzdCcpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL2xvYWRpbmcnKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9tb2RhbHMnKTtcbnJlcXVpcmUoJ2Fwb2xsby11cGxvYWQtY2xpZW50Jyk7XG5yZXF1aXJlKCdAZW1vdGlvbi9oYXNoJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L3NxbGl0ZS1hZjllNTE0OC5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L2dyYXBocWwtdHMtc2NoZW1hLWZjZTdhNmE4LmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ0BhcG9sbG8vY2xpZW50Jyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L2FkbWluLW1ldGEtZ3JhcGhxbC05ZjlhOWMxMS5janMuZGV2LmpzJyk7XG5yZXF1aXJlKCduZXh0L3JvdXRlcicpO1xucmVxdWlyZSgnQGtleXN0b25lLXVpL3BvcG92ZXInKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Nb3JlSG9yaXpvbnRhbEljb24nKTtcbnJlcXVpcmUoJ0BrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uUmlnaHRJY29uJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L1NpZ25vdXRCdXR0b24tYWNkYjE1NTQuY2pzLmRldi5qcycpO1xucmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG5yZXF1aXJlKCdAa2V5c3RvbmUtdWkvbm90aWNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi9kaXN0L3V0aWxzLWVmZjFmZDMwLmNqcy5kZXYuanMnKTtcbnZhciBkYXRlRm5zID0gcmVxdWlyZSgnZGF0ZS1mbnMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2FkbWluLXVpL3JvdXRlci9kaXN0L2tleXN0b25lLW5leHQta2V5c3RvbmUtYWRtaW4tdWktcm91dGVyLmNqcy5kZXYuanMnKTtcbnJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRvb2xzL3NjaGVtYScpO1xucmVxdWlyZSgnQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRob3V0LWNvbnRleHQnKTtcbnJlcXVpcmUoJ0BncmFwaHFsLXRzL3NjaGVtYScpO1xucmVxdWlyZSgnZ3JhcGhxbC10eXBlLWpzb24nKTtcbnJlcXVpcmUoJ2dyYXBocWwtdXBsb2FkL3B1YmxpYy9HcmFwaFFMVXBsb2FkLmpzJyk7XG5yZXF1aXJlKCdncmFwaHFsJyk7XG5yZXF1aXJlKCdAZ3JhcGhxbC10cy9zY2hlbWEvYXBpLXdpdGgtY29udGV4dCcpO1xuXG5jb25zdCBGVUxMX1RJTUVfUEFUVEVSTiA9ICdISDptbTpzcy5TU1MnO1xuXG5mdW5jdGlvbiBmb3JtYXRGdWxsVGltZShkYXRlKSB7XG4gIHJldHVybiBkYXRlRm5zLmZvcm1hdChkYXRlLCBGVUxMX1RJTUVfUEFUVEVSTik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSkge1xuICBjb25zdCBkYXRlID0gZGF0ZUZucy5wYXJzZSh0aW1lLCBGVUxMX1RJTUVfUEFUVEVSTiwgbmV3IERhdGUoKSk7XG5cbiAgaWYgKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgIT09IDApIHtcbiAgICByZXR1cm4gZGF0ZUZucy5mb3JtYXQoZGF0ZSwgRlVMTF9USU1FX1BBVFRFUk4pO1xuICB9XG5cbiAgaWYgKGRhdGUuZ2V0U2Vjb25kcygpICE9PSAwKSB7XG4gICAgcmV0dXJuIGRhdGVGbnMuZm9ybWF0KGRhdGUsICdISDptbTpzcycpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGVGbnMuZm9ybWF0KGRhdGUsICdISDptbScpO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWUpIHtcbiAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIFsnSDptOnMuU1NTJywgJ0g6bTpzJywgJ0g6bScsICdIJ10pIHtcbiAgICBjb25zdCBwYXJzZWQgPSBkYXRlRm5zLnBhcnNlKHRpbWUsIHBhdHRlcm4sIG5ldyBEYXRlKCkpO1xuXG4gICAgaWYgKGRhdGVGbnMuaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgICByZXR1cm4gZGF0ZUZucy5mb3JtYXQocGFyc2VkLCBGVUxMX1RJTUVfUEFUVEVSTik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFRpbWVzdGFtcCh7XG4gIGRhdGVWYWx1ZSxcbiAgdGltZVZhbHVlXG59KSB7XG4gIHJldHVybiBuZXcgRGF0ZShgJHtkYXRlVmFsdWV9VCR7dGltZVZhbHVlfWApLnRvSVNPU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBkZWNvbnN0cnVjdFRpbWVzdGFtcCh2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGRhdGVWYWx1ZTogZGF0ZUZucy5mb3JtYXRJU08obmV3IERhdGUodmFsdWUpLCB7XG4gICAgICByZXByZXNlbnRhdGlvbjogJ2RhdGUnXG4gICAgfSksXG4gICAgdGltZVZhbHVlOiB7XG4gICAgICBraW5kOiAncGFyc2VkJyxcbiAgICAgIHZhbHVlOiBmb3JtYXRGdWxsVGltZShuZXcgRGF0ZSh2YWx1ZSkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0T3V0cHV0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiAnJztcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoKTtcbn1cblxuY29uc3QgRmllbGQgPSAoe1xuICBmaWVsZCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBmb3JjZVZhbGlkYXRpb25cbn0pID0+IHtcbiAgdmFyIF92YWx1ZSR2YWx1ZSRkYXRlVmFsdSwgX2ZpZWxkJGZpZWxkTWV0YSRkZWZhO1xuXG4gIGNvbnN0IFt0b3VjaGVkRmlyc3RJbnB1dCwgc2V0VG91Y2hlZEZpcnN0SW5wdXRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdG91Y2hlZFNlY29uZElucHV0LCBzZXRUb3VjaGVkU2Vjb25kSW5wdXRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBzaG93VmFsaWRhdGlvbiA9IHRvdWNoZWRGaXJzdElucHV0ICYmIHRvdWNoZWRTZWNvbmRJbnB1dCB8fCBmb3JjZVZhbGlkYXRpb247XG4gIGNvbnN0IHZhbGlkYXRpb25NZXNzYWdlcyA9IHNob3dWYWxpZGF0aW9uID8gdmFsaWRhdGUodmFsdWUsIGZpZWxkLmZpZWxkTWV0YSwgZmllbGQubGFiZWwpIDogdW5kZWZpbmVkO1xuICBjb25zdCB0aW1lSW5wdXRQcm9wcyA9IHV0aWxzLnVzZUZvcm1hdHRlZElucHV0KHtcbiAgICBmb3JtYXQoe1xuICAgICAgdmFsdWVcbiAgICB9KSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0VGltZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcblxuICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6ICdwYXJzZWQnLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVGltZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChwYXJzZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6ICdwYXJzZWQnLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZWRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICB9LCB7XG4gICAgdmFsdWU6IHZhbHVlLnZhbHVlLnRpbWVWYWx1ZSxcblxuICAgIG9uQ2hhbmdlKHRpbWVWYWx1ZSkge1xuICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmFsdWUpLCB7fSwge1xuICAgICAgICB2YWx1ZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZS52YWx1ZSksIHt9LCB7XG4gICAgICAgICAgdGltZVZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uQmx1cigpIHtcbiAgICAgIHNldFRvdWNoZWRTZWNvbmRJbnB1dCh0cnVlKTtcbiAgICB9XG5cbiAgfSk7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIHtcbiAgICBhczogXCJmaWVsZHNldFwiXG4gIH0sIGNvcmUuanN4KGNvcmUuU3RhY2ssIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCB7XG4gICAgYXM6IFwibGVnZW5kXCJcbiAgfSwgZmllbGQubGFiZWwpLCBvbkNoYW5nZSA/IGNvcmUuanN4KGNvcmUuSW5saW5lLCB7XG4gICAgZ2FwOiBcInNtYWxsXCJcbiAgfSwgY29yZS5qc3goY29yZS5TdGFjaywgbnVsbCwgY29yZS5qc3goZmllbGRzLkRhdGVQaWNrZXIsIHtcbiAgICBvblVwZGF0ZTogZGF0ZSA9PiB7XG4gICAgICBvbkNoYW5nZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBkYXRlVmFsdWU6IGRhdGUsXG4gICAgICAgICAgdGltZVZhbHVlOiB0eXBlb2YgdmFsdWUudmFsdWUudGltZVZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS52YWx1ZS50aW1lVmFsdWUudmFsdWUgPT09IG51bGwgPyB7XG4gICAgICAgICAgICBraW5kOiAncGFyc2VkJyxcbiAgICAgICAgICAgIHZhbHVlOiAnMDA6MDA6MDAuMDAwJ1xuICAgICAgICAgIH0gOiB2YWx1ZS52YWx1ZS50aW1lVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgb25DbGVhcjogKCkgPT4ge1xuICAgICAgb25DaGFuZ2UoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbHVlLnZhbHVlKSwge30sIHtcbiAgICAgICAgICBkYXRlVmFsdWU6IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIG9uQmx1cjogKCkgPT4gc2V0VG91Y2hlZEZpcnN0SW5wdXQodHJ1ZSksXG4gICAgdmFsdWU6IChfdmFsdWUkdmFsdWUkZGF0ZVZhbHUgPSB2YWx1ZS52YWx1ZS5kYXRlVmFsdWUpICE9PSBudWxsICYmIF92YWx1ZSR2YWx1ZSRkYXRlVmFsdSAhPT0gdm9pZCAwID8gX3ZhbHVlJHZhbHVlJGRhdGVWYWx1IDogJydcbiAgfSksICh2YWxpZGF0aW9uTWVzc2FnZXMgPT09IG51bGwgfHwgdmFsaWRhdGlvbk1lc3NhZ2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZGF0aW9uTWVzc2FnZXMuZGF0ZSkgJiYgY29yZS5qc3goY29yZS5UZXh0LCB7XG4gICAgY29sb3I6IFwicmVkNjAwXCIsXG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0sIHZhbGlkYXRpb25NZXNzYWdlcy5kYXRlKSksIGNvcmUuanN4KGNvcmUuU3RhY2ssIG51bGwsIGNvcmUuanN4KGNvcmUuVmlzdWFsbHlIaWRkZW4sIHtcbiAgICBhczogXCJsYWJlbFwiLFxuICAgIGh0bWxGb3I6IGAke2ZpZWxkLnBhdGh9LS10aW1lLWlucHV0YFxuICB9LCBgJHtmaWVsZC5sYWJlbH0gdGltZSBmaWVsZGApLCBjb3JlLmpzeChmaWVsZHMuVGV4dElucHV0LCBfZXh0ZW5kcyh7XG4gICAgaWQ6IGAke2ZpZWxkLnBhdGh9LS10aW1lLWlucHV0YFxuICB9LCB0aW1lSW5wdXRQcm9wcywge1xuICAgIGRpc2FibGVkOiBvbkNoYW5nZSA9PT0gdW5kZWZpbmVkLFxuICAgIHBsYWNlaG9sZGVyOiBcIjAwOjAwXCJcbiAgfSkpLCAodmFsaWRhdGlvbk1lc3NhZ2VzID09PSBudWxsIHx8IHZhbGlkYXRpb25NZXNzYWdlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbk1lc3NhZ2VzLnRpbWUpICYmIGNvcmUuanN4KGNvcmUuVGV4dCwge1xuICAgIGNvbG9yOiBcInJlZDYwMFwiLFxuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCB2YWxpZGF0aW9uTWVzc2FnZXMudGltZSkpKSA6IHZhbHVlLnZhbHVlLmRhdGVWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudmFsdWUudGltZVZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS52YWx1ZS50aW1lVmFsdWUudmFsdWUgIT09IG51bGwgJiYgY29yZS5qc3goY29yZS5UZXh0LCBudWxsLCBmb3JtYXRPdXRwdXQoY29uc3RydWN0VGltZXN0YW1wKHtcbiAgICBkYXRlVmFsdWU6IHZhbHVlLnZhbHVlLmRhdGVWYWx1ZSxcbiAgICB0aW1lVmFsdWU6IHZhbHVlLnZhbHVlLnRpbWVWYWx1ZS52YWx1ZVxuICB9KSkpLCAodmFsdWUua2luZCA9PT0gJ2NyZWF0ZScgJiYgdHlwZW9mIGZpZWxkLmZpZWxkTWV0YS5kZWZhdWx0VmFsdWUgIT09ICdzdHJpbmcnICYmICgoX2ZpZWxkJGZpZWxkTWV0YSRkZWZhID0gZmllbGQuZmllbGRNZXRhLmRlZmF1bHRWYWx1ZSkgPT09IG51bGwgfHwgX2ZpZWxkJGZpZWxkTWV0YSRkZWZhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZmllbGQkZmllbGRNZXRhJGRlZmEua2luZCkgPT09ICdub3cnIHx8IGZpZWxkLmZpZWxkTWV0YS51cGRhdGVkQXQpICYmIGNvcmUuanN4KGNvcmUuVGV4dCwgbnVsbCwgXCJXaGVuIHRoaXMgaXRlbSBpcyBzYXZlZCwgdGhpcyBmaWVsZCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lXCIpKSk7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgZmllbGRNZXRhLCBsYWJlbCkge1xuICB2YXIgX2ZpZWxkTWV0YSRkZWZhdWx0VmFsO1xuXG4gIGNvbnN0IHZhbCA9IHZhbHVlLnZhbHVlO1xuICBjb25zdCBoYXNEYXRlVmFsdWUgPSB2YWwuZGF0ZVZhbHVlICE9PSBudWxsO1xuICBjb25zdCBoYXNUaW1lVmFsdWUgPSB0eXBlb2YgdmFsLnRpbWVWYWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbC50aW1lVmFsdWUudmFsdWUgPT09ICdzdHJpbmcnO1xuICBjb25zdCBpc1ZhbHVlRW1wdHkgPSAhaGFzRGF0ZVZhbHVlICYmICFoYXNUaW1lVmFsdWU7IC8vIGlmIHdlIHJlY2lldmUgbnVsbCBpbml0aWFsbHkgb24gdGhlIGl0ZW0gdmlldyBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgbnVsbCxcbiAgLy8gd2Ugc2hvdWxkIGFsd2F5cyBhbGxvdyBzYXZpbmcgaXQgYmVjYXVzZTpcbiAgLy8gLSB0aGUgdmFsdWUgbWlnaHQgYmUgbnVsbCBpbiB0aGUgZGF0YWJhc2UgYW5kIHdlIGRvbid0IHdhbnQgdG8gcHJldmVudCBzYXZpbmcgdGhlIHdob2xlIGl0ZW0gYmVjYXVzZSBvZiB0aGF0XG4gIC8vIC0gd2UgbWlnaHQgaGF2ZSBudWxsIGJlY2F1c2Ugb2YgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3JcblxuICBpZiAodmFsdWUua2luZCA9PT0gJ3VwZGF0ZScgJiYgdmFsdWUuaW5pdGlhbCA9PT0gbnVsbCAmJiBpc1ZhbHVlRW1wdHkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHZhbHVlLmtpbmQgPT09ICdjcmVhdGUnICYmIGlzVmFsdWVFbXB0eSAmJiAodHlwZW9mIGZpZWxkTWV0YS5kZWZhdWx0VmFsdWUgPT09ICdvYmplY3QnICYmICgoX2ZpZWxkTWV0YSRkZWZhdWx0VmFsID0gZmllbGRNZXRhLmRlZmF1bHRWYWx1ZSkgPT09IG51bGwgfHwgX2ZpZWxkTWV0YSRkZWZhdWx0VmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZmllbGRNZXRhJGRlZmF1bHRWYWwua2luZCkgPT09ICdub3cnIHx8IGZpZWxkTWV0YS51cGRhdGVkQXQpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChmaWVsZE1ldGEuaXNSZXF1aXJlZCAmJiBpc1ZhbHVlRW1wdHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogYCR7bGFiZWx9IGlzIHJlcXVpcmVkYFxuICAgIH07XG4gIH1cblxuICBpZiAoaGFzRGF0ZVZhbHVlICYmICFoYXNUaW1lVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZTogYCR7bGFiZWx9IHJlcXVpcmVzIGEgdGltZSB0byBiZSBwcm92aWRlZGBcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdGltZUVycm9yID0gdHlwZW9mIHZhbC50aW1lVmFsdWUgPT09ICdzdHJpbmcnID8gYCR7bGFiZWx9IHJlcXVpcmVzIGEgdmFsaWQgdGltZSBpbiB0aGUgZm9ybWF0IGhoOm1tYCA6IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzVGltZVZhbHVlICYmICFoYXNEYXRlVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogYCR7bGFiZWx9IHJlcXVpcmVzIGEgZGF0ZSB0byBiZSBzZWxlY3RlZGAsXG4gICAgICB0aW1lOiB0aW1lRXJyb3JcbiAgICB9O1xuICB9XG5cbiAgaWYgKHRpbWVFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lOiB0aW1lRXJyb3JcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgQ2VsbCA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkLFxuICBsaW5rVG9cbn0pID0+IHtcbiAgbGV0IHZhbHVlID0gaXRlbVtmaWVsZC5wYXRoXTtcbiAgcmV0dXJuIGxpbmtUbyA/IGNvcmUuanN4KENlbGxMaW5rLkNlbGxMaW5rLCBsaW5rVG8sIGZvcm1hdE91dHB1dCh2YWx1ZSkpIDogY29yZS5qc3goQ2VsbENvbnRhaW5lci5DZWxsQ29udGFpbmVyLCBudWxsLCBmb3JtYXRPdXRwdXQodmFsdWUpKTtcbn07XG5DZWxsLnN1cHBvcnRzTGlua1RvID0gdHJ1ZTtcbmNvbnN0IENhcmRWYWx1ZSA9ICh7XG4gIGl0ZW0sXG4gIGZpZWxkXG59KSA9PiB7XG4gIHJldHVybiBjb3JlLmpzeChmaWVsZHMuRmllbGRDb250YWluZXIsIG51bGwsIGNvcmUuanN4KGZpZWxkcy5GaWVsZExhYmVsLCBudWxsLCBmaWVsZC5sYWJlbCksIGZvcm1hdE91dHB1dChpdGVtW2ZpZWxkLnBhdGhdKSk7XG59O1xuY29uc3QgY29udHJvbGxlciA9IGNvbmZpZyA9PiB7XG4gIHJldHVybiB7XG4gICAgcGF0aDogY29uZmlnLnBhdGgsXG4gICAgbGFiZWw6IGNvbmZpZy5sYWJlbCxcbiAgICBncmFwaHFsU2VsZWN0aW9uOiBjb25maWcucGF0aCxcbiAgICBmaWVsZE1ldGE6IGNvbmZpZy5maWVsZE1ldGEsXG4gICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgIHZhbHVlOiB0eXBlb2YgY29uZmlnLmZpZWxkTWV0YS5kZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnID8gZGVjb25zdHJ1Y3RUaW1lc3RhbXAoY29uZmlnLmZpZWxkTWV0YS5kZWZhdWx0VmFsdWUpIDoge1xuICAgICAgICBkYXRlVmFsdWU6IG51bGwsXG4gICAgICAgIHRpbWVWYWx1ZToge1xuICAgICAgICAgIGtpbmQ6ICdwYXJzZWQnLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc2VyaWFsaXplOiBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtjb25maWcucGF0aF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAndXBkYXRlJyxcbiAgICAgICAgaW5pdGlhbDogZGF0YVtjb25maWcucGF0aF0sXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/IGRlY29uc3RydWN0VGltZXN0YW1wKHZhbHVlKSA6IHtcbiAgICAgICAgICBkYXRlVmFsdWU6IG51bGwsXG4gICAgICAgICAgdGltZVZhbHVlOiB7XG4gICAgICAgICAgICBraW5kOiAncGFyc2VkJyxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiAoe1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZGF0ZVZhbHVlLFxuICAgICAgICB0aW1lVmFsdWVcbiAgICAgIH1cbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZGF0ZVZhbHVlICYmIHR5cGVvZiB0aW1lVmFsdWUgPT09ICdvYmplY3QnICYmIHRpbWVWYWx1ZS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkRGF0ZSA9IGNvbnN0cnVjdFRpbWVzdGFtcCh7XG4gICAgICAgICAgZGF0ZVZhbHVlLFxuICAgICAgICAgIHRpbWVWYWx1ZTogdGltZVZhbHVlLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFtjb25maWcucGF0aF06IGZvcm1hdHRlZERhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2NvbmZpZy5wYXRoXTogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiB2YWxpZGF0ZSh2YWx1ZSwgY29uZmlnLmZpZWxkTWV0YSwgY29uZmlnLmxhYmVsKSA9PT0gdW5kZWZpbmVkXG4gIH07XG59O1xuXG5leHBvcnRzLkNhcmRWYWx1ZSA9IENhcmRWYWx1ZTtcbmV4cG9ydHMuQ2VsbCA9IENlbGw7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2V5c3RvbmUtbmV4dC1rZXlzdG9uZS1maWVsZHMtdHlwZXMtdGltZXN0YW1wLXZpZXdzLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZXlzdG9uZS1uZXh0LWtleXN0b25lLWZpZWxkcy10eXBlcy10aW1lc3RhbXAtdmlld3MuY2pzLmRldi5qc1wiKTtcbn1cbiIsImltcG9ydCB7IGdldEFwcCB9IGZyb20gJ0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL19fX2ludGVybmFsLWRvLW5vdC11c2Utd2lsbC1icmVhay1pbi1wYXRjaC9hZG1pbi11aS9wYWdlcy9BcHAnO1xuXG5pbXBvcnQgKiBhcyB2aWV3MCBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL19fX2ludGVybmFsLWRvLW5vdC11c2Utd2lsbC1icmVhay1pbi1wYXRjaC9hZG1pbi11aS9pZC1maWVsZC12aWV3XCI7XG5pbXBvcnQgKiBhcyB2aWV3MSBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy90ZXh0L3ZpZXdzXCI7XG5pbXBvcnQgKiBhcyB2aWV3MiBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9jaGVja2JveC92aWV3c1wiO1xuaW1wb3J0ICogYXMgdmlldzMgZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9maWVsZHMvdHlwZXMvcGFzc3dvcmQvdmlld3NcIjtcbmltcG9ydCAqIGFzIHZpZXc0IGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL2ltYWdlL3ZpZXdzXCI7XG5pbXBvcnQgKiBhcyB2aWV3NSBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy90aW1lc3RhbXAvdmlld3NcIjtcbmltcG9ydCAqIGFzIHZpZXc2IGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3JlbGF0aW9uc2hpcC92aWV3c1wiO1xuaW1wb3J0ICogYXMgdmlldzcgZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2V5c3RvbmUtbmV4dC9maWVsZHMtZG9jdW1lbnQvdmlld3NcIjtcbmltcG9ydCAqIGFzIHZpZXc4IGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL2pzb24vdmlld3NcIjtcbmltcG9ydCAqIGFzIHZpZXc5IGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGtleXN0b25lLW5leHQva2V5c3RvbmUvZmllbGRzL3R5cGVzL3NlbGVjdC92aWV3c1wiO1xuXG52YXIgYWRtaW5Db25maWcgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0QXBwKHtcbiAgbGF6eU1ldGFkYXRhUXVlcnk6IHtcImtpbmRcIjpcIkRvY3VtZW50XCIsXCJkZWZpbml0aW9uc1wiOlt7XCJraW5kXCI6XCJPcGVyYXRpb25EZWZpbml0aW9uXCIsXCJvcGVyYXRpb25cIjpcInF1ZXJ5XCIsXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwia2V5c3RvbmVcIixcImxvY1wiOntcInN0YXJ0XCI6MjIsXCJlbmRcIjozMH19LFwiYXJndW1lbnRzXCI6W10sXCJkaXJlY3RpdmVzXCI6W10sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiYWRtaW5NZXRhXCIsXCJsb2NcIjp7XCJzdGFydFwiOjM5LFwiZW5kXCI6NDh9fSxcImFyZ3VtZW50c1wiOltdLFwiZGlyZWN0aXZlc1wiOltdLFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImxpc3RzXCIsXCJsb2NcIjp7XCJzdGFydFwiOjU5LFwiZW5kXCI6NjR9fSxcImFyZ3VtZW50c1wiOltdLFwiZGlyZWN0aXZlc1wiOltdLFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImtleVwiLFwibG9jXCI6e1wic3RhcnRcIjo3NyxcImVuZFwiOjgwfX0sXCJhcmd1bWVudHNcIjpbXSxcImRpcmVjdGl2ZXNcIjpbXSxcImxvY1wiOntcInN0YXJ0XCI6NzcsXCJlbmRcIjo4MH19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImlzSGlkZGVuXCIsXCJsb2NcIjp7XCJzdGFydFwiOjkxLFwiZW5kXCI6OTl9fSxcImFyZ3VtZW50c1wiOltdLFwiZGlyZWN0aXZlc1wiOltdLFwibG9jXCI6e1wic3RhcnRcIjo5MSxcImVuZFwiOjk5fX0se1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiZmllbGRzXCIsXCJsb2NcIjp7XCJzdGFydFwiOjExMCxcImVuZFwiOjExNn19LFwiYXJndW1lbnRzXCI6W10sXCJkaXJlY3RpdmVzXCI6W10sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwicGF0aFwiLFwibG9jXCI6e1wic3RhcnRcIjoxMzEsXCJlbmRcIjoxMzV9fSxcImFyZ3VtZW50c1wiOltdLFwiZGlyZWN0aXZlc1wiOltdLFwibG9jXCI6e1wic3RhcnRcIjoxMzEsXCJlbmRcIjoxMzV9fSx7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJjcmVhdGVWaWV3XCIsXCJsb2NcIjp7XCJzdGFydFwiOjE0OCxcImVuZFwiOjE1OH19LFwiYXJndW1lbnRzXCI6W10sXCJkaXJlY3RpdmVzXCI6W10sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiZmllbGRNb2RlXCIsXCJsb2NcIjp7XCJzdGFydFwiOjE3NSxcImVuZFwiOjE4NH19LFwiYXJndW1lbnRzXCI6W10sXCJkaXJlY3RpdmVzXCI6W10sXCJsb2NcIjp7XCJzdGFydFwiOjE3NSxcImVuZFwiOjE4NH19XSxcImxvY1wiOntcInN0YXJ0XCI6MTU5LFwiZW5kXCI6MTk4fX0sXCJsb2NcIjp7XCJzdGFydFwiOjE0OCxcImVuZFwiOjE5OH19XSxcImxvY1wiOntcInN0YXJ0XCI6MTE3LFwiZW5kXCI6MjEwfX0sXCJsb2NcIjp7XCJzdGFydFwiOjExMCxcImVuZFwiOjIxMH19XSxcImxvY1wiOntcInN0YXJ0XCI6NjUsXCJlbmRcIjoyMjB9fSxcImxvY1wiOntcInN0YXJ0XCI6NTksXCJlbmRcIjoyMjB9fV0sXCJsb2NcIjp7XCJzdGFydFwiOjQ5LFwiZW5kXCI6MjI4fX0sXCJsb2NcIjp7XCJzdGFydFwiOjM5LFwiZW5kXCI6MjI4fX1dLFwibG9jXCI6e1wic3RhcnRcIjozMSxcImVuZFwiOjIzNH19LFwibG9jXCI6e1wic3RhcnRcIjoyMixcImVuZFwiOjIzNH19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImF1dGhlbnRpY2F0ZWRJdGVtXCJ9LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIklubGluZUZyYWdtZW50XCIsXCJ0eXBlQ29uZGl0aW9uXCI6e1wia2luZFwiOlwiTmFtZWRUeXBlXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcIlVzZXJcIn19LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImlkXCJ9fSx7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJuYW1lXCJ9fV19fV19fV19fV19LFxuICBmaWVsZFZpZXdzOiBbdmlldzAsdmlldzEsdmlldzIsdmlldzMsdmlldzQsdmlldzUsdmlldzYsdmlldzcsdmlldzgsdmlldzldLFxuICBhZG1pbk1ldGFIYXNoOiBcIjQzN3E5YlwiLFxuICBhZG1pbkNvbmZpZzogYWRtaW5Db25maWcsXG4gIGFwaVBhdGg6IFwiL2FwaS9ncmFwaHFsXCIsXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcm91dGVyID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlclwiKTtcbnZhciBfcm91dGVyMSA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbnZhciBfdXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmNvbnN0IHByZWZldGNoZWQgPSB7XG59O1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhcm91dGVyKSByZXR1cm47XG4gICAgaWYgKCEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuO1xuICAgIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gICAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY3VyTG9jYWxlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXQgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgYXZvaWQgc2Nyb2xsIGZvciB1cmxzIHdpdGggYW5jaG9yIHJlZnNcbiAgICBpZiAoc2Nyb2xsID09IG51bGwgJiYgYXMuaW5kZXhPZignIycpID49IDApIHtcbiAgICAgICAgc2Nyb2xsID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICAgIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShocmVmLCBhcywge1xuICAgICAgICBzaGFsbG93LFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHNjcm9sbFxuICAgIH0pO1xufVxuZnVuY3Rpb24gTGluayhwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBocmVmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFByb3BzR3VhcmQpO1xuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JlcGxhY2UnIHx8IGtleSA9PT0gJ3Njcm9sbCcgfHwga2V5ID09PSAnc2hhbGxvdycgfHwga2V5ID09PSAncGFzc0hyZWYnIHx8IGtleSA9PT0gJ3ByZWZldGNoJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCBfID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIGNvbnN0IGhhc1dhcm5lZCA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwID0gcHJvcHMucHJlZmV0Y2ggIT09IGZhbHNlO1xuICAgIGNvbnN0IHJvdXRlciA9ICgwLCBfcm91dGVyMSkudXNlUm91dGVyKCk7XG4gICAgY29uc3QgeyBocmVmICwgYXMgIH0gPSBfcmVhY3QuZGVmYXVsdC51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yb3V0ZXIpLnJlc29sdmVIcmVmKHJvdXRlciwgcHJvcHMuaHJlZiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBhczogcHJvcHMuYXMgPyAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBwcm9wcy5hcykgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBwcm9wcy5ocmVmLFxuICAgICAgICBwcm9wcy5hc1xuICAgIF0pO1xuICAgIGxldCB7IGNoaWxkcmVuICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgIH0gPSBwcm9wcztcbiAgICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke3Byb3BzLmhyZWZ9XFxgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlbmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUmVmID0gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWY7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlXSA9ICgwLCBfdXNlSW50ZXJzZWN0aW9uKS51c2VJbnRlcnNlY3Rpb24oe1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpO1xuICAgICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiAoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKTtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNQcmVmZXRjaGVkID0gcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXTtcbiAgICAgICAgaWYgKHNob3VsZFByZWZldGNoICYmICFpc1ByZWZldGNoZWQpIHtcbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcCxcbiAgICAgICAgcm91dGVyXG4gICAgXSk7XG4gICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICAgIG9uQ2xpY2s6IChlKT0+e1xuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGlsZFByb3BzLm9uTW91c2VFbnRlciA9IChlKT0+e1xuICAgICAgICBpZiAoISgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSByZXR1cm47XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgcHJpb3JpdHk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXJcbiAgICBpZiAocHJvcHMucGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkge1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSByb3V0ZXIgJiYgcm91dGVyLmlzTG9jYWxlRG9tYWluICYmICgwLCBfcm91dGVyKS5nZXREb21haW5Mb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5sb2NhbGVzLCByb3V0ZXIgJiYgcm91dGVyLmRvbWFpbkxvY2FsZXMpO1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9yb3V0ZXIpLmFkZEJhc2VQYXRoKCgwLCBfcm91dGVyKS5hZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcykpO1xufVxudmFyIF9kZWZhdWx0ID0gTGluaztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoO1xuZXhwb3J0cy5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn1cbmNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIID8gKHBhdGgpPT57XG4gICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJztcbiAgICB9XG59IDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2g7XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2g7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVxdWVzdElkbGVDYWxsYmFjayA9IGV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gdm9pZCAwO1xuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHtcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCAxKTtcbn07XG5leHBvcnRzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcbmV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gY2FuY2VsSWRsZUNhbGxiYWNrO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hcmtBc3NldEVycm9yID0gbWFya0Fzc2V0RXJyb3I7XG5leHBvcnRzLmlzQXNzZXRFcnJvciA9IGlzQXNzZXRFcnJvcjtcbmV4cG9ydHMuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCA9IGdldENsaWVudEJ1aWxkTWFuaWZlc3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLnRoZW4oKHZhbHVlKT0+KHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpXG4gICAgKSA6IHByb207XG59XG5mdW5jdGlvbiBoYXNQcmVmZXRjaChsaW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgcmV0dXJuKC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgICAvLyB3aXRoIHJlbExpc3Quc3VwcG9ydFxuICAgICAgICAoISF3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgISFkb2N1bWVudC5kb2N1bWVudE1vZGUpIHx8IGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgY2FuUHJlZmV0Y2ggPSBoYXNQcmVmZXRjaCgpO1xuZnVuY3Rpb24gcHJlZmV0Y2hWaWFEb20oaHJlZiwgYXMsIGxpbmspIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKT0+e1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl1gKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcygpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgICAgIGlmIChhcykgbGluay5hcyA9IGFzO1xuICAgICAgICBsaW5rLnJlbCA9IGBwcmVmZXRjaGA7XG4gICAgICAgIGxpbmsuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOO1xuICAgICAgICBsaW5rLm9ubG9hZCA9IHJlcztcbiAgICAgICAgbGluay5vbmVycm9yID0gcmVqO1xuICAgICAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0pO1xufVxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpO1xuZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyO1xufVxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNyYywgc2NyaXB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgICAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKT0+cmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpXG4gICAgICAgIDtcbiAgICAgICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXG4gICAgICAgIC8vICAgIGJyb3dzZXIgYmVnaW5zIHRvIGZldGNoLlxuICAgICAgICBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOO1xuICAgICAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxuICAgICAgICAvLyAgICBtdXN0IGJlIGFwcGVuZGVkIGZvciBmZXRjaGluZyB0byBzdGFydC5cbiAgICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuLy8gV2Ugd2FpdCBmb3IgcGFnZXMgdG8gYmUgYnVpbHQgaW4gZGV2IGJlZm9yZSB3ZSBzdGFydCB0aGUgcm91dGUgdHJhbnNpdGlvblxuLy8gdGltZW91dCB0byBwcmV2ZW50IGFuIHVuLW5lY2Vzc2FyeSBoYXJkIG5hdmlnYXRpb24gaW4gZGV2ZWxvcG1lbnQuXG5sZXQgZGV2QnVpbGRQcm9taXNlO1xuLy8gUmVzb2x2ZSBhIHByb21pc2UgdGhhdCB0aW1lcyBvdXQgYWZ0ZXIgZ2l2ZW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kcy5cbmZ1bmN0aW9uIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQocCwgbXMsIGVycikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHAudGhlbigocik9PntcbiAgICAgICAgICAgIC8vIFJlc29sdmVkLCBjYW5jZWwgdGhlIHRpbWVvdXRcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAvLyBXZSB3cmFwIHRoZXNlIGNoZWNrcyBzZXBhcmF0ZWx5IGZvciBiZXR0ZXIgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIGluXG4gICAgICAgIC8vIHByb2R1Y3Rpb24gYnVuZGxlcy5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAoZGV2QnVpbGRQcm9taXNlIHx8IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBtcylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgbXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkge1xuICAgIGlmIChzZWxmLl9fQlVJTERfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpO1xuICAgIH1cbiAgICBjb25zdCBvbkJ1aWxkTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgICAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQjtcbiAgICAgICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQob25CdWlsZE1hbmlmZXN0LCBNU19NQVhfSURMRV9ERUxBWSwgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpLCBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCBlbnRyeXBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2FkZWRTY3JpcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjKSB7XG4gICAgICAgIGxldCBwcm9tID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjKTtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWRTY3JpcHRzLnNldChzcmMsIHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSk7XG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFN0eWxlU2hlZXQoaHJlZikge1xuICAgICAgICBsZXQgcHJvbSA9IHN0eWxlU2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlU2hlZXRzLnNldChocmVmLCBwcm9tID0gZmV0Y2goaHJlZikudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0eWxlc2hlZXQ6ICR7aHJlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpPT4oe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICB0aHJvdyBtYXJrQXNzZXRFcnJvcihlcnIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aGVuRW50cnlwb2ludCAocm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoRnV0dXJlKHJvdXRlLCBlbnRyeXBvaW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50cnlwb2ludCAocm91dGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKS50aGVuKChmbik9PmZuKClcbiAgICAgICAgICAgICkudGhlbigoZXhwb3J0cyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogZXhwb3J0cyAmJiBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0c1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAsIChlcnIpPT4oe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkudGhlbigoaW5wdXQpPT57XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKTtcbiAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAob2xkICYmICdyZXNvbHZlJyBpbiBvbGQpIG9sZC5yZXNvbHZlKGlucHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBsb2FkUm91dGUgKHJvdXRlLCBwcmVmZXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIHJvdXRlcywgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUZpbGVzUHJvbWlzZSA9IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKS50aGVuKCh7IHNjcmlwdHMgLCBjc3MgIH0pPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpID8gW10gOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksIFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKS50aGVuKChlbnRyeXBvaW50KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcmVzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZUZpbGVzUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUZpbGVzUHJvbWlzZS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KHJvdXRlRmlsZXNQcm9taXNlLCBNU19NQVhfSURMRV9ERUxBWSwgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YCkpKS50aGVuKCh7IGVudHJ5cG9pbnQgLCBzdHlsZXMgIH0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgfSwgZW50cnlwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InIGluIGVudHJ5cG9pbnQgPyBlbnRyeXBvaW50IDogcmVzO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSBlcnJvcnMgZHVyaW5nIHByZWZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwcmVmZXRjaCAocm91dGUpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcbiAgICAgICAgICAgIC8vIExpY2Vuc2U6IEFwYWNoZSAyLjBcbiAgICAgICAgICAgIGxldCBjbjtcbiAgICAgICAgICAgIGlmIChjbiA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNuLnNhdmVEYXRhIHx8IC8yZy8udGVzdChjbi5lZmZlY3RpdmVUeXBlKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKS50aGVuKChvdXRwdXQpPT5Qcm9taXNlLmFsbChjYW5QcmVmZXRjaCA/IG91dHB1dC5zY3JpcHRzLm1hcCgoc2NyaXB0KT0+cHJlZmV0Y2hWaWFEb20oc2NyaXB0LCAnc2NyaXB0JylcbiAgICAgICAgICAgICAgICApIDogW10pXG4gICAgICAgICAgICApLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnRoaXMubG9hZFJvdXRlKHJvdXRlLCB0cnVlKS5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KS5jYXRjaCgvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm91dGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcm91dGVyLmRlZmF1bHQ7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aXRoUm91dGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2l0aFJvdXRlci5kZWZhdWx0O1xuICAgIH1cbn0pO1xuZXhwb3J0cy51c2VSb3V0ZXIgPSB1c2VSb3V0ZXI7XG5leHBvcnRzLmNyZWF0ZVJvdXRlciA9IGNyZWF0ZVJvdXRlcjtcbmV4cG9ydHMubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlID0gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcm91dGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpKTtcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xudmFyIF93aXRoUm91dGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93aXRoLXJvdXRlclwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5jb25zdCBzaW5nbGV0b25Sb3V0ZXIgPSB7XG4gICAgcm91dGVyOiBudWxsLFxuICAgIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgICByZWFkeSAoY2IpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAgICdwYXRobmFtZScsXG4gICAgJ3JvdXRlJyxcbiAgICAncXVlcnknLFxuICAgICdhc1BhdGgnLFxuICAgICdjb21wb25lbnRzJyxcbiAgICAnaXNGYWxsYmFjaycsXG4gICAgJ2Jhc2VQYXRoJyxcbiAgICAnbG9jYWxlJyxcbiAgICAnbG9jYWxlcycsXG4gICAgJ2RlZmF1bHRMb2NhbGUnLFxuICAgICdpc1JlYWR5JyxcbiAgICAnaXNQcmV2aWV3JyxcbiAgICAnaXNMb2NhbGVEb21haW4nLFxuICAgICdkb21haW5Mb2NhbGVzJywgXG5dO1xuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAgICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgICAnaGFzaENoYW5nZUNvbXBsZXRlJywgXG5dO1xuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgICAncHVzaCcsXG4gICAgJ3JlcGxhY2UnLFxuICAgICdyZWxvYWQnLFxuICAgICdiYWNrJyxcbiAgICAncHJlZmV0Y2gnLFxuICAgICdiZWZvcmVQb3BTdGF0ZScsIFxuXTtcbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gICAgZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIF9yb3V0ZXIuZGVmYXVsdC5ldmVudHM7XG4gICAgfVxufSk7XG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCk9PntcbiAgICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gICAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gICAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgIHNpbmdsZXRvblJvdXRlcltmaWVsZF0gPSAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCk7XG4gICAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpO1xuICAgIH07XG59KTtcbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCk9PntcbiAgICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCk9PntcbiAgICAgICAgX3JvdXRlci5kZWZhdWx0LmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZygxKX1gO1xuICAgICAgICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlcjtcbiAgICAgICAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBnZXRSb3V0ZXIoKSB7XG4gICAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgKyAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgb24gdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG52YXIgX2RlZmF1bHQgPSBzaW5nbGV0b25Sb3V0ZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbmZ1bmN0aW9uIHVzZVJvdXRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlciguLi5hcmdzKSB7XG4gICAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBfcm91dGVyLmRlZmF1bHQoLi4uYXJncyk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKT0+Y2IoKVxuICAgICk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW107XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG5mdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKSB7XG4gICAgY29uc3QgX3JvdXRlcjEgPSByb3V0ZXI7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKXtcbiAgICAgICAgaWYgKHR5cGVvZiBfcm91dGVyMVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKEFycmF5LmlzQXJyYXkoX3JvdXRlcjFbcHJvcGVydHldKSA/IFtdIDoge1xuICAgICAgICAgICAgfSwgX3JvdXRlcjFbcHJvcGVydHldKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcjFbcHJvcGVydHldO1xuICAgIH1cbiAgICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gICAgaW5zdGFuY2UuZXZlbnRzID0gX3JvdXRlci5kZWZhdWx0LmV2ZW50cztcbiAgICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgICAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIHJldHVybiBfcm91dGVyMVtmaWVsZF0oLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZUludGVyc2VjdGlvbiA9IHVzZUludGVyc2VjdGlvbjtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX3JlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzZXRSZWYgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIGlmICh1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgaWYgKGVsICYmIGVsLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShlbCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSlcbiAgICAgICAgICAgICwge1xuICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VmlzaWJsZSh0cnVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2V0UmVmLFxuICAgICAgICB2aXNpYmxlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnO1xuICAgIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXJcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvc2VkQ29tcG9uZW50KSB7XG4gICAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICByb3V0ZXI6ICgwLCBfcm91dGVyKS51c2VSb3V0ZXIoKVxuICAgICAgICB9LCBwcm9wcykpKTtcbiAgICB9XG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzO1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLm9yaWdHZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5vcmlnR2V0SW5pdGlhbFByb3BzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbiAgICAgICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWA7XG4gICAgfVxuICAgIHJldHVybiBXaXRoUm91dGVyV3JhcHBlcjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aC1yb3V0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldERvbWFpbkxvY2FsZSA9IGdldERvbWFpbkxvY2FsZTtcbmV4cG9ydHMuYWRkTG9jYWxlID0gYWRkTG9jYWxlO1xuZXhwb3J0cy5kZWxMb2NhbGUgPSBkZWxMb2NhbGU7XG5leHBvcnRzLmhhc0Jhc2VQYXRoID0gaGFzQmFzZVBhdGg7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG5leHBvcnRzLmRlbEJhc2VQYXRoID0gZGVsQmFzZVBhdGg7XG5leHBvcnRzLmlzTG9jYWxVUkwgPSBpc0xvY2FsVVJMO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUFzID0gaW50ZXJwb2xhdGVBcztcbmV4cG9ydHMucmVzb2x2ZUhyZWYgPSByZXNvbHZlSHJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9kZW5vcm1hbGl6ZVBhZ2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG52YXIgX25vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG52YXIgX3BhcnNlUmVsYXRpdmVVcmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3Jlc29sdmVSZXdyaXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmxldCBkZXRlY3REb21haW5Mb2NhbGU7XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG59XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoID09PSAnLycgPyAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeCkgOiBgJHtwcmVmaXh9JHtwYXRoTm9RdWVyeUhhc2gocGF0aCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aH1gIDogcGF0aDtcbn1cbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBsb2NhbGUgPSBsb2NhbGUgfHwgKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGgsIGxvY2FsZXMpLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIGxvY2FsZSk7XG4gICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHtiYXNlUGF0aCB8fCAnJ30ke2xvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke2xvY2FsZX1gfSR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSwgZGVmYXVsdExvY2FsZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCBwYXRoTG93ZXIgPSBwYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBsb2NhbGVMb3dlciA9IGxvY2FsZSAmJiBsb2NhbGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSAmJiBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiYgIXBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSAmJiBwYXRoTG93ZXIgIT09ICcvJyArIGxvY2FsZUxvd2VyID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpIDogcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBkZWxMb2NhbGUocGF0aCwgbG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIChwYXRoTG93ZXIuc3RhcnRzV2l0aCgnLycgKyBsb2NhbGVMb3dlciArICcvJykgfHwgcGF0aExvd2VyID09PSAnLycgKyBsb2NhbGVMb3dlcikgPyAocGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/ICcvJyA6ICcnKSArIHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gcGF0aE5vUXVlcnlIYXNoKHBhdGgpIHtcbiAgICBjb25zdCBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJyk7XG59XG5mdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoKSB7XG4gICAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCk7XG59XG5mdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpIHx8IHVybC5zdGFydHNXaXRoKCcjJykgfHwgdXJsLnN0YXJ0c1dpdGgoJz8nKSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJztcbiAgICBjb25zdCBkeW5hbWljUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzO1xuICAgIGNvbnN0IGR5bmFtaWNNYXRjaGVzID0gLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fCAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnk7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKTtcbiAgICBpZiAoIXBhcmFtcy5ldmVyeSgocGFyYW0pPT57XG4gICAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJztcbiAgICAgICAgY29uc3QgeyByZXBlYXQgLCBvcHRpb25hbCAgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dO1xuICAgICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gO1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiYgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9IGludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UocmVwbGFjZWQsIHJlcGVhdCA/IHZhbHVlLm1hcCgvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XG4gICAgICAgIC8vIHBhdGggZGVsaW1pdGVyIGVzY2FwZWQgc2luY2UgdGhleSBhcmUgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcbiAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXG4gICAgICAgIChzZWdtZW50KT0+ZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICkuam9pbignLycpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgJy8nKTtcbiAgICB9KSkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGZpbHRlcmVkUXVlcnkgPSB7XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkUXVlcnk7XG59XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnN1YnN0cih1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdCgnPycpO1xuICAgIGlmICgodXJsUGFydHNbMF0gfHwgJycpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byBuZXh0L3JvdXRlcjogJHt1cmxBc1N0cmluZ30sIHJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZmApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscykubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogJycpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICB1cmxBc1N0cmluZ1xuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKHVybEFzU3RyaW5nLnN0YXJ0c1dpdGgoJyMnKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsICdodHRwOi8vbicpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gJyc7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZykuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgLCBwYXJhbXMgIH0gPSBpbnRlcnBvbGF0ZUFzKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgY29uc3QgaHJlZkhhZE9yaWdpbiA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFnZSkgJiYgKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge1xuICAgIH1cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgfSkudGhlbigocmVzKT0+e1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AuXG4gICAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLm1hcmtBc3NldEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuY2xhc3MgUm91dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZTEsIHF1ZXJ5MSwgYXMxLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50OiBDb21wb25lbnQxICwgZXJyOiBlcnIxICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gICAgICAgIHRoaXMuc2RjID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbi1mbGlnaHQgU2VydmVyIERhdGEgUmVxdWVzdHMsIGZvciBkZWR1cGluZ1xuICAgICAgICB0aGlzLnNkciA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faWR4ID0gMDtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IHBhdGhuYW1lMSAsIHF1ZXJ5OiBxdWVyeTEgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lMSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeTFcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXM6IGFzMSAsIG9wdGlvbnMgLCBpZHggIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pZHggPSBpZHg7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBwYXRobmFtZTEgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhczEgPT09IHRoaXMuYXNQYXRoICYmIHBhdGhuYW1lMSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMxLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICB0aGlzLnJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZTEpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lMSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQxLFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnI6IGVycjEsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTE7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTE7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhdGhuYW1lMSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYXNQYXRoID0gYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZTEgOiBhczE7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2s7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIWlzUHJldmlldztcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISFkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmIChhczEuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMxICE9PSBwYXRobmFtZTE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUxKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5MVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsb2FkKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovIGJhY2soKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRSZXNvbHZlSHJlZiA9IHVybCA9PT0gYXMgfHwgb3B0aW9ucy5faCB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZjtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICBpZiAob3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gdGhpcy5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChyZWYgPSB0aGlzLmxvY2FsZXMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmluY2x1ZGVzKHRoaXMubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHthZGRCYXNlUGF0aChgJHt0aGlzLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke3RoaXMubG9jYWxlfWB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nKX1gO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSBhZGRCYXNlUGF0aChhZGRMb2NhbGUoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgbGV0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IHRoaXMubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZTogcGF0aG5hbWUxICwgcXVlcnk6IHF1ZXJ5MSAgfSA9IHBhcnNlZDtcbiAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IGF3YWl0ICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lMSA9IHBhdGhuYW1lMSA/ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUxKSkgOiBwYXRobmFtZTE7XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZTEgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoY2xlYW5lZEFzLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5MSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKVxuICAgICAgICAgICAgICAgICwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTEgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lMSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lMSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTEgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lMSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZTEpO1xuICAgICAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgKyBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcyk7XG4gICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGUgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeTEpIDoge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5MVtwYXJhbV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtzaG91bGRJbnRlcnBvbGF0ZSA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5MSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5MSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUxLCBxdWVyeTEsIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIGxldCB7IGVycm9yICwgcHJvcHMgLCBfX05fU1NHICwgX19OX1NTUCAgfSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgaWYgKChfX05fU1NHIHx8IF9fTl9TU1ApICYmIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnBhZ2VQcm9wcyAmJiBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8obm90Rm91bmRSb3V0ZSwgbm90Rm91bmRSb3V0ZSwgcXVlcnkxLCBhcywgcmVzb2x2ZWRBcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBDb21wID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB3aW5kb3cubmV4dC5pc1ByZXJlbmRlcmVkID0gYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJiAhcm91dGVJbmZvLkNvbXBvbmVudC5nZXRJbml0aWFsUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5faCAmJiBwYXRobmFtZTEgPT09ICcvX2Vycm9yJyAmJiAoKHJlZiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmMSA9IHJlZi5wYWdlUHJvcHMpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMucm91dGUgPT09IHJvdXRlO1xuICAgICAgICAgICAgdmFyIF9zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPT0gbnVsbCAmJiBfc2Nyb2xsICE9PSB2b2lkIDAgPyBfc2Nyb2xsIDogIWlzVmFsaWRTaGFsbG93Um91dGU7XG4gICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQocm91dGUsIHBhdGhuYW1lMSwgcXVlcnkxLCBjbGVhbmVkQXMsIHJvdXRlSW5mbywgZm9yY2VkU2Nyb2xsICE9PSBudWxsICYmIGZvcmNlZFNjcm9sbCAhPT0gdm9pZCAwID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGwpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICBpZiAoZXJyMS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnIxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8ICgwLCBfdXRpbHMpLmdldFVSTCgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgJycsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVMb2FkZXIpLmlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBDb21wb25lbnQxO1xuICAgICAgICAgICAgbGV0IHN0eWxlU2hlZXRzO1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQxID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygc3R5bGVTaGVldHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgKHsgcGFnZTogQ29tcG9uZW50MSAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudDEsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKHJvdXRlSW5mb0VyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvID0gZXhpc3RpbmdSb3V0ZUluZm8gJiYgJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvID8gdW5kZWZpbmVkIDogZXhpc3RpbmdSb3V0ZUluZm87XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gPyBjYWNoZWRSb3V0ZUluZm8gOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpPT4oe1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IENvbXBvbmVudDEgLCBfX05fU1NHICwgX19OX1NTUCAgfSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YUhyZWY7XG4gICAgICAgICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgcmVzb2x2ZWRBcywgX19OX1NTRywgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhKCgpPT5fX05fU1NHID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZikgOiBfX05fU1NQID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZikgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQxLCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyMiwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5hc1BhdGggPSBhcztcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGggPSB1cmwsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lOiBwYXRobmFtZTIgIH0gPSBwYXJzZWQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUyID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lMiwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTI7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXNQYXRoLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKVxuICAgICAgICAgICAgLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUyID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lMjtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lMikge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lMiA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTI7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUyKTtcbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IHRoaXMuX2dldFN0YXRpY0RhdGEodGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHVybCwgcmVzb2x2ZWRBcywgdHJ1ZSwgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9jYWxlIDogdGhpcy5sb2NhbGUpKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksIFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSB0aGlzLmNsYyA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBlcnIyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgIXRoaXMuaXNQcmV2aWV3ICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1tjYWNoZUtleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgY29uc3QgeyBocmVmOiByZXNvdXJjZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHRoaXMuc2RyW3Jlc291cmNlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2RyW3Jlc291cmNlS2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZHJbcmVzb3VyY2VLZXldID0gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkcltyZXNvdXJjZUtleV07XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycjIpPT57XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zZHJbcmVzb3VyY2VLZXldO1xuICAgICAgICAgICAgdGhyb3cgZXJyMjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwMSAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwMSk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwMSwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRDb21wb25lbnRMb2FkKGFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBhcG9sbG8vY2xpZW50XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBicmFpbnRyZWUvc2FuaXRpemUtdXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBlbW90aW9uL2hhc2hcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGVtb3Rpb24vd2Vhay1tZW1vaXplXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBncmFwaHFsLXRvb2xzL3NjaGVtYVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAZ3JhcGhxbC10cy9zY2hlbWFcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRoLWNvbnRleHRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGdyYXBocWwtdHMvc2NoZW1hL2FwaS13aXRob3V0LWNvbnRleHRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLW5leHQva2V5c3RvbmUvX19faW50ZXJuYWwtZG8tbm90LXVzZS13aWxsLWJyZWFrLWluLXBhdGNoL2FkbWluLXVpL3BhZ2VzL0FwcFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtbmV4dC9rZXlzdG9uZS9hZG1pbi11aS9jb250ZXh0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS1uZXh0L2tleXN0b25lL2ZpZWxkcy90eXBlcy9yZWxhdGlvbnNoaXAvdmlld3MvUmVsYXRpb25zaGlwU2VsZWN0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9idXR0b25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2NvcmVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ZpZWxkc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxlcnRUcmlhbmdsZUljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0FsaWduQ2VudGVySWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25MZWZ0SWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvQWxpZ25SaWdodEljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0JvbGRJY29uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9DaGV2cm9uRG93bkljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0NoZXZyb25SaWdodEljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL0NvZGVJY29uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9Db2x1bW5zSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvRXh0ZXJuYWxMaW5rSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvRXllSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvRXllT2ZmSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvSXRhbGljSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTGlua0ljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01heGltaXplMkljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01pbmltaXplMkljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2ljb25zL2ljb25zL01pbnVzSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvTW9yZUhvcml6b250YWxJY29uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9pY29ucy9pY29ucy9QbHVzSWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvVHJhc2gySWNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvaWNvbnMvaWNvbnMvWEljb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL2xvYWRpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL21vZGFsc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvbm90aWNlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9waWxsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9wb3BvdmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBrZXlzdG9uZS11aS9zZWdtZW50ZWQtY29udHJvbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAa2V5c3RvbmUtdWkvdG9hc3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQGtleXN0b25lLXVpL3Rvb2x0aXBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXBvbGxvLXVwbG9hZC1jbGllbnRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXBwbHktcmVmXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ5dGVzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcHktdG8tY2xpcGJvYXJkXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRhdGUtZm5zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZHVtYi1wYXNzd29yZHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdyYXBocWxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ3JhcGhxbC10eXBlLWpzb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ3JhcGhxbC11cGxvYWQvcHVibGljL0dyYXBoUUxVcGxvYWQuanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaW50ZXJzZWN0aW9uLW9ic2VydmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImlzLWhvdGtleVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtYXRjaC1zb3J0ZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibWRhc3QtdXRpbC1kZWZpbml0aW9uc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtZGFzdC11dGlsLWZyb20tbWFya2Rvd25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbC9mcm9tLW1hcmtkb3duXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2gvZnJvbS1tYXJrZG93blwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2hcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGguanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbWl0dC5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZS5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLmpzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV4dC9yb3V0ZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2xhdGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic2xhdGUtaGlzdG9yeVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzbGF0ZS1yZWFjdFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dWlkXCIpOyIsIi8qIChpZ25vcmVkKSAqLyJdLCJuYW1lcyI6WyJnZXRBcHAiLCJ2aWV3MCIsInZpZXcxIiwidmlldzIiLCJ2aWV3MyIsInZpZXc0IiwidmlldzUiLCJ2aWV3NiIsInZpZXc3IiwidmlldzgiLCJ2aWV3OSIsImFkbWluQ29uZmlnIiwibGF6eU1ldGFkYXRhUXVlcnkiLCJmaWVsZFZpZXdzIiwiYWRtaW5NZXRhSGFzaCIsImFwaVBhdGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9yb3V0ZXIiLCJfcm91dGVyMSIsIl91c2VJbnRlcnNlY3Rpb24iLCJvYmoiLCJfX2VzTW9kdWxlIiwicHJlZmV0Y2hlZCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImlzTG9jYWxVUkwiLCJjYXRjaCIsImVyciIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwiaW5kZXhPZiIsIkxpbmsiLCJwcm9wcyIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImtleXMiLCJmb3JFYWNoIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJwIiwidXNlUm91dGVyIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsImNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2hpbGRSZWYiLCJyZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsInNob3VsZFByZWZldGNoIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsIm9uQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwib25Nb3VzZUVudGVyIiwicHJpb3JpdHkiLCJ0eXBlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsIl9kZWZhdWx0IiwicmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2giLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInBhdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInRlc3QiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwic2VsZiIsImJpbmQiLCJ3aW5kb3ciLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJpZCIsImNsZWFyVGltZW91dCIsIm1hcmtBc3NldEVycm9yIiwiaXNBc3NldEVycm9yIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsImNyZWF0ZVJvdXRlTG9hZGVyIiwiX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSIsIl9yZXF1ZXN0SWRsZUNhbGxiYWNrIiwiTVNfTUFYX0lETEVfREVMQVkiLCJ3aXRoRnV0dXJlIiwibWFwIiwiZ2VuZXJhdG9yIiwiZW50cnkiLCJnZXQiLCJmdXR1cmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHJvbSIsInNldCIsInRoZW4iLCJoYXNQcmVmZXRjaCIsImxpbmsiLCJkb2N1bWVudCIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiY2FuUHJlZmV0Y2giLCJwcmVmZXRjaFZpYURvbSIsInJlcyIsInJlaiIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsIl9fTkVYVF9DUk9TU19PUklHSU4iLCJvbmxvYWQiLCJvbmVycm9yIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImFwcGVuZFNjcmlwdCIsInNyYyIsInNjcmlwdCIsInJlamVjdCIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwibXMiLCJjYW5jZWxsZWQiLCJyIiwiX19CVUlMRF9NQU5JRkVTVCIsIm9uQnVpbGRNYW5pZmVzdCIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJnZXRGaWxlc0ZvclJvdXRlIiwiYXNzZXRQcmVmaXgiLCJyb3V0ZSIsInNjcmlwdHMiLCJlbmNvZGVVUkkiLCJjc3MiLCJtYW5pZmVzdCIsImFsbEZpbGVzIiwiZmlsdGVyIiwidiIsImVudHJ5cG9pbnRzIiwiTWFwIiwibG9hZGVkU2NyaXB0cyIsInN0eWxlU2hlZXRzIiwicm91dGVzIiwibWF5YmVFeGVjdXRlU2NyaXB0IiwiZmV0Y2hTdHlsZVNoZWV0IiwiZmV0Y2giLCJvayIsInRleHQiLCJjb250ZW50Iiwid2hlbkVudHJ5cG9pbnQiLCJvbkVudHJ5cG9pbnQiLCJleGVjdXRlIiwiZm4iLCJjb21wb25lbnQiLCJlcnJvciIsImlucHV0Iiwib2xkIiwibG9hZFJvdXRlIiwicm91dGVGaWxlc1Byb21pc2UiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiZmluYWxseSIsImFzc2lnbiIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwiZWZmZWN0aXZlVHlwZSIsIm91dHB1dCIsImVudW1lcmFibGUiLCJfd2l0aFJvdXRlciIsImNyZWF0ZVJvdXRlciIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIl9yb3V0ZXJDb250ZXh0Iiwic2luZ2xldG9uUm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInB1c2giLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJldmVudHMiLCJmaWVsZCIsImdldFJvdXRlciIsIm9uIiwiZXZlbnRGaWVsZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIiwiX3NpbmdsZXRvblJvdXRlciIsIm1lc3NhZ2UiLCJzdGFjayIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiaW5zdGFuY2UiLCJwcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwidW5kZWZpbmVkIiwidGFnTmFtZSIsIm9ic2VydmUiLCJpZGxlQ2FsbGJhY2siLCJlbGVtZW50IiwiY2FsbGJhY2siLCJvYnNlcnZlciIsImVsZW1lbnRzIiwiY3JlYXRlT2JzZXJ2ZXIiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsIm9ic2VydmVycyIsImVudHJpZXMiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwid2l0aFJvdXRlciIsIkNvbXBvc2VkQ29tcG9uZW50IiwiV2l0aFJvdXRlcldyYXBwZXIiLCJnZXRJbml0aWFsUHJvcHMiLCJvcmlnR2V0SW5pdGlhbFByb3BzIiwibmFtZSIsImRpc3BsYXlOYW1lIiwiZGVsTG9jYWxlIiwiaGFzQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsImludGVycG9sYXRlQXMiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIl9yb3V0ZUxvYWRlciIsIl9kZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiX25vcm1hbGl6ZUxvY2FsZVBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc0R5bmFtaWMiLCJfcGFyc2VSZWxhdGl2ZVVybCIsIl9xdWVyeXN0cmluZyIsIl9yZXNvbHZlUmV3cml0ZXMiLCJfcm91dGVNYXRjaGVyIiwiX3JvdXRlUmVnZXgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwiYmFzZVBhdGgiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFkZFBhdGhQcmVmaXgiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aE5vUXVlcnlIYXNoIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdGVkTG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJodHRwIiwiZG9tYWluIiwicGF0aG5hbWUiLCJwYXRoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUxvd2VyIiwibGVuZ3RoIiwic3Vic3RyIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsInVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJyZXN1bHQiLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJmaWx0ZXJlZFF1ZXJ5IiwiaW5jbHVkZXMiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInVybFBhcnRzIiwic3BsaXQiLCJub3JtYWxpemVkVXJsIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwiYXNQYXRoIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsImhhc2giLCJzdHJpcE9yaWdpbiIsInByZXBhcmVVcmxBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwic29tZSIsInBhZ2UiLCJyZSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsImhpc3RvcnkiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImNyZWRlbnRpYWxzIiwic3RhdHVzIiwianNvbiIsImRhdGEiLCJub3RGb3VuZCIsImZldGNoTmV4dERhdGEiLCJkYXRhSHJlZiIsImlzU2VydmVyUmVuZGVyIiwiUm91dGVyIiwiY29uc3RydWN0b3IiLCJwYXRobmFtZTEiLCJxdWVyeTEiLCJhczEiLCJpbml0aWFsUHJvcHMiLCJwYWdlTG9hZGVyIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsIkNvbXBvbmVudDEiLCJlcnIxIiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImlzUHJldmlldyIsInNkYyIsInNkciIsIl9pZHgiLCJvblBvcFN0YXRlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImdldFVSTCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImlkeCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ4IiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwicGFyc2UiLCJwYXJzZVJlbGF0aXZlVXJsIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwiX3NoYWxsb3ciLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsIl9fTl9TU0ciLCJfX05fU1NQIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsInN1YiIsImNsYyIsIl93cmFwQXBwIiwiaXNSZWFkeSIsImdzc3AiLCJnaXAiLCJhcHBHaXAiLCJnc3AiLCJsb2NhdGlvbiIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJob3N0bmFtZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsInJlbG9hZCIsImJhY2siLCJtZXRob2QiLCJzaG91bGRSZXNvbHZlSHJlZiIsIl9oIiwicHJldkxvY2FsZSIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiYXNOb0Jhc2VQYXRoIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJyb3V0ZVByb3BzIiwiX2luRmxpZ2h0Um91dGUiLCJhYm9ydENvbXBvbmVudExvYWQiLCJjbGVhbmVkQXMiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJlbWl0Iiwic2Nyb2xsVG9IYXNoIiwibm90aWZ5IiwicGFyc2VkIiwicmV3cml0ZXMiLCJnZXRQYWdlTGlzdCIsIl9fcmV3cml0ZXMiLCJ1cmxJc05ldyIsInJld3JpdGVzUmVzdWx0IiwibWF0Y2hlZFBhZ2UiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJlZjEiLCJyb3V0ZUluZm8iLCJnZXRSb3V0ZUluZm8iLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJuZXdVcmwiLCJuZXdBcyIsIl9fTl9QUkVWSUVXIiwibm90Rm91bmRSb3V0ZSIsImZldGNoQ29tcG9uZW50IiwiYXBwQ29tcCIsIm5leHQiLCJpc1ByZXJlbmRlcmVkIiwic3RhdHVzQ29kZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfc2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiZ2lwRXJyIiwicm91dGVJbmZvRXJyIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXREYXRhSHJlZiIsIl9nZXREYXRhIiwiX2dldFN0YXRpY0RhdGEiLCJfZ2V0U2VydmVyRGF0YSIsImVycjIiLCJiZWZvcmVQb3BTdGF0ZSIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwic2Nyb2xsVG8iLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwicGF0aG5hbWUyIiwiX2lzU3NnIiwiaXNTc2ciLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImNhY2hlS2V5IiwicmVzb3VyY2VLZXkiLCJjdHgiLCJBcHAxIiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9